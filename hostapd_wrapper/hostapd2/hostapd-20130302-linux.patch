diff -purN hostapd-20130302/.dep_files hostapd-20130302-linux/.dep_files
--- hostapd-20130302/.dep_files	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/.dep_files	2013-07-04 11:17:58.000000000 -0400
@@ -0,0 +1 @@
+9a92d7a9c094e136aab269d09a5078ef
diff -purN hostapd-20130302/hostapd/.config hostapd-20130302-linux/hostapd/.config
--- hostapd-20130302/hostapd/.config	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/hostapd/.config	2013-07-06 06:07:21.000000000 -0400
@@ -0,0 +1,169 @@
+# Example hostapd build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cass, these lines should use += in order not
+# to override previous values of the variables.
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+CONFIG_LIBNL_TINY=y
+
+# Driver interface for wired authenticator
+CONFIG_DRIVER_WIRED=y
+
+# Driver interface for madwifi driver
+#CONFIG_DRIVER_MADWIFI=y
+#CFLAGS += -I../../madwifi # change to the madwifi source directory
+
+# Driver interface for Prism54 driver
+#CONFIG_DRIVER_PRISM54=y
+
+# Driver interface for drivers using the nl80211 kernel interface
+CONFIG_DRIVER_NL80211=y
+# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
+# shipped with your distribution yet. If that is the case, you need to build
+# newer libnl version and point the hostapd build to use it.
+#LIBNL=/usr/src/libnl
+#CFLAGS += -I$(LIBNL)/include
+#LIBS += -L$(LIBNL)/lib
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+
+# Driver interface for no driver (e.g., RADIUS server only)
+#CONFIG_DRIVER_NONE=y
+
+# IEEE 802.11F/IAPP
+CONFIG_IAPP=y
+
+# WPA2/IEEE 802.11i RSN pre-authentication
+CONFIG_RSN_PREAUTH=y
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Integrated EAP server
+CONFIG_EAP=y
+
+# EAP-MD5 for the integrated EAP server
+CONFIG_EAP_MD5=y
+
+# EAP-TLS for the integrated EAP server
+CONFIG_EAP_TLS=y
+
+# EAP-MSCHAPv2 for the integrated EAP server
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-PEAP for the integrated EAP server
+CONFIG_EAP_PEAP=y
+
+# EAP-GTC for the integrated EAP server
+CONFIG_EAP_GTC=y
+
+# EAP-TTLS for the integrated EAP server
+CONFIG_EAP_TTLS=y
+
+# EAP-SIM for the integrated EAP server
+#CONFIG_EAP_SIM=y
+
+# EAP-AKA for the integrated EAP server
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' for the integrated EAP server
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# EAP-PAX for the integrated EAP server
+#CONFIG_EAP_PAX=y
+
+# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-SAKE for the integrated EAP server
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK for the integrated EAP server
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-FAST for the integrated EAP server
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# Wi-Fi Protected Setup (WPS)
+#CONFIG_WPS=y
+# Enable UPnP support for external WPS Registrars
+#CONFIG_WPS_UPNP=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# Trusted Network Connect (EAP-TNC)
+#CONFIG_EAP_TNC=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# RADIUS authentication server. This provides access to the integrated EAP
+# server from external hosts using RADIUS.
+#CONFIG_RADIUS_SERVER=y
+
+# Build IPv6 support for RADIUS operations
+CONFIG_IPV6=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Use the hostapd's IEEE 802.11 authentication (ACL), but without
+# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
+#CONFIG_DRIVER_RADIUS_ACL=y
+
+# IEEE 802.11n (High Throughput) support
+CONFIG_IEEE80211N=y
+
+# Remove debugging code that is printing out debug messages to stdout.
+# This can be used to reduce the size of the hostapd considerably if debugging
+# code is not needed.
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove support for RADIUS accounting
+#CONFIG_NO_ACCOUNTING=y
+
+# Remove support for RADIUS
+#CONFIG_NO_RADIUS=y
+
+# Remove support for VLANs
+#CONFIG_NO_VLAN=y
+
+CONFIG_TLS=internal
+CONFIG_INTERNAL_LIBTOMMATH=y
+CONFIG_INTERNAL_AES=y
+NEED_AES_DEC=y
+
+CONFIG_NO_DUMP_STATE=y
+
+CONFIG_WPS=y
+CONFIG_FULL_DYNAMIC_VLAN=y
+
+CONFIG_UBUS=y
+
+CONFIG_DRIVER_CAPWAP=y
diff -purN hostapd-20130302/hostapd/config_file.c hostapd-20130302-linux/hostapd/config_file.c
--- hostapd-20130302/hostapd/config_file.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/config_file.c	2013-07-04 11:17:51.000000000 -0400
@@ -2464,6 +2464,8 @@ static int hostapd_config_fill(struct ho
 			}
 #endif /* CONFIG_IEEE80211W */
 #ifdef CONFIG_IEEE80211N
+		} else if (os_strcmp(buf, "noscan") == 0) {
+			conf->noscan = atoi(pos);
 		} else if (os_strcmp(buf, "ieee80211n") == 0) {
 			conf->ieee80211n = atoi(pos);
 		} else if (os_strcmp(buf, "ht_capab") == 0) {
@@ -2472,6 +2474,10 @@ static int hostapd_config_fill(struct ho
 					   "ht_capab", line);
 				errors++;
 			}
+		} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
+			conf->dynamic_ht40 = atoi(pos);
+			if (conf->dynamic_ht40 == 1)
+				conf->dynamic_ht40 = 1500;
 		} else if (os_strcmp(buf, "require_ht") == 0) {
 			conf->require_ht = atoi(pos);
 #endif /* CONFIG_IEEE80211N */
diff -purN hostapd-20130302/hostapd/ctrl_iface.c hostapd-20130302-linux/hostapd/ctrl_iface.c
--- hostapd-20130302/hostapd/ctrl_iface.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/ctrl_iface.c	2013-07-04 11:17:51.000000000 -0400
@@ -33,6 +33,7 @@
 #include "wps/wps.h"
 #include "config_file.h"
 #include "ctrl_iface.h"
+#include "config_file.h"
 
 
 struct wpa_ctrl_dst {
@@ -43,6 +44,7 @@ struct wpa_ctrl_dst {
 	int errors;
 };
 
+static char *reload_opts = NULL;
 
 static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
 				    const char *buf, size_t len);
@@ -152,6 +154,68 @@ static int hostapd_ctrl_iface_new_sta(st
 	return 0;
 }
 
+static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
+{
+	if (hapd->driver->stop_ap)
+		hapd->driver->stop_ap(hapd->drv_priv);
+	return 0;
+}
+
+static char *get_option(char *opt, char *str)
+{
+	int len = strlen(str);
+
+	if (!strncmp(opt, str, len))
+		return opt + len;
+	else
+		return NULL;
+}
+
+static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
+{
+	struct hostapd_config *conf;
+	char *opt, *val;
+
+	conf = hostapd_config_read(fname);
+	if (!conf)
+		return NULL;
+
+	for (opt = strtok(reload_opts, " ");
+	     opt;
+		 opt = strtok(NULL, " ")) {
+
+		if ((val = get_option(opt, "channel=")))
+			conf->channel = atoi(val);
+		else if ((val = get_option(opt, "ht_capab=")))
+			conf->ht_capab = atoi(val);
+		else if ((val = get_option(opt, "ht_capab_mask=")))
+			conf->ht_capab &= atoi(val);
+		else if ((val = get_option(opt, "sec_chan=")))
+			conf->secondary_channel = atoi(val);
+		else if ((val = get_option(opt, "hw_mode=")))
+			conf->hw_mode = atoi(val);
+		else if ((val = get_option(opt, "ieee80211n=")))
+			conf->ieee80211n = atoi(val);
+		else
+			break;
+	}
+
+	return conf;
+}
+
+static int hostapd_ctrl_iface_update(struct hostapd_data *hapd, char *txt)
+{
+	struct hostapd_config * (*config_read_cb)(const char *config_fname);
+	struct hostapd_iface *iface = hapd->iface;
+
+	config_read_cb = iface->interfaces->config_read_cb;
+	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
+	reload_opts = txt;
+
+	hostapd_reload_config(iface);
+
+	iface->interfaces->config_read_cb = config_read_cb;
+}
 
 #ifdef CONFIG_IEEE80211W
 #ifdef NEED_AP_MLME
@@ -415,6 +479,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
 	char *pos;
 	const char *pin_txt;
 
+	if (!hapd->wps)
+		return -1;
+
 	pos = os_strchr(txt, ' ');
 	if (pos)
 		*pos++ = '\0';
@@ -873,6 +940,7 @@ static void hostapd_ctrl_iface_receive(i
 	} else if (os_strncmp(buf, "RELOG", 5) == 0) {
 		if (wpa_debug_reopen_file() < 0)
 			reply_len = -1;
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "MIB") == 0) {
 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
 		if (reply_len >= 0) {
@@ -902,6 +970,12 @@ static void hostapd_ctrl_iface_receive(i
 				reply_len += res;
 		}
 #endif /* CONFIG_NO_RADIUS */
+#endif
+	} else if (os_strcmp(buf, "DOWN") == 0) {
+		hostapd_ctrl_iface_set_down(hapd);
+	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
+		hostapd_ctrl_iface_update(hapd, buf + 7);
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
 							 reply_size);
@@ -911,6 +985,7 @@ static void hostapd_ctrl_iface_receive(i
 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
 							reply_size);
+#endif
 	} else if (os_strcmp(buf, "ATTACH") == 0) {
 		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
 			reply_len = -1;
diff -purN hostapd-20130302/hostapd/defconfig hostapd-20130302-linux/hostapd/defconfig
--- hostapd-20130302/hostapd/defconfig	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/defconfig	2013-07-04 11:17:51.000000000 -0400
@@ -267,3 +267,5 @@ CONFIG_IPV6=y
 
 # Enable SQLite database support in hlr_auc_gw, EAP-SIM DB, and eap_user_file
 #CONFIG_SQLITE=y
+
+CONFIG_DRIVER_CAPWAP_WTP=y
diff -purN hostapd-20130302/hostapd/hostapd_ac.conf hostapd-20130302-linux/hostapd/hostapd_ac.conf
--- hostapd-20130302/hostapd/hostapd_ac.conf	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/hostapd/hostapd_ac.conf	2013-07-06 06:07:33.000000000 -0400
@@ -0,0 +1,3 @@
+ip_daemon_ac=127.0.0.1
+sock_path_ac=/tmp/ac_ipc_hostapd
+port_daemon_ac=5543
diff -purN hostapd-20130302/hostapd/hostapd_cli.c hostapd-20130302-linux/hostapd/hostapd_cli.c
--- hostapd-20130302/hostapd/hostapd_cli.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/hostapd_cli.c	2013-07-04 11:17:51.000000000 -0400
@@ -67,7 +67,6 @@ static const char *commands_help =
 #ifdef CONFIG_IEEE80211W
 "   sa_query <addr>      send SA Query to a station\n"
 #endif /* CONFIG_IEEE80211W */
-#ifdef CONFIG_WPS
 "   wps_pin <uuid> <pin> [timeout] [addr]  add WPS Enrollee PIN\n"
 "   wps_check_pin <PIN>  verify PIN checksum\n"
 "   wps_pbc              indicate button pushed to initiate PBC\n"
@@ -79,7 +78,6 @@ static const char *commands_help =
 #endif /* CONFIG_WPS_NFC */
 "   wps_ap_pin <cmd> [params..]  enable/disable AP PIN\n"
 "   wps_config <SSID> <auth> <encr> <key>  configure AP\n"
-#endif /* CONFIG_WPS */
 "   get_config           show current configuration\n"
 "   help                 show this usage help\n"
 "   interface [ifname]   show interfaces/select interface\n"
@@ -340,7 +338,6 @@ static int hostapd_cli_cmd_sa_query(stru
 #endif /* CONFIG_IEEE80211W */
 
 
-#ifdef CONFIG_WPS
 static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
 				   char *argv[])
 {
@@ -559,7 +556,6 @@ static int hostapd_cli_cmd_wps_config(st
 			 ssid_hex, argv[1]);
 	return wpa_ctrl_command(ctrl, buf);
 }
-#endif /* CONFIG_WPS */
 
 
 static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
@@ -805,7 +801,6 @@ static struct hostapd_cli_cmd hostapd_cl
 #ifdef CONFIG_IEEE80211W
 	{ "sa_query", hostapd_cli_cmd_sa_query },
 #endif /* CONFIG_IEEE80211W */
-#ifdef CONFIG_WPS
 	{ "wps_pin", hostapd_cli_cmd_wps_pin },
 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin },
 	{ "wps_pbc", hostapd_cli_cmd_wps_pbc },
@@ -818,7 +813,6 @@ static struct hostapd_cli_cmd hostapd_cl
 #endif /* CONFIG_WPS_NFC */
 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
 	{ "wps_config", hostapd_cli_cmd_wps_config },
-#endif /* CONFIG_WPS */
 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent },
 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
 	{ "get_config", hostapd_cli_cmd_get_config },
diff -purN hostapd-20130302/hostapd/hostapd.conf hostapd-20130302-linux/hostapd/hostapd.conf
--- hostapd-20130302/hostapd/hostapd.conf	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/hostapd.conf	2013-07-07 01:29:44.000000000 -0400
@@ -23,6 +23,7 @@ interface=wlan0
 # Use driver=none if building hostapd as a standalone RADIUS server that does
 # not control any wireless/wired driver.
 # driver=hostap
+driver=capwap
 
 # hostapd event logger configuration
 #
@@ -83,15 +84,7 @@ ctrl_interface_group=0
 ##### IEEE 802.11 related configuration #######################################
 
 # SSID to be used in IEEE 802.11 management frames
-ssid=test
-# Alternative formats for configuring SSID
-# (double quoted string, hexdump, printf-escaped string)
-#ssid2="test"
-#ssid2=74657374
-#ssid2=P"hello\nthere"
-
-# UTF-8 SSID: Whether the SSID is to be interpreted using UTF-8 encoding
-#utf8_ssid=1
+ssid=OpenWRT
 
 # Country code (ISO/IEC 3166-1). Used to set regulatory domain.
 # Set as needed to indicate country in which device is operating.
@@ -106,10 +99,8 @@ ssid=test
 #ieee80211d=1
 
 # Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,
-# ad = IEEE 802.11ad (60 GHz); a/g options are used with IEEE 802.11n, too, to
-# specify band)
 # Default: IEEE 802.11b
-hw_mode=g
+hw_mode=b
 
 # Channel number (IEEE 802.11)
 # (default: 0, i.e., not set)
@@ -171,7 +162,7 @@ fragm_threshold=2346
 # disabled (and enabled when such STAs disassociate) dynamically.
 # 0 = do not allow use of short preamble (default)
 # 1 = allow use of short preamble
-#preamble=1
+preamble=1
 
 # Station MAC address -based authentication
 # Please note that this kind of access control requires a driver that uses
@@ -194,7 +185,7 @@ macaddr_acl=0
 # Bit fields of allowed authentication algorithms:
 # bit 0 = Open System Authentication
 # bit 1 = Shared Key Authentication (requires WEP)
-auth_algs=3
+auth_algs=1
 
 # Send empty SSID in beacons and ignore probe request frames that do not
 # specify full SSID, i.e., require stations to know SSID.
@@ -206,13 +197,6 @@ auth_algs=3
 #     requests for broadcast SSID
 ignore_broadcast_ssid=0
 
-# Additional vendor specfic elements for Beacon and Probe Response frames
-# This parameter can be used to add additional vendor specific element(s) into
-# the end of the Beacon and Probe Response frames. The format for these
-# element(s) is a hexdump of the raw information elements (id+len+payload for
-# one or more elements)
-#vendor_elements=dd0411223301
-
 # TX queue parameters (EDCF / bursting)
 # tx_queue_<queue name>_<param>
 # queues: data0, data1, data2, data3, after_beacon, beacon
@@ -356,17 +340,11 @@ wmm_ac_vo_acm=0
 # the STA with a data frame.
 # default: 300 (i.e., 5 minutes)
 #ap_max_inactivity=300
-#
-# The inactivity polling can be disabled to disconnect stations based on
-# inactivity timeout so that idle stations are more likely to be disconnected
-# even if they are still in range of the AP. This can be done by setting
-# skip_inactivity_poll to 1 (default 0).
-#skip_inactivity_poll=0
 
 # Disassociate stations based on excessive transmission failures or other
 # indications of connection loss. This depends on the driver capabilities and
 # may not be available with all drivers.
-#disassoc_low_ack=1
+disassoc_low_ack=1
 
 # Maximum allowed Listen Interval (how many Beacon periods STAs are allowed to
 # remain asleep). Default: 65535 (no limit apart from field size)
@@ -433,161 +411,10 @@ wmm_ac_vo_acm=0
 # Require stations to support HT PHY (reject association if they do not)
 #require_ht=1
 
-##### IEEE 802.11ac related configuration #####################################
-
-# ieee80211ac: Whether IEEE 802.11ac (VHT) is enabled
-# 0 = disabled (default)
-# 1 = enabled
-# Note: You will also need to enable WMM for full VHT functionality.
-#ieee80211ac=1
-
-# vht_capab: VHT capabilities (list of flags)
-#
-# vht_max_mpdu_len: [MAX-MPDU-7991] [MAX-MPDU-11454]
-# Indicates maximum MPDU length
-# 0 = 3895 octets (default)
-# 1 = 7991 octets
-# 2 = 11454 octets
-# 3 = reserved
-#
-# supported_chan_width: [VHT160] [VHT160-80PLUS80]
-# Indicates supported Channel widths
-# 0 = 160 MHz & 80+80 channel widths are not supported (default)
-# 1 = 160 MHz channel width is supported
-# 2 = 160 MHz & 80+80 channel widths are supported
-# 3 = reserved
-#
-# Rx LDPC coding capability: [RXLDPC]
-# Indicates support for receiving LDPC coded pkts
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Short GI for 80 MHz: [SHORT-GI-80]
-# Indicates short GI support for reception of packets transmitted with TXVECTOR
-# params format equal to VHT and CBW = 80Mhz
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Short GI for 160 MHz: [SHORT-GI-160]
-# Indicates short GI support for reception of packets transmitted with TXVECTOR
-# params format equal to VHT and CBW = 160Mhz
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Tx STBC: [TX-STBC-2BY1]
-# Indicates support for the transmission of at least 2x1 STBC
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Rx STBC: [RX-STBC-1] [RX-STBC-12] [RX-STBC-123] [RX-STBC-1234]
-# Indicates support for the reception of PPDUs using STBC
-# 0 = Not supported (default)
-# 1 = support of one spatial stream
-# 2 = support of one and two spatial streams
-# 3 = support of one, two and three spatial streams
-# 4 = support of one, two, three and four spatial streams
-# 5,6,7 = reserved
-#
-# SU Beamformer Capable: [SU-BEAMFORMER]
-# Indicates support for operation as a single user beamformer
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# SU Beamformee Capable: [SU-BEAMFORMEE]
-# Indicates support for operation as a single user beamformee
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Compressed Steering Number of Beamformer Antennas Supported: [BF-ANTENNA-2]
-#   Beamformee's capability indicating the maximum number of beamformer
-#   antennas the beamformee can support when sending compressed beamforming
-#   feedback
-# If SU beamformer capable, set to maximum value minus 1
-# else reserved (default)
-#
-# Number of Sounding Dimensions: [SOUNDING-DIMENSION-2]
-# Beamformer's capability indicating the maximum value of the NUM_STS parameter
-# in the TXVECTOR of a VHT NDP
-# If SU beamformer capable, set to maximum value minus 1
-# else reserved (default)
-#
-# MU Beamformer Capable: [MU-BEAMFORMER]
-# Indicates support for operation as an MU beamformer
-# 0 = Not supported or sent by Non-AP STA (default)
-# 1 = Supported
-#
-# MU Beamformee Capable: [MU-BEAMFORMEE]
-# Indicates support for operation as an MU beamformee
-# 0 = Not supported or sent by AP (default)
-# 1 = Supported
-#
-# VHT TXOP PS: [VHT-TXOP-PS]
-# Indicates whether or not the AP supports VHT TXOP Power Save Mode
-#  or whether or not the STA is in VHT TXOP Power Save mode
-# 0 = VHT AP doesnt support VHT TXOP PS mode (OR) VHT Sta not in VHT TXOP PS
-#  mode
-# 1 = VHT AP supports VHT TXOP PS mode (OR) VHT Sta is in VHT TXOP power save
-#  mode
-#
-# +HTC-VHT Capable: [HTC-VHT]
-# Indicates whether or not the STA supports receiving a VHT variant HT Control
-# field.
-# 0 = Not supported (default)
-# 1 = supported
-#
-# Maximum A-MPDU Length Exponent: [MAX-A-MPDU-LEN-EXP0]..[MAX-A-MPDU-LEN-EXP7]
-# Indicates the maximum length of A-MPDU pre-EOF padding that the STA can recv
-# This field is an integer in the range of 0 to 7.
-# The length defined by this field is equal to
-# 2 pow(13 + Maximum A-MPDU Length Exponent) -1 octets
-#
-# VHT Link Adaptation Capable: [VHT-LINK-ADAPT2] [VHT-LINK-ADAPT3]
-# Indicates whether or not the STA supports link adaptation using VHT variant
-# HT Control field
-# If +HTC-VHTcapable is 1
-#  0 = (no feedback) if the STA does not provide VHT MFB (default)
-#  1 = reserved
-#  2 = (Unsolicited) if the STA provides only unsolicited VHT MFB
-#  3 = (Both) if the STA can provide VHT MFB in response to VHT MRQ and if the
-#      STA provides unsolicited VHT MFB
-# Reserved if +HTC-VHTcapable is 0
-#
-# Rx Antenna Pattern Consistency: [RX-ANTENNA-PATTERN]
-# Indicates the possibility of Rx antenna pattern change
-# 0 = Rx antenna pattern might change during the lifetime of an association
-# 1 = Rx antenna pattern does not change during the lifetime of an association
-#
-# Tx Antenna Pattern Consistency: [TX-ANTENNA-PATTERN]
-# Indicates the possibility of Tx antenna pattern change
-# 0 = Tx antenna pattern might change during the lifetime of an association
-# 1 = Tx antenna pattern does not change during the lifetime of an association
-#vht_capab=[SHORT-GI-80][HTC-VHT]
-#
-# Require stations to support VHT PHY (reject association if they do not)
-#require_vht=1
-
-# 0 = 20 or 40 MHz operating Channel width
-# 1 = 80 MHz channel width
-# 2 = 160 MHz channel width
-# 3 = 80+80 MHz channel width
-#vht_oper_chwidth=1
-#
-# center freq = 5 GHz + (5 * index)
-# So index 42 gives center freq 5.210 GHz
-# which is channel 42 in 5G band
-#
-#vht_oper_centr_freq_seg0_idx=42
-#
-# center freq = 5 GHz + (5 * index)
-# So index 159 gives center freq 5.795 GHz
-# which is channel 159 in 5G band
-#
-#vht_oper_centr_freq_seg1_idx=159
-
 ##### IEEE 802.1X-2004 related configuration ##################################
 
 # Require IEEE 802.1X authorization
-#ieee8021x=1
+ieee8021x=1
 
 # IEEE 802.1X/EAPOL version
 # hostapd is implemented based on IEEE Std 802.1X-2004 which defines EAPOL
@@ -615,7 +442,7 @@ wmm_ac_vo_acm=0
 
 # EAPOL-Key index workaround (set bit7) for WinXP Supplicant (needed only if
 # only broadcast keys are used)
-eapol_key_index_workaround=0
+eapol_key_index_workaround=1
 
 # EAP reauthentication period in seconds (default: 3600 seconds; 0 = disable
 # reauthentication).
@@ -640,8 +467,6 @@ eapol_key_index_workaround=0
 eap_server=0
 
 # Path for EAP server user database
-# If SQLite support is included, this can be set to "sqlite:/path/to/sqlite.db"
-# to use SQLite database instead of a text file.
 #eap_user_file=/etc/hostapd.eap_user
 
 # CA certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
@@ -686,18 +511,12 @@ eap_server=0
 # Fragment size for EAP methods
 #fragment_size=1400
 
-# Finite cyclic group for EAP-pwd. Number maps to group of domain parameters
-# using the IANA repository for IKE (RFC 2409).
-#pwd_group=19
-
 # Configuration data for EAP-SIM database/authentication gateway interface.
 # This is a text string in implementation specific format. The example
 # implementation in eap_sim_db.c uses this as the UNIX domain socket name for
 # the HLR/AuC gateway (e.g., hlr_auc_gw). In this case, the path uses "unix:"
-# prefix. If hostapd is built with SQLite support (CONFIG_SQLITE=y in .config),
-# database file can be described with an optional db=<path> parameter.
+# prefix.
 #eap_sim_db=unix:/tmp/hlr_auc_gw.sock
-#eap_sim_db=unix:/tmp/hlr_auc_gw.sock db=/tmp/hostapd.db
 
 # Encryption key for EAP-FAST PAC-Opaque values. This key must be a secret,
 # random value. It is configured as a 16-octet value in hex format. It can be
@@ -763,12 +582,12 @@ own_ip_addr=127.0.0.1
 # fully qualified domain name can be used here.
 # When using IEEE 802.11r, nas_identifier must be set and must be between 1 and
 # 48 octets long.
-#nas_identifier=ap.example.com
+nas_identifier=OpenWrt
 
 # RADIUS authentication server
-#auth_server_addr=127.0.0.1
-#auth_server_port=1812
-#auth_server_shared_secret=secret
+auth_server_addr=31.1.1.1
+auth_server_port=1812
+auth_server_shared_secret=SharedSecret
 
 # RADIUS accounting server
 #acct_server_addr=127.0.0.1
@@ -804,12 +623,6 @@ own_ip_addr=127.0.0.1
 # 60 (1 minute).
 #radius_acct_interim_interval=600
 
-# Request Chargeable-User-Identity (RFC 4372)
-# This parameter can be used to configure hostapd to request CUI from the
-# RADIUS server by including Chargeable-User-Identity attribute into
-# Access-Request packets.
-#radius_request_cui=1
-
 # Dynamic VLAN mode; allow RADIUS authentication server to decide which VLAN
 # is used for the stations. This information is parsed from following RADIUS
 # attributes based on RFC 3580 and RFC 2868: Tunnel-Type (value 13 = VLAN),
@@ -837,61 +650,6 @@ own_ip_addr=127.0.0.1
 # to the bridge.
 #vlan_tagged_interface=eth0
 
-# When hostapd creates a VLAN interface on vlan_tagged_interfaces, it needs
-# to know how to name it.
-# 0 = vlan<XXX>, e.g., vlan1
-# 1 = <vlan_tagged_interface>.<XXX>, e.g. eth0.1
-#vlan_naming=0
-
-# Arbitrary RADIUS attributes can be added into Access-Request and
-# Accounting-Request packets by specifying the contents of the attributes with
-# the following configuration parameters. There can be multiple of these to
-# add multiple attributes. These parameters can also be used to override some
-# of the attributes added automatically by hostapd.
-# Format: <attr_id>[:<syntax:value>]
-# attr_id: RADIUS attribute type (e.g., 26 = Vendor-Specific)
-# syntax: s = string (UTF-8), d = integer, x = octet string
-# value: attribute value in format indicated by the syntax
-# If syntax and value parts are omitted, a null value (single 0x00 octet) is
-# used.
-#
-# Additional Access-Request attributes
-# radius_auth_req_attr=<attr_id>[:<syntax:value>]
-# Examples:
-# Operator-Name = "Operator"
-#radius_auth_req_attr=126:s:Operator
-# Service-Type = Framed (2)
-#radius_auth_req_attr=6:d:2
-# Connect-Info = "testing" (this overrides the automatically generated value)
-#radius_auth_req_attr=77:s:testing
-# Same Connect-Info value set as a hexdump
-#radius_auth_req_attr=77:x:74657374696e67
-
-#
-# Additional Accounting-Request attributes
-# radius_acct_req_attr=<attr_id>[:<syntax:value>]
-# Examples:
-# Operator-Name = "Operator"
-#radius_acct_req_attr=126:s:Operator
-
-# Dynamic Authorization Extensions (RFC 5176)
-# This mechanism can be used to allow dynamic changes to user session based on
-# commands from a RADIUS server (or some other disconnect client that has the
-# needed session information). For example, Disconnect message can be used to
-# request an associated station to be disconnected.
-#
-# This is disabled by default. Set radius_das_port to non-zero UDP port
-# number to enable.
-#radius_das_port=3799
-#
-# DAS client (the host that can send Disconnect/CoA requests) and shared secret
-#radius_das_client=192.168.1.123 shared secret here
-#
-# DAS Event-Timestamp time window in seconds
-#radius_das_time_window=300
-#
-# DAS require Event-Timestamp
-#radius_das_require_event_timestamp=1
 
 ##### RADIUS authentication server configuration ##############################
 
@@ -915,7 +673,6 @@ own_ip_addr=127.0.0.1
 # Enable WPA. Setting this variable configures the AP to require WPA (either
 # WPA-PSK or WPA-RADIUS/EAP based on other configuration). For WPA-PSK, either
 # wpa_psk or wpa_passphrase must be set and wpa_key_mgmt must include WPA-PSK.
-# Instead of wpa_psk / wpa_passphrase, wpa_psk_radius might suffice.
 # For WPA-RADIUS/EAP, ieee8021x must be set (but without dynamic WEP keys),
 # RADIUS authentication server must be configured, and WPA-EAP must be included
 # in wpa_key_mgmt.
@@ -923,7 +680,7 @@ own_ip_addr=127.0.0.1
 # and/or WPA2 (full IEEE 802.11i/RSN):
 # bit0 = WPA
 # bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)
-#wpa=1
+wpa=2
 
 # WPA pre-shared keys for WPA-PSK. This can be either entered as a 256-bit
 # secret in hex format (64 hex digits), wpa_psk, or as an ASCII passphrase
@@ -940,20 +697,11 @@ own_ip_addr=127.0.0.1
 # configuration reloads.
 #wpa_psk_file=/etc/hostapd.wpa_psk
 
-# Optionally, WPA passphrase can be received from RADIUS authentication server
-# This requires macaddr_acl to be set to 2 (RADIUS)
-# 0 = disabled (default)
-# 1 = optional; use default passphrase/psk if RADIUS server does not include
-#	Tunnel-Password
-# 2 = required; reject authentication if RADIUS server does not include
-#	Tunnel-Password
-#wpa_psk_radius=0
-
 # Set of accepted key management algorithms (WPA-PSK, WPA-EAP, or both). The
 # entries are separated with a space. WPA-PSK-SHA256 and WPA-EAP-SHA256 can be
 # added to enable SHA256-based stronger algorithms.
 # (dot11RSNAConfigAuthenticationSuitesTable)
-#wpa_key_mgmt=WPA-PSK WPA-EAP
+wpa_key_mgmt=WPA-EAP
 
 # Set of accepted cipher suites (encryption algorithms) for pairwise keys
 # (unicast packets). This is a space separated list of algorithms:
@@ -965,7 +713,7 @@ own_ip_addr=127.0.0.1
 # TKIP will be used as the group cipher.
 # (dot11RSNAConfigPairwiseCiphersTable)
 # Pairwise cipher for WPA (v1) (default: TKIP)
-#wpa_pairwise=TKIP CCMP
+wpa_pairwise=CCMP
 # Pairwise cipher for RSN/WPA2 (default: use wpa_pairwise value)
 #rsn_pairwise=CCMP
 
@@ -1028,28 +776,15 @@ own_ip_addr=127.0.0.1
 # it is enabled (rsn_preauth=1).
 # 0 = PMKSA caching enabled (default)
 # 1 = PMKSA caching disabled
-#disable_pmksa_caching=0
+disable_pmksa_caching=0
 
 # okc: Opportunistic Key Caching (aka Proactive Key Caching)
 # Allow PMK cache to be shared opportunistically among configured interfaces
 # and BSSes (i.e., all configurations within a single hostapd process).
 # 0 = disabled (default)
 # 1 = enabled
-#okc=1
+okc=0
 
-# SAE threshold for anti-clogging mechanism (dot11RSNASAEAntiCloggingThreshold)
-# This parameter defines how many open SAE instances can be in progress at the
-# same time before the anti-clogging mechanism is taken into use.
-#sae_anti_clogging_threshold=5
-
-# Enabled SAE finite cyclic groups
-# SAE implementation are required to support group 19 (ECC group defined over a
-# 256-bit prime order field). All groups that are supported by the
-# implementation are enabled by default. This configuration parameter can be
-# used to specify a limited set of allowed groups. The group values are listed
-# in the IANA registry:
-# http://www.iana.org/assignments/ipsec-registry/ipsec-registry.xml#ipsec-registry-9
-#sae_groups=19 20 21 25 26
 
 ##### IEEE 802.11r configuration ##############################################
 
@@ -1273,24 +1008,6 @@ own_ip_addr=127.0.0.1
 # 12-digit, all-numeric code that identifies the consumer package.
 #upc=123456789012
 
-# WPS RF Bands (a = 5G, b = 2.4G, g = 2.4G, ag = dual band)
-# This value should be set according to RF band(s) supported by the AP if
-# hw_mode is not set. For dual band dual concurrent devices, this needs to be
-# set to ag to allow both RF bands to be advertized.
-#wps_rf_bands=ag
-
-# NFC password token for WPS
-# These parameters can be used to configure a fixed NFC password token for the
-# AP. This can be generated, e.g., with nfc_pw_token from wpa_supplicant. When
-# these parameters are used, the AP is assumed to be deployed with a NFC tag
-# that includes the matching NFC password token (e.g., written based on the
-# NDEF record from nfc_pw_token).
-#
-#wps_nfc_dev_pw_id: Device Password ID (16..65535)
-#wps_nfc_dh_pubkey: Hexdump of DH Public Key
-#wps_nfc_dh_privkey: Hexdump of DH Private Key
-#wps_nfc_dev_pw: Hexdump of Device Password
-
 ##### Wi-Fi Direct (P2P) ######################################################
 
 # Enable P2P Device management
@@ -1318,16 +1035,6 @@ own_ip_addr=127.0.0.1
 # stdoffset[dst[offset][,start[/time],end[/time]]]
 #time_zone=EST5
 
-# WNM-Sleep Mode (extended sleep mode for stations)
-# 0 = disabled (default)
-# 1 = enabled (allow stations to use WNM-Sleep Mode)
-#wnm_sleep_mode=1
-
-# BSS Transition Management
-# 0 = disabled (default)
-# 1 = enabled
-#bss_transition=1
-
 ##### IEEE 802.11u-2011 #######################################################
 
 # Enable Interworking service
@@ -1381,138 +1088,11 @@ own_ip_addr=127.0.0.1
 # Arbitrary number of Roaming Consortium OIs can be configured with each line
 # adding a new OI to the list. The first three entries are available through
 # Beacon and Probe Response frames. Any additional entry will be available only
-# through ANQP queries. Each OI is between 3 and 15 octets and is configured as
+# through ANQP queries. Each OI is between 3 and 15 octets and is configured a
 # a hexstring.
 #roaming_consortium=021122
 #roaming_consortium=2233445566
 
-# Venue Name information
-# This parameter can be used to configure one or more Venue Name Duples for
-# Venue Name ANQP information. Each entry has a two or three character language
-# code (ISO-639) separated by colon from the venue name string.
-# Note that venue_group and venue_type have to be set for Venue Name
-# information to be complete.
-#venue_name=eng:Example venue
-#venue_name=fin:Esimerkkipaikka
-
-# Network Authentication Type
-# This parameter indicates what type of network authentication is used in the
-# network.
-# format: <network auth type indicator (1-octet hex str)> [redirect URL]
-# Network Authentication Type Indicator values:
-# 00 = Acceptance of terms and conditions
-# 01 = On-line enrollment supported
-# 02 = http/https redirection
-# 03 = DNS redirection
-#network_auth_type=00
-#network_auth_type=02http://www.example.com/redirect/me/here/
-
-# IP Address Type Availability
-# format: <1-octet encoded value as hex str>
-# (ipv4_type & 0x3f) << 2 | (ipv6_type & 0x3)
-# ipv4_type:
-# 0 = Address type not available
-# 1 = Public IPv4 address available
-# 2 = Port-restricted IPv4 address available
-# 3 = Single NATed private IPv4 address available
-# 4 = Double NATed private IPv4 address available
-# 5 = Port-restricted IPv4 address and single NATed IPv4 address available
-# 6 = Port-restricted IPv4 address and double NATed IPv4 address available
-# 7 = Availability of the address type is not known
-# ipv6_type:
-# 0 = Address type not available
-# 1 = Address type available
-# 2 = Availability of the address type not known
-#ipaddr_type_availability=14
-
-# Domain Name
-# format: <variable-octet str>[,<variable-octet str>]
-#domain_name=example.com,another.example.com,yet-another.example.com
-
-# 3GPP Cellular Network information
-# format: <MCC1,MNC1>[;<MCC2,MNC2>][;...]
-#anqp_3gpp_cell_net=244,91;310,026;234,56
-
-# NAI Realm information
-# One or more realm can be advertised. Each nai_realm line adds a new realm to
-# the set. These parameters provide information for stations using Interworking
-# network selection to allow automatic connection to a network based on
-# credentials.
-# format: <encoding>,<NAI Realm(s)>[,<EAP Method 1>][,<EAP Method 2>][,...]
-# encoding:
-#	0 = Realm formatted in accordance with IETF RFC 4282
-#	1 = UTF-8 formatted character string that is not formatted in
-#	    accordance with IETF RFC 4282
-# NAI Realm(s): Semi-colon delimited NAI Realm(s)
-# EAP Method: <EAP Method>[:<[AuthParam1:Val1]>][<[AuthParam2:Val2]>][...]
-# AuthParam (Table 8-188 in IEEE Std 802.11-2012):
-# ID 2 = Non-EAP Inner Authentication Type
-#	1 = PAP, 2 = CHAP, 3 = MSCHAP, 4 = MSCHAPV2
-# ID 3 = Inner authentication EAP Method Type
-# ID 5 = Credential Type
-#	1 = SIM, 2 = USIM, 3 = NFC Secure Element, 4 = Hardware Token,
-#	5 = Softoken, 6 = Certificate, 7 = username/password, 9 = Anonymous,
-#	10 = Vendor Specific
-#nai_realm=0,example.com;example.net
-# EAP methods EAP-TLS with certificate and EAP-TTLS/MSCHAPv2 with
-# username/password
-#nai_realm=0,example.org,13[5:6],21[2:4][5:7]
-
-##### Hotspot 2.0 #############################################################
-
-# Enable Hotspot 2.0 support
-#hs20=1
-
-# Disable Downstream Group-Addressed Forwarding (DGAF)
-# This can be used to configure a network where no group-addressed frames are
-# allowed. The AP will not forward any group-address frames to the stations and
-# random GTKs are issued for each station to prevent associated stations from
-# forging such frames to other stations in the BSS.
-#disable_dgaf=1
-
-# Operator Friendly Name
-# This parameter can be used to configure one or more Operator Friendly Name
-# Duples. Each entry has a two or three character language code (ISO-639)
-# separated by colon from the operator friendly name string.
-#hs20_oper_friendly_name=eng:Example operator
-#hs20_oper_friendly_name=fin:Esimerkkioperaattori
-
-# Connection Capability
-# This can be used to advertise what type of IP traffic can be sent through the
-# hotspot (e.g., due to firewall allowing/blocking protocols/ports).
-# format: <IP Protocol>:<Port Number>:<Status>
-# IP Protocol: 1 = ICMP, 6 = TCP, 17 = UDP
-# Port Number: 0..65535
-# Status: 0 = Closed, 1 = Open, 2 = Unknown
-# Each hs20_conn_capab line is added to the list of advertised tuples.
-#hs20_conn_capab=1:0:2
-#hs20_conn_capab=6:22:1
-#hs20_conn_capab=17:5060:0
-
-# WAN Metrics
-# format: <WAN Info>:<DL Speed>:<UL Speed>:<DL Load>:<UL Load>:<LMD>
-# WAN Info: B0-B1: Link Status, B2: Symmetric Link, B3: At Capabity
-#    (encoded as two hex digits)
-#    Link Status: 1 = Link up, 2 = Link down, 3 = Link in test state
-# Downlink Speed: Estimate of WAN backhaul link current downlink speed in kbps;
-#	1..4294967295; 0 = unknown
-# Uplink Speed: Estimate of WAN backhaul link current uplink speed in kbps
-#	1..4294967295; 0 = unknown
-# Downlink Load: Current load of downlink WAN connection (scaled to 255 = 100%)
-# Uplink Load: Current load of uplink WAN connection (scaled to 255 = 100%)
-# Load Measurement Duration: Duration for measuring downlink/uplink load in
-# tenths of a second (1..65535); 0 if load cannot be determined
-#hs20_wan_metrics=01:8000:1000:80:240:3000
-
-# Operating Class Indication
-# List of operating classes the BSSes in this ESS use. The Global operating
-# classes in Table E-4 of IEEE Std 802.11-2012 Annex E define the values that
-# can be used in this.
-# format: hexdump of operating class octets
-# for example, operating classes 81 (2.4 GHz channels 1-13) and 115 (5 GHz
-# channels 36-48):
-#hs20_operating_class=5173
-
 ##### Multiple BSSID support ##################################################
 #
 # Above configuration is using the default interface (wlan#, or multi-SSID VLAN
diff -purN hostapd-20130302/hostapd/main.c hostapd-20130302-linux/hostapd/main.c
--- hostapd-20130302/hostapd/main.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/main.c	2013-07-04 11:17:51.000000000 -0400
@@ -13,6 +13,7 @@
 
 #include "utils/common.h"
 #include "utils/eloop.h"
+#include "utils/build_features.h"
 #include "crypto/random.h"
 #include "crypto/tls.h"
 #include "common/version.h"
@@ -31,6 +32,8 @@
 extern int wpa_debug_level;
 extern int wpa_debug_show_keys;
 extern int wpa_debug_timestamp;
+static int daemonize = 0;
+static char *pid_file = NULL;
 
 extern struct wpa_driver_ops *wpa_drivers[];
 
@@ -145,6 +148,14 @@ static void hostapd_logger_cb(void *ctx,
 }
 #endif /* CONFIG_NO_HOSTAPD_LOGGER */
 
+static void hostapd_setup_complete_cb(void *ctx)
+{
+	if (daemonize && os_daemonize(pid_file)) {
+		perror("daemon");
+		return;
+	}
+	daemonize = 0;
+}
 
 /**
  * hostapd_init - Allocate and initialize per-interface data
@@ -188,6 +199,7 @@ static struct hostapd_iface * hostapd_in
 		if (hapd == NULL)
 			goto fail;
 		hapd->msg_ctx = hapd;
+		hapd->setup_complete_cb = hostapd_setup_complete_cb;
 	}
 
 	return hapd_iface;
@@ -424,8 +436,6 @@ static void hostapd_global_deinit(const
 #endif /* CONFIG_NATIVE_WINDOWS */
 
 	eap_server_unregister_methods();
-
-	os_daemonize_terminate(pid_file);
 }
 
 
@@ -451,11 +461,6 @@ static int hostapd_global_run(struct hap
 	}
 #endif /* EAP_SERVER_TNC */
 
-	if (daemonize && os_daemonize(pid_file)) {
-		perror("daemon");
-		return -1;
-	}
-
 	eloop_run();
 
 	return 0;
@@ -530,14 +535,16 @@ static int hostapd_get_global_ctrl_iface
 	return 0;
 }
 
+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
+                       union wpa_event_data *data);
+
 
 int main(int argc, char *argv[])
 {
 	struct hapd_interfaces interfaces;
 	int ret = 1;
 	size_t i;
-	int c, debug = 0, daemonize = 0;
-	char *pid_file = NULL;
+	int c, debug = 0;
 	const char *log_file = NULL;
 	const char *entropy_file = NULL;
 
@@ -555,8 +562,9 @@ int main(int argc, char *argv[])
 	interfaces.global_iface_name = NULL;
 	interfaces.global_ctrl_sock = -1;
 
+	wpa_supplicant_event = hostapd_wpa_event;
 	for (;;) {
-		c = getopt(argc, argv, "Bde:f:hKP:tvg:");
+		c = getopt(argc, argv, "Bde:f:hKP:tg:v::");
 		if (c < 0)
 			break;
 		switch (c) {
@@ -588,6 +596,8 @@ int main(int argc, char *argv[])
 			wpa_debug_timestamp++;
 			break;
 		case 'v':
+			if (optarg)
+				exit(!has_feature(optarg));
 			show_version();
 			exit(1);
 			break;
diff -purN hostapd-20130302/hostapd/Makefile hostapd-20130302-linux/hostapd/Makefile
--- hostapd-20130302/hostapd/Makefile	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/hostapd/Makefile	2013-07-06 06:13:59.000000000 -0400
@@ -6,7 +6,7 @@ ifndef CFLAGS
 CFLAGS = -MMD -O2 -Wall -g
 endif
 
-CFLAGS += -I../src
+CFLAGS += -I../src -D__USE_GNU
 CFLAGS += -I../src/utils
 
 # Uncomment following line and set the path to your kernel tree include
@@ -14,6 +14,7 @@ CFLAGS += -I../src/utils
 # CFLAGS += -DUSE_KERNEL_HEADERS -I/usr/src/linux/include
 
 -include .config
+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
 
 ifndef CONFIG_OS
 ifdef CONFIG_NATIVE_WINDOWS
@@ -135,6 +136,9 @@ endif
 ifdef CONFIG_NO_CTRL_IFACE
 CFLAGS += -DCONFIG_NO_CTRL_IFACE
 else
+ifdef CONFIG_CTRL_IFACE_MIB
+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
+endif
 OBJS += ctrl_iface.o
 OBJS += ../src/ap/ctrl_iface_ap.o
 endif
@@ -192,10 +196,14 @@ ifdef CONFIG_IEEE80211AC
 CFLAGS += -DCONFIG_IEEE80211AC
 endif
 
+ifndef MULTICALL
+CFLAGS += -DNO_SUPPLICANT
+endif
+
 include ../src/drivers/drivers.mak
-OBJS += $(DRV_AP_OBJS)
-CFLAGS += $(DRV_AP_CFLAGS)
-LDFLAGS += $(DRV_AP_LDFLAGS)
+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
 LIBS += $(DRV_AP_LIBS)
 
 ifdef CONFIG_L2_PACKET
@@ -860,6 +868,12 @@ install: all
 
 BCHECK=../src/drivers/build.hostapd
 
+hostapd_multi.a: $(BCHECK) $(OBJS)
+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
+	@$(E) "  CC " $<
+	@rm -f $@
+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
+
 hostapd: $(BCHECK) $(OBJS)
 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
 	@$(E) "  LD " $@
@@ -898,6 +912,12 @@ HOBJS += ../src/crypto/aes-internal.o
 HOBJS += ../src/crypto/aes-internal-enc.o
 endif
 
+dump_cflags:
+	@echo -n $(CFLAGS) " "
+
+dump_ldflags:
+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
+
 nt_password_hash: $(NOBJS)
 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
 	@$(E) "  LD " $@
diff -purN hostapd-20130302/hostapd/src/crypto/random.c.rej hostapd-20130302-linux/hostapd/src/crypto/random.c.rej
--- hostapd-20130302/hostapd/src/crypto/random.c.rej	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/hostapd/src/crypto/random.c.rej	2013-07-06 06:13:35.000000000 -0400
@@ -0,0 +1,117 @@
+--- src/crypto/random.c
++++ src/crypto/random.c
+@@ -25,7 +25,6 @@
+ #include "utils/includes.h"
+ #ifdef __linux__
+ #include <fcntl.h>
+-#include <sys/stat.h>
+ #endif /* __linux__ */
+ 
+ #include "utils/common.h"
+@@ -34,8 +33,6 @@
+ #include "sha1.h"
+ #include "random.h"
+ 
+-#define RANDOM_STAMPFILE "/var/run/.random_available"
+-
+ #define POOL_WORDS 32
+ #define POOL_WORDS_MASK (POOL_WORDS - 1)
+ #define POOL_TAP1 26
+@@ -46,8 +43,6 @@
+ #define EXTRACT_LEN 16
+ #define MIN_READY_MARK 2
+ 
+-#ifndef CONFIG_NO_RANDOM_POOL
+-
+ static u32 pool[POOL_WORDS];
+ static unsigned int input_rotate = 0;
+ static unsigned int pool_pos = 0;
+@@ -128,7 +123,7 @@
+ }
+ 
+ 
+-static void random_pool_add_randomness(const void *buf, size_t len)
++void random_add_randomness(const void *buf, size_t len)
+ {
+ 	struct os_time t;
+ 	static unsigned int count = 0;
+@@ -218,22 +213,16 @@
+ int random_pool_ready(void)
+ {
+ #ifdef __linux__
+-	struct stat st;
+ 	int fd;
+ 	ssize_t res;
+ 
+-	if (stat(RANDOM_STAMPFILE, &st) == 0)
+-		return 1;
+-
+ 	/*
+ 	 * Make sure that there is reasonable entropy available before allowing
+ 	 * some key derivation operations to proceed.
+ 	 */
+ 
+-	if (dummy_key_avail == sizeof(dummy_key)) {
+-		random_mark_pool_ready();
++	if (dummy_key_avail == sizeof(dummy_key))
+ 		return 1; /* Already initialized - good to continue */
+-	}
+ 
+ 	/*
+ 	 * Try to fetch some more data from the kernel high quality
+@@ -268,7 +257,6 @@
+ 	if (dummy_key_avail == sizeof(dummy_key)) {
+ 		if (own_pool_ready < MIN_READY_MARK)
+ 			own_pool_ready = MIN_READY_MARK;
+-		random_mark_pool_ready();
+ 		random_write_entropy();
+ 		return 1;
+ 	}
+@@ -281,7 +269,6 @@
+ 	    total_collected + 10 * own_pool_ready > MIN_COLLECT_ENTROPY) {
+ 		wpa_printf(MSG_INFO, "random: Allow operation to proceed "
+ 			   "based on internal entropy");
+-		random_mark_pool_ready();
+ 		return 1;
+ 	}
+ 
+@@ -297,16 +284,10 @@
+ 
+ void random_mark_pool_ready(void)
+ {
+-	int fd;
+-
+ 	own_pool_ready++;
+ 	wpa_printf(MSG_DEBUG, "random: Mark internal entropy pool to be "
+ 		   "ready (count=%u/%u)", own_pool_ready, MIN_READY_MARK);
+ 	random_write_entropy();
+-
+-	fd = open(RANDOM_STAMPFILE, O_CREAT | O_WRONLY | O_EXCL | O_NOFOLLOW, 0600);
+-	if (fd >= 0)
+-		close(fd);
+ }
+ 
+ 
+@@ -463,22 +444,3 @@
+ 	os_free(random_entropy_file);
+ 	random_entropy_file = NULL;
+ }
+-
+-#endif /* CONFIG_NO_RANDOM_POOL */
+-
+-
+-void random_add_randomness(const void *buf, size_t len)
+-{
+-#ifdef __linux__
+-	int fd;
+-
+-	fd = open("/dev/random", O_RDWR);
+-	if (fd >= 0) {
+-		write(fd, buf, len);
+-		close(fd);
+-	}
+-#endif
+-#ifndef CONFIG_NO_RANDOM_POOL
+-	random_pool_add_randomness(buf, len);
+-#endif
+-}
diff -purN hostapd-20130302/hostapd/wpa_supplicant/Android.mk.rej hostapd-20130302-linux/hostapd/wpa_supplicant/Android.mk.rej
--- hostapd-20130302/hostapd/wpa_supplicant/Android.mk.rej	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/hostapd/wpa_supplicant/Android.mk.rej	2013-07-06 06:13:35.000000000 -0400
@@ -0,0 +1,13 @@
+--- wpa_supplicant/Android.mk
++++ wpa_supplicant/Android.mk
+@@ -1162,8 +1162,9 @@
+ 
+ ifdef CONFIG_NO_RANDOM_POOL
+ L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
++else
++OBJS += src/crypto/random.c
+ endif
+-OBJS += src/crypto/random.c
+ 
+ ifdef CONFIG_CTRL_IFACE
+ ifeq ($(CONFIG_CTRL_IFACE), y)
diff -purN hostapd-20130302/hostapd/wpa_supplicant/Makefile.rej hostapd-20130302-linux/hostapd/wpa_supplicant/Makefile.rej
--- hostapd-20130302/hostapd/wpa_supplicant/Makefile.rej	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/hostapd/wpa_supplicant/Makefile.rej	2013-07-06 06:13:35.000000000 -0400
@@ -0,0 +1,13 @@
+--- wpa_supplicant/Makefile
++++ wpa_supplicant/Makefile
+@@ -1222,8 +1222,9 @@
+ 
+ ifdef CONFIG_NO_RANDOM_POOL
+ CFLAGS += -DCONFIG_NO_RANDOM_POOL
++else
++OBJS += ../src/crypto/random.o
+ endif
+-OBJS += ../src/crypto/random.o
+ 
+ ifdef CONFIG_CTRL_IFACE
+ ifeq ($(CONFIG_CTRL_IFACE), y)
diff -purN hostapd-20130302/ipkg-ar71xx/hostapd/CONTROL/control hostapd-20130302-linux/ipkg-ar71xx/hostapd/CONTROL/control
--- hostapd-20130302/ipkg-ar71xx/hostapd/CONTROL/control	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/ipkg-ar71xx/hostapd/CONTROL/control	2013-07-04 11:18:15.000000000 -0400
@@ -0,0 +1,12 @@
+Package: hostapd
+Version: 20130302-1
+Depends: libc, libnl-tiny, libubus
+Source: package/network/services/hostapd
+SourceFile: hostapd-20130302.tar.bz2
+SourceURL: git://w1.fi/srv/git/hostap.git
+Section: net
+Maintainer: Felix Fietkau <nbd@openwrt.org>
+Architecture: ar71xx
+Installed-Size: 273719
+Description:  This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
+ Authenticator.
diff -purN hostapd-20130302/ipkg-ar71xx/hostapd/etc/capwap/config.wtp hostapd-20130302-linux/ipkg-ar71xx/hostapd/etc/capwap/config.wtp
--- hostapd-20130302/ipkg-ar71xx/hostapd/etc/capwap/config.wtp	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/ipkg-ar71xx/hostapd/etc/capwap/config.wtp	2013-06-29 06:20:17.000000000 -0400
@@ -0,0 +1,11 @@
+<AC_ADDRESSES>
+31.1.1.1
+</AC_ADDRESSES>
+</WTP_NAME>My WTP 1
+</WTP_LOCATION>  Next to Fridge
+</WTP_LEV3_PROTOCOL> IPv4
+</WTP_FORCE_MTU> 1420
+</WTP_FORCE_AC_ADDRESS>31.1.1.1
+</WTP_FORCE_SECURITY> PRESHARED
+</AC_LOG_FILE_ENABLE> 1
+</AC_LOG_FILE_SIZE> 8388608
diff -purN hostapd-20130302/ipkg-ar71xx/hostapd/etc/capwap/hostapd_wtp.conf hostapd-20130302-linux/ipkg-ar71xx/hostapd/etc/capwap/hostapd_wtp.conf
--- hostapd-20130302/ipkg-ar71xx/hostapd/etc/capwap/hostapd_wtp.conf	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/ipkg-ar71xx/hostapd/etc/capwap/hostapd_wtp.conf	2013-06-27 07:43:47.000000000 -0400
@@ -0,0 +1,3 @@
+ip_daemon_wtp=127.0.0.1
+port_daemon_wtp=6333
+sock_path_wtp=/tmp/wtp_ipc_hostapd
diff -purN hostapd-20130302/ipkg-ar71xx/hostapd/etc/capwap/settings.wtp.txt hostapd-20130302-linux/ipkg-ar71xx/hostapd/etc/capwap/settings.wtp.txt
--- hostapd-20130302/ipkg-ar71xx/hostapd/etc/capwap/settings.wtp.txt	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/ipkg-ar71xx/hostapd/etc/capwap/settings.wtp.txt	2013-06-29 06:20:54.000000000 -0400
@@ -0,0 +1,9 @@
+<IF_NAME>    mon.wlan0
+<WTP_ETH_IF_NAME>    vmnet1
+<RADIO_0_IF_NAME>    wlan0
+<BASE_MAC_IF_NAME>   vmnet1
+<BOARD_REVISION_NO>   eth0
+<WTP_MODEL_NUM>    12345678
+<WTP_SERIAL_NUM>   12345678
+<WTP_HOSTAPD_PORT> 6333
+<WTP_HOSTAPD_UNIX_PATH> /tmp/wtp_ipc_hostapd
diff -purN hostapd-20130302/ipkg-ar71xx/hostapd/lib/wifi/hostapd.sh hostapd-20130302-linux/ipkg-ar71xx/hostapd/lib/wifi/hostapd.sh
--- hostapd-20130302/ipkg-ar71xx/hostapd/lib/wifi/hostapd.sh	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/ipkg-ar71xx/hostapd/lib/wifi/hostapd.sh	2013-07-04 11:18:15.000000000 -0400
@@ -0,0 +1,301 @@
+hostapd_set_bss_options() {
+	local var="$1"
+	local vif="$2"
+	local enc wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wps_possible
+
+	config_get enc "$vif" encryption
+	config_get wep_rekey        "$vif" wep_rekey        # 300
+	config_get wpa_group_rekey  "$vif" wpa_group_rekey  # 300
+	config_get wpa_pair_rekey   "$vif" wpa_pair_rekey   # 300
+	config_get wpa_master_rekey "$vif" wpa_master_rekey # 640
+	config_get_bool ap_isolate "$vif" isolate 0
+	config_get_bool disassoc_low_ack "$vif" disassoc_low_ack 1
+	config_get max_num_sta "$vif" max_num_sta 0
+	config_get max_inactivity "$vif" max_inactivity 0
+	config_get_bool preamble "$vif" short_preamble 1
+
+	config_get device "$vif" device
+	config_get hwmode "$device" hwmode
+	config_get phy "$device" phy
+
+	append "$var" "ctrl_interface=/var/run/hostapd-$phy" "$N"
+
+	if [ "$ap_isolate" -gt 0 ]; then
+		append "$var" "ap_isolate=$ap_isolate" "$N"
+	fi
+	if [ "$max_num_sta" -gt 0 ]; then
+		append "$var" "max_num_sta=$max_num_sta" "$N"
+	fi
+	if [ "$max_inactivity" -gt 0 ]; then
+		append "$var" "ap_max_inactivity=$max_inactivity" "$N"
+	fi
+	append "$var" "disassoc_low_ack=$disassoc_low_ack" "$N"
+	if [ "$preamble" -gt 0 ]; then
+		append "$var" "preamble=$preamble" "$N"
+	fi
+
+	# Examples:
+	# psk-mixed/tkip 	=> WPA1+2 PSK, TKIP
+	# wpa-psk2/tkip+aes	=> WPA2 PSK, CCMP+TKIP
+	# wpa2/tkip+aes 	=> WPA2 RADIUS, CCMP+TKIP
+	# ...
+
+	# TODO: move this parsing function somewhere generic, so that
+	# later it can be reused by drivers that don't use hostapd
+
+	# crypto defaults: WPA2 vs WPA1
+	case "$enc" in
+		wpa2*|*psk2*)
+			wpa=2
+			crypto="CCMP"
+		;;
+		*mixed*)
+			wpa=3
+			crypto="CCMP TKIP"
+		;;
+		*)
+			wpa=1
+			crypto="TKIP"
+		;;
+	esac
+
+	# explicit override for crypto setting
+	case "$enc" in
+		*tkip+aes|*tkip+ccmp|*aes+tkip|*ccmp+tkip) crypto="CCMP TKIP";;
+		*aes|*ccmp) crypto="CCMP";;
+		*tkip) crypto="TKIP";;
+	esac
+
+	# enforce CCMP for 11ng and 11na
+	case "$hwmode:$crypto" in
+		*ng:TKIP|*na:TKIP) crypto="CCMP TKIP";;
+	esac
+
+	# use crypto/auth settings for building the hostapd config
+	case "$enc" in
+		*psk*)
+			config_get psk "$vif" key
+			if [ ${#psk} -eq 64 ]; then
+				append "$var" "wpa_psk=$psk" "$N"
+			else
+				append "$var" "wpa_passphrase=$psk" "$N"
+			fi
+			wps_possible=1
+			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
+			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
+			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
+		;;
+		*wpa*)
+			# required fields? formats?
+			# hostapd is particular, maybe a default configuration for failures
+			config_get auth_server "$vif" auth_server
+			[ -z "$auth_server" ] && config_get auth_server "$vif" server
+			append "$var" "auth_server_addr=$auth_server" "$N"
+			config_get auth_port "$vif" auth_port
+			[ -z "$auth_port" ] && config_get auth_port "$vif" port
+			auth_port=${auth_port:-1812}
+			append "$var" "auth_server_port=$auth_port" "$N"
+			config_get auth_secret "$vif" auth_secret
+			[ -z "$auth_secret" ] && config_get auth_secret "$vif" key
+			append "$var" "auth_server_shared_secret=$auth_secret" "$N"
+			config_get_bool auth_cache "$vif" auth_cache 0
+			[ "$auth_cache" -gt 0 ] || append "$var" "disable_pmksa_caching=1" "$N"
+			[ "$auth_cache" -gt 0 ] || append "$var" "okc=0" "$N"
+			config_get acct_server "$vif" acct_server
+			[ -n "$acct_server" ] && append "$var" "acct_server_addr=$acct_server" "$N"
+			config_get acct_port "$vif" acct_port
+			[ -n "$acct_port" ] && acct_port=${acct_port:-1813}
+			[ -n "$acct_port" ] && append "$var" "acct_server_port=$acct_port" "$N"
+			config_get acct_secret "$vif" acct_secret
+			[ -n "$acct_secret" ] && append "$var" "acct_server_shared_secret=$acct_secret" "$N"
+			config_get nasid "$vif" nasid
+			append "$var" "nas_identifier=$nasid" "$N"
+			append "$var" "eapol_key_index_workaround=1" "$N"
+			append "$var" "ieee8021x=1" "$N"
+			append "$var" "wpa_key_mgmt=WPA-EAP" "$N"
+			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
+			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
+			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
+		;;
+		*wep*)
+			config_get key "$vif" key
+			key="${key:-1}"
+			case "$key" in
+				[1234])
+					for idx in 1 2 3 4; do
+						local zidx
+						zidx=$(($idx - 1))
+						config_get ckey "$vif" "key${idx}"
+						[ -n "$ckey" ] && \
+							append "$var" "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N"
+					done
+					append "$var" "wep_default_key=$((key - 1))"  "$N"
+				;;
+				*)
+					append "$var" "wep_key0=$(prepare_key_wep "$key")" "$N"
+					append "$var" "wep_default_key=0" "$N"
+					[ -n "$wep_rekey" ] && append "$var" "wep_rekey_period=$wep_rekey" "$N"
+				;;
+			esac
+			case "$enc" in
+				*shared*)
+					auth_algs=2
+				;;
+				*mixed*)
+					auth_algs=3
+				;;
+			esac
+			wpa=0
+			crypto=
+		;;
+		*)
+			wpa=0
+			crypto=
+		;;
+	esac
+	append "$var" "auth_algs=${auth_algs:-1}" "$N"
+	append "$var" "wpa=$wpa" "$N"
+	[ -n "$crypto" ] && append "$var" "wpa_pairwise=$crypto" "$N"
+	[ -n "$wpa_group_rekey" ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
+
+	config_get ssid "$vif" ssid
+	config_get bridge "$vif" bridge
+	config_get ieee80211d "$vif" ieee80211d
+	config_get iapp_interface "$vif" iapp_interface
+
+	config_get_bool wps_pbc "$vif" wps_pushbutton 0
+	config_get_bool wps_label "$vif" wps_label 0
+
+	config_get config_methods "$vif" wps_config
+	[ "$wps_pbc" -gt 0 ] && append config_methods push_button
+
+	[ -n "$wps_possible" -a -n "$config_methods" ] && {
+		config_get device_type "$vif" wps_device_type "6-0050F204-1"
+		config_get device_name "$vif" wps_device_name "OpenWrt AP"
+		config_get manufacturer "$vif" wps_manufacturer "openwrt.org"
+
+		append "$var" "eap_server=1" "$N"
+		append "$var" "wps_state=2" "$N"
+		append "$var" "ap_setup_locked=1" "$N"
+		append "$var" "device_type=$device_type" "$N"
+		append "$var" "device_name=$device_name" "$N"
+		append "$var" "manufacturer=$manufacturer" "$N"
+		append "$var" "config_methods=$config_methods" "$N"
+	}
+
+	append "$var" "ssid=$ssid" "$N"
+	[ -n "$bridge" ] && append "$var" "bridge=$bridge" "$N"
+	[ -n "$ieee80211d" ] && append "$var" "ieee80211d=$ieee80211d" "$N"
+	[ -n "$iapp_interface" ] && append "$var" iapp_interface=$(uci_get_state network "$iapp_interface" ifname "$iapp_interface") "$N"
+
+	if [ "$wpa" -ge "2" ]
+	then
+		# RSN -> allow preauthentication
+		config_get_bool rsn_preauth "$vif" rsn_preauth "$auth_cache"
+		if [ -n "$bridge" -a "$rsn_preauth" = 1 ]
+		then
+			append "$var" "rsn_preauth=1" "$N"
+			append "$var" "rsn_preauth_interfaces=$bridge" "$N"
+		fi
+
+		# RSN -> allow management frame protection
+		config_get ieee80211w "$vif" ieee80211w
+		case "$ieee80211w" in
+			[012])
+				append "$var" "ieee80211w=$ieee80211w" "$N"
+				[ "$ieee80211w" -gt "0" ] && {
+					config_get ieee80211w_max_timeout "$vif" ieee80211w_max_timeout
+					config_get ieee80211w_retry_timeout "$vif" ieee80211w_retry_timeout
+					[ -n "$ieee80211w_max_timeout" ] && \
+						append "$var" "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
+					[ -n "$ieee80211w_retry_timeout" ] && \
+						append "$var" "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
+				}
+			;;
+		esac
+	fi
+
+	config_get macfilter "$vif" macfilter
+	macfile="/var/run/hostapd-$ifname.maclist"
+	[ -e "$macfile" ] && rm -f "$macfile"
+
+	case "$macfilter" in
+		allow)
+			append "$var" "macaddr_acl=1" "$N"
+			append "$var" "accept_mac_file=$macfile" "$N"
+			;;
+		deny)
+			append "$var" "macaddr_acl=0" "$N"
+			append "$var" "deny_mac_file=$macfile" "$N"
+			;;
+	esac
+	config_get maclist "$vif" maclist
+	[ -n "$maclist" ] && {
+		for mac in $maclist; do
+			echo "$mac" >> $macfile
+		done
+	}
+}
+
+hostapd_set_log_options() {
+	local var="$1"
+	local cfg="$2"
+	local log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
+
+	config_get log_level "$cfg" log_level 2
+
+	config_get_bool log_80211  "$cfg" log_80211  1
+	config_get_bool log_8021x  "$cfg" log_8021x  1
+	config_get_bool log_radius "$cfg" log_radius 1
+	config_get_bool log_wpa    "$cfg" log_wpa    1
+	config_get_bool log_driver "$cfg" log_driver 1
+	config_get_bool log_iapp   "$cfg" log_iapp   1
+	config_get_bool log_mlme   "$cfg" log_mlme   1
+
+	local log_mask=$((       \
+		($log_80211  << 0) | \
+		($log_8021x  << 1) | \
+		($log_radius << 2) | \
+		($log_wpa    << 3) | \
+		($log_driver << 4) | \
+		($log_iapp   << 5) | \
+		($log_mlme   << 6)   \
+	))
+
+	append "$var" "logger_syslog=$log_mask" "$N"
+	append "$var" "logger_syslog_level=$log_level" "$N"
+	append "$var" "logger_stdout=$log_mask" "$N"
+	append "$var" "logger_stdout_level=$log_level" "$N"
+}
+
+hostapd_setup_vif() {
+	local vif="$1"
+	local driver="$2"
+	local ifname device channel hwmode
+
+	hostapd_cfg=
+
+	config_get ifname "$vif" ifname
+	config_get device "$vif" device
+	config_get channel "$device" channel
+	config_get hwmode "$device" hwmode
+
+	hostapd_set_log_options hostapd_cfg "$device"
+	hostapd_set_bss_options hostapd_cfg "$vif"
+
+	case "$hwmode" in
+		*bg|*gdt|*gst|*fh) hwmode=g;;
+		*adt|*ast) hwmode=a;;
+	esac
+	[ "$channel" = auto ] && channel=
+	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
+	cat > /var/run/hostapd-$ifname.conf <<EOF
+driver=$driver
+interface=$ifname
+${hwmode:+hw_mode=${hwmode#11}}
+${channel:+channel=$channel}
+$hostapd_cfg
+EOF
+	hostapd -P /var/run/wifi-$ifname.pid -B /var/run/hostapd-$ifname.conf
+}
+
Binary files hostapd-20130302/ipkg-ar71xx/hostapd/usr/sbin/hostapd and hostapd-20130302-linux/ipkg-ar71xx/hostapd/usr/sbin/hostapd differ
diff -purN hostapd-20130302/src/ap/ap_config.h hostapd-20130302-linux/src/ap/ap_config.h
--- hostapd-20130302/src/ap/ap_config.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/ap_config.h	2013-07-04 11:17:51.000000000 -0400
@@ -510,9 +510,11 @@ struct hostapd_config {
 
 	int ht_op_mode_fixed;
 	u16 ht_capab;
+	int noscan;
 	int ieee80211n;
 	int secondary_channel;
 	int require_ht;
+	int dynamic_ht40;
 	u32 vht_capab;
 	int ieee80211ac;
 	int require_vht;
diff -purN hostapd-20130302/src/ap/beacon.c hostapd-20130302-linux/src/ap/beacon.c
--- hostapd-20130302/src/ap/beacon.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/beacon.c	2013-07-06 06:11:10.000000000 -0400
@@ -455,6 +455,10 @@ void handle_probe_req(struct hostapd_dat
 		return;
 	}
 
+	if (!sta && hapd->num_sta >= hapd->conf->max_num_sta)
+		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " ignored,"
+			   " too many connected stations.", MAC2STR(mgmt->sa));
+
 #ifdef CONFIG_INTERWORKING
 	if (elems.interworking && elems.interworking_len >= 1) {
 		u8 ant = elems.interworking[0] & 0x0f;
diff -purN hostapd-20130302/src/ap/ctrl_iface_ap.c hostapd-20130302-linux/src/ap/ctrl_iface_ap.c
--- hostapd-20130302/src/ap/ctrl_iface_ap.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/ctrl_iface_ap.c	2013-07-04 11:17:51.000000000 -0400
@@ -20,6 +20,7 @@
 #include "ctrl_iface_ap.h"
 #include "ap_drv_ops.h"
 
+#ifdef CONFIG_CTRL_IFACE_MIB
 
 static int hostapd_get_sta_conn_time(struct sta_info *sta,
 				     char *buf, size_t buflen)
@@ -129,6 +130,7 @@ int hostapd_ctrl_iface_sta_next(struct h
 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
 }
 
+#endif
 
 #ifdef CONFIG_P2P_MANAGER
 static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
@@ -303,3 +305,4 @@ int hostapd_ctrl_iface_disassociate(stru
 
 	return 0;
 }
+
diff -purN hostapd-20130302/src/ap/drv_callbacks.c hostapd-20130302-linux/src/ap/drv_callbacks.c
--- hostapd-20130302/src/ap/drv_callbacks.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/drv_callbacks.c	2013-07-04 11:17:51.000000000 -0400
@@ -714,8 +714,8 @@ static void hostapd_event_eapol_rx(struc
 }
 
 
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data)
+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
+		       union wpa_event_data *data)
 {
 	struct hostapd_data *hapd = ctx;
 #ifndef CONFIG_NO_STDOUT_DEBUG
diff -purN hostapd-20130302/src/ap/hostapd.c hostapd-20130302-linux/src/ap/hostapd.c
--- hostapd-20130302/src/ap/hostapd.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/hostapd.c	2013-07-06 06:11:10.000000000 -0400
@@ -22,6 +22,7 @@
 #include "beacon.h"
 #include "iapp.h"
 #include "ieee802_1x.h"
+#include "ieee802_11.h"
 #include "ieee802_11_auth.h"
 #include "vlan_init.h"
 #include "wpa_auth.h"
@@ -140,6 +141,24 @@ int hostapd_reload_config(struct hostapd
 	oldconf = hapd->iconf;
 	iface->conf = newconf;
 
+	hostapd_select_hw_mode(iface);
+	iface->freq = hostapd_hw_get_freq(hapd, newconf->channel);
+
+	if (hostapd_set_freq(hapd, newconf->hw_mode, iface->freq,
+			     newconf->channel,
+			     newconf->ieee80211n,
+			     newconf->ieee80211ac,
+			     newconf->secondary_channel,
+			     newconf->vht_oper_chwidth,
+			     newconf->vht_oper_centr_freq_seg0_idx,
+			     newconf->vht_oper_centr_freq_seg1_idx)) {
+		wpa_printf(MSG_ERROR, "Could not set channel for "
+			   "kernel driver");
+	}
+
+	if (iface->current_mode)
+		hostapd_prepare_rates(iface, iface->current_mode);
+
 	for (j = 0; j < iface->num_bss; j++) {
 		hapd = iface->bss[j];
 		hapd->iconf = newconf;
@@ -314,6 +333,7 @@ static void hostapd_cleanup_iface_pre(st
 
 static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
 {
+	hostapd_deinit_ht(iface);
 	hostapd_free_hw_features(iface->hw_features, iface->num_hw_features);
 	iface->hw_features = NULL;
 	os_free(iface->current_rates);
@@ -877,11 +897,8 @@ int hostapd_setup_interface_complete(str
 	size_t j;
 	u8 *prev_addr;
 
-	if (err) {
-		wpa_printf(MSG_ERROR, "Interface initialization failed");
-		eloop_terminate();
-		return -1;
-	}
+	if (err)
+		goto error;
 
 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
 	if (hapd->iconf->channel) {
@@ -901,7 +918,7 @@ int hostapd_setup_interface_complete(str
 				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
 			wpa_printf(MSG_ERROR, "Could not set channel for "
 				   "kernel driver");
-			return -1;
+			goto error;
 		}
 	}
 
@@ -912,7 +929,7 @@ int hostapd_setup_interface_complete(str
 			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
 				       HOSTAPD_LEVEL_WARNING,
 				       "Failed to prepare rates table.");
-			return -1;
+			goto error;
 		}
 	}
 
@@ -920,14 +937,14 @@ int hostapd_setup_interface_complete(str
 	    hostapd_set_rts(hapd, hapd->iconf->rts_threshold)) {
 		wpa_printf(MSG_ERROR, "Could not set RTS threshold for "
 			   "kernel driver");
-		return -1;
+		goto error;
 	}
 
 	if (hapd->iconf->fragm_threshold > -1 &&
 	    hostapd_set_frag(hapd, hapd->iconf->fragm_threshold)) {
 		wpa_printf(MSG_ERROR, "Could not set fragmentation threshold "
 			   "for kernel driver");
-		return -1;
+		goto error;
 	}
 
 	prev_addr = hapd->own_addr;
@@ -937,7 +954,7 @@ int hostapd_setup_interface_complete(str
 		if (j)
 			os_memcpy(hapd->own_addr, prev_addr, ETH_ALEN);
 		if (hostapd_setup_bss(hapd, j == 0))
-			return -1;
+			goto error;
 		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
 			prev_addr = hapd->own_addr;
 	}
@@ -949,7 +966,7 @@ int hostapd_setup_interface_complete(str
 	if (hostapd_driver_commit(hapd) < 0) {
 		wpa_printf(MSG_ERROR, "%s: Failed to commit driver "
 			   "configuration", __func__);
-		return -1;
+		goto error;
 	}
 
 	/*
@@ -970,6 +987,11 @@ int hostapd_setup_interface_complete(str
 		   iface->bss[0]->conf->iface);
 
 	return 0;
+
+error:
+	wpa_printf(MSG_ERROR, "Interface initialization failed");
+	eloop_terminate();
+	return -1;
 }
 
 
diff -purN hostapd-20130302/src/ap/hostapd.h hostapd-20130302-linux/src/ap/hostapd.h
--- hostapd-20130302/src/ap/hostapd.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/hostapd.h	2013-07-06 06:11:10.000000000 -0400
@@ -265,6 +265,9 @@ struct hostapd_iface {
 	/* Overlapping BSS information */
 	int olbc_ht;
 
+	int force_20mhz;
+	struct os_time last_20mhz_trigger;
+
 	u16 ht_op_mode;
 	void (*scan_cb)(struct hostapd_iface *iface);
 };
diff -purN hostapd-20130302/src/ap/hw_features.c hostapd-20130302-linux/src/ap/hw_features.c
--- hostapd-20130302/src/ap/hw_features.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/hw_features.c	2013-07-04 11:17:51.000000000 -0400
@@ -494,7 +494,7 @@ static int ieee80211n_check_40mhz(struct
 {
 	struct wpa_driver_scan_params params;
 
-	if (!iface->conf->secondary_channel)
+	if (!iface->conf->secondary_channel || iface->conf->noscan)
 		return 0; /* HT40 not used */
 
 	wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes prior to enabling "
diff -purN hostapd-20130302/src/ap/ieee802_11.c hostapd-20130302-linux/src/ap/ieee802_11.c
--- hostapd-20130302/src/ap/ieee802_11.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/ieee802_11.c	2013-07-06 06:11:10.000000000 -0400
@@ -1484,6 +1484,9 @@ static void handle_beacon(struct hostapd
 					     sizeof(mgmt->u.beacon)), &elems,
 				      0);
 
+	if (!elems.ht_capabilities)
+		hostapd_trigger_20mhz(hapd->iface);
+
 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
 }
 
diff -purN hostapd-20130302/src/ap/ieee802_11.h hostapd-20130302-linux/src/ap/ieee802_11.h
--- hostapd-20130302/src/ap/ieee802_11.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/ieee802_11.h	2013-07-04 11:17:51.000000000 -0400
@@ -81,4 +81,17 @@ int hostapd_update_time_adv(struct hosta
 void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
 u8 * hostapd_eid_bss_max_idle_period(struct hostapd_data *hapd, u8 *eid);
 
+#ifdef CONFIG_IEEE80211N
+void hostapd_trigger_20mhz(struct hostapd_iface *iface);
+void hostapd_deinit_ht(struct hostapd_iface *iface);
+
+#else
+static inline void hostapd_deinit_ht(struct hostapd_iface *iface)
+{
+}
+static inline void hostapd_trigger_20mhz(struct hostapd_iface *iface)
+{
+}
+#endif /* CONFIG_IEEE80211N */
+
 #endif /* IEEE802_11_H */
diff -purN hostapd-20130302/src/ap/ieee802_11_ht.c hostapd-20130302-linux/src/ap/ieee802_11_ht.c
--- hostapd-20130302/src/ap/ieee802_11_ht.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/ieee802_11_ht.c	2013-07-04 11:17:51.000000000 -0400
@@ -20,9 +20,11 @@
 #include "drivers/driver.h"
 #include "hostapd.h"
 #include "ap_config.h"
+#include "ap_drv_ops.h"
 #include "sta_info.h"
 #include "beacon.h"
 #include "ieee802_11.h"
+#include "utils/eloop.h"
 
 
 u8 * hostapd_eid_ht_capabilities(struct hostapd_data *hapd, u8 *eid)
@@ -70,12 +72,15 @@ u8 * hostapd_eid_ht_operation(struct hos
 
 	oper->control_chan = hapd->iconf->channel;
 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
-	if (hapd->iconf->secondary_channel == 1)
-		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
-			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-	if (hapd->iconf->secondary_channel == -1)
-		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
-			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
+
+	if (!hapd->iface->force_20mhz) {
+		if (hapd->iconf->secondary_channel == 1)
+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
+		if (hapd->iconf->secondary_channel == -1)
+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
+	}
 
 	pos += sizeof(*oper);
 
@@ -270,3 +275,84 @@ void hostapd_get_ht_capab(struct hostapd
 
 	neg_ht_cap->ht_capabilities_info = host_to_le16(cap);
 }
+
+static void hostapd_set_force_20mhz(struct hostapd_iface *iface);
+
+static void hostapd_restore_40mhz(void *eloop_data, void *user_ctx)
+{
+	struct hostapd_iface *iface = eloop_data;
+	struct os_time time;
+	int timeout;
+
+	if (!iface->last_20mhz_trigger.sec)
+	    return;
+
+	os_get_time(&time);
+	timeout = iface->last_20mhz_trigger.sec + iface->conf->dynamic_ht40 -
+		  time.sec;
+
+	if (timeout > 0) {
+		eloop_register_timeout(timeout, 0, hostapd_restore_40mhz,
+				       iface, NULL);
+		return;
+	}
+
+	iface->last_20mhz_trigger.sec = 0;
+	iface->last_20mhz_trigger.usec = 0;
+
+	iface->force_20mhz = 0;
+	hostapd_set_force_20mhz(iface);
+}
+
+static void hostapd_set_force_20mhz(struct hostapd_iface *iface)
+{
+	int secondary_channel;
+	int i;
+
+	ieee802_11_set_beacons(iface);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *hapd = iface->bss[i];
+
+		if (iface->force_20mhz)
+			secondary_channel = 0;
+		else
+			secondary_channel = hapd->iconf->secondary_channel;
+
+		if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
+				     hapd->iconf->channel,
+				     hapd->iconf->ieee80211n,
+				     hapd->iconf->ieee80211ac,
+				     secondary_channel,
+				     hapd->iconf->vht_oper_chwidth,
+				     hapd->iconf->vht_oper_centr_freq_seg0_idx,
+				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
+			wpa_printf(MSG_ERROR, "Could not set channel for "
+				   "kernel driver");
+		}
+	}
+}
+
+void hostapd_deinit_ht(struct hostapd_iface *iface)
+{
+	eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
+}
+
+void hostapd_trigger_20mhz(struct hostapd_iface *iface)
+{
+	if (!iface->conf->dynamic_ht40)
+		return;
+
+	if (!iface->force_20mhz) {
+		iface->force_20mhz = 1;
+		hostapd_set_force_20mhz(iface);
+	}
+
+	if (!iface->last_20mhz_trigger.sec) {
+		eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
+		eloop_register_timeout(iface->conf->dynamic_ht40, 0,
+				       hostapd_restore_40mhz, iface, NULL);
+	}
+
+	os_get_time(&iface->last_20mhz_trigger);
+}
diff -purN hostapd-20130302/src/ap/ieee802_1x.c hostapd-20130302-linux/src/ap/ieee802_1x.c
--- hostapd-20130302/src/ap/ieee802_1x.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/ieee802_1x.c	2013-07-04 11:17:51.000000000 -0400
@@ -2043,11 +2043,12 @@ void ieee802_1x_notify_pre_auth(struct e
 }
 
 
-static const char * bool_txt(Boolean bool)
+static const char * bool_txt(Boolean bool_val)
 {
-	return bool ? "TRUE" : "FALSE";
+	return bool_val ? "TRUE" : "FALSE";
 }
 
+#ifdef CONFIG_CTRL_IFACE_MIB
 
 int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
 {
@@ -2200,6 +2201,7 @@ int ieee802_1x_get_mib_sta(struct hostap
 	return len;
 }
 
+#endif
 
 static void ieee802_1x_finished(struct hostapd_data *hapd,
 				struct sta_info *sta, int success)
diff -purN hostapd-20130302/src/ap/sta_info.c hostapd-20130302-linux/src/ap/sta_info.c
--- hostapd-20130302/src/ap/sta_info.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/sta_info.c	2013-07-04 11:17:51.000000000 -0400
@@ -576,7 +576,7 @@ void ap_sta_disassociate(struct hostapd_
 {
 	wpa_printf(MSG_DEBUG, "%s: disassociate STA " MACSTR,
 		   hapd->conf->iface, MAC2STR(sta->addr));
-	sta->flags &= ~WLAN_STA_ASSOC;
+	sta->flags &= ~(WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK);
 	ap_sta_set_authorized(hapd, sta, 0);
 	sta->timeout_next = STA_DEAUTH;
 	wpa_printf(MSG_DEBUG, "%s: reschedule ap_handle_timer timeout "
diff -purN hostapd-20130302/src/ap/wpa_auth.c hostapd-20130302-linux/src/ap/wpa_auth.c
--- hostapd-20130302/src/ap/wpa_auth.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/wpa_auth.c	2013-07-04 11:17:51.000000000 -0400
@@ -2687,6 +2687,7 @@ static const char * wpa_bool_txt(int boo
 	return bool ? "TRUE" : "FALSE";
 }
 
+#ifdef CONFIG_CTRL_IFACE_MIB
 
 #define RSN_SUITE "%02x-%02x-%02x-%d"
 #define RSN_SUITE_ARG(s) \
@@ -2831,7 +2832,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
 
 	return len;
 }
-
+#endif
 
 void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
 {
diff -purN hostapd-20130302/src/ap/wps_hostapd.c hostapd-20130302-linux/src/ap/wps_hostapd.c
--- hostapd-20130302/src/ap/wps_hostapd.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/ap/wps_hostapd.c	2013-07-04 11:17:51.000000000 -0400
@@ -871,11 +871,9 @@ int hostapd_init_wps(struct hostapd_data
 
 		if (conf->rsn_pairwise & WPA_CIPHER_CCMP)
 			wps->encr_types |= WPS_ENCR_AES;
-		if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
+		else if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
 			wps->encr_types |= WPS_ENCR_TKIP;
-	}
-
-	if (conf->wpa & WPA_PROTO_WPA) {
+	} else if (conf->wpa & WPA_PROTO_WPA) {
 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
 			wps->auth_types |= WPS_AUTH_WPAPSK;
 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X)
@@ -883,7 +881,7 @@ int hostapd_init_wps(struct hostapd_data
 
 		if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
 			wps->encr_types |= WPS_ENCR_AES;
-		if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
+		else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
 			wps->encr_types |= WPS_ENCR_TKIP;
 	}
 
diff -purN hostapd-20130302/src/capwap/capwap_mgmt_frame_ac.c hostapd-20130302-linux/src/capwap/capwap_mgmt_frame_ac.c
--- hostapd-20130302/src/capwap/capwap_mgmt_frame_ac.c	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/capwap_mgmt_frame_ac.c	2013-07-06 06:07:00.000000000 -0400
@@ -0,0 +1,87 @@
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "radius/radius.h"
+#include "drivers/driver.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "common/wpa_ctrl.h"
+#include "crypto/random.h"
+
+
+#define MAC_LENGTH 6
+#define HLEN_80211 24
+#define HLEN_LLC 8
+
+int same_mac( unsigned char *mac1, unsigned char *mac2){// return 0
+	int i;
+	for(i=0;i<MAC_LENGTH;i++)if(mac1[i]!=mac2[i])return -1;
+	return 0;
+}
+
+int GetEapol_Frame( unsigned char *sa,  unsigned char *buf, int len){
+	struct ieee80211_hdr *hdr;
+	hdr = (struct ieee80211_hdr *) buf;
+	os_memcpy(sa, hdr->addr2, MAC_LENGTH);
+	return HLEN_80211 + HLEN_LLC;
+}
+
+int isEAPOL_Frame( unsigned char *buf, int len){
+	unsigned char rfc1042_header[6] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+	int i;
+	
+	for(i=0; i<6; i++)if(rfc1042_header[i]!=buf[i + HLEN_80211])return 0;
+	return 1;
+}
+
+void stampa_mac(char *s,  unsigned char *mac){
+	int i;
+	wpa_printf(MSG_DEBUG,"%s",s);
+	for(i=0; i<6; i++)wpa_printf(MSG_DEBUG,"%02X ",mac[i]);
+	wpa_printf(MSG_DEBUG,"\n");
+}
+
+void stamp_all_max( unsigned char *buf,  unsigned char *own_mac){
+	struct ieee80211_hdr *hdr;
+	
+	hdr = (struct ieee80211_hdr *) buf;
+
+	stampa_mac("addr1 ",hdr->addr1);
+	stampa_mac("addr2 ",hdr->addr2);
+	stampa_mac("addr3 ",hdr->addr3);
+	stampa_mac("own_mac ", own_mac);
+}
+
+int isCallBackFrame( unsigned char *buf, int len,  unsigned char *own_mac){
+	// return 1 if is it CALL Back Frame
+	// return 0 if is NOT CALL Back Frame
+	struct ieee80211_hdr *hdr;
+	u16 fc;
+	
+	hdr = (struct ieee80211_hdr *) buf;
+	fc = le_to_host16(hdr->frame_control);
+
+	if( same_mac(hdr->addr2,own_mac)==0 && same_mac(hdr->addr3,own_mac)==0 )return 1;
+	return 0;
+}
+
+int AC_get_SubType( unsigned char *buf, int len){
+	struct ieee80211_hdr *hdr;
+	u16 fc;
+	
+	hdr = (struct ieee80211_hdr *) buf;
+	fc = le_to_host16(hdr->frame_control);
+	
+	return WLAN_FC_GET_STYPE(fc);
+}
+
+int AC_get_Type( unsigned char *buf, int len){
+	struct ieee80211_hdr *hdr;
+	u16 fc;
+	
+	hdr = (struct ieee80211_hdr *) buf;
+	fc = le_to_host16(hdr->frame_control);
+	
+	return WLAN_FC_GET_TYPE(fc);
+}
+
diff -purN hostapd-20130302/src/capwap/capwap_mgmt_frame.h hostapd-20130302-linux/src/capwap/capwap_mgmt_frame.h
--- hostapd-20130302/src/capwap/capwap_mgmt_frame.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/capwap_mgmt_frame.h	2013-07-06 06:07:00.000000000 -0400
@@ -0,0 +1,11 @@
+#include "drivers/driver.h"
+
+int GetEapol_Frame( unsigned char *sa,  unsigned char *buf, int len);
+
+int isEAPOL_Frame( unsigned char *buf, int len);
+
+int isCallBackFrame( unsigned char *buf, int len,  unsigned char *own_mac);
+
+int AC_get_SubType( unsigned char *buf, int len);
+
+int AC_get_Type( unsigned char *buf, int len);
diff -purN hostapd-20130302/src/capwap/file_conf.h hostapd-20130302-linux/src/capwap/file_conf.h
--- hostapd-20130302/src/capwap/file_conf.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/file_conf.h	2013-07-07 13:07:40.000000000 -0400
@@ -0,0 +1,121 @@
+#define CONFIGFILE "/etc/hostapd_ac.conf"
+#define VARLENGTH 1024 
+
+struct config_ac {
+	int ac_port;
+	char ip_ac[50];
+	char path_unix_socket[50];
+}config_ac;
+
+int max_(int integer1,int integer2){
+	if(integer1>integer2)return integer1;
+	return integer2;
+}
+
+int countString(char string[]){
+	int cnt=0;
+	for(cnt=0;string[cnt]!=0;cnt++);
+	return cnt;
+}
+
+int isEqualString(char String1[],char String2[]){
+	int len1=countString(String1);
+	int len2=countString(String2);
+	int i;
+	for( i=0;i<max_(len1,len2);++i ){
+		if ( String1[i]==0 && String2[i]==0 )return 1;
+		if ( String1[i]==0 || String2[i]==0 )return 0;
+		if ( String1[i]!=String2[i] )return 0;
+	}
+	return 1;
+}
+
+int StartWith(char String1[],char String2[]){
+	int len1=countString(String1);
+	int len2=countString(String2);
+	int i;
+	
+	for( i=0; i<len2;i++ ){
+
+		if ( String1[i]!=String2[i] )return 0;
+	}
+
+	return 1;
+}
+
+void ReplaceString(char *String1,char *rep,char *String2){	
+	if(isEqualString(String1,rep)){
+		String1[0]=0;
+		return;
+	}
+	if(String1[0]==0 || rep[0]==0)return;
+	int i,j,k,b,l,m;
+	char tmp[strlen(String1)+strlen(String2)+1];
+	for(i=0;i<=strlen(String1)+strlen(String2)-1;i++)tmp[i]=88;
+	tmp[i]=0;
+	for(i=0;i<=strlen(String1)-1;i++){
+		if(strlen(rep)>=1)b=1;
+		for(j=0;j<=strlen(rep)-1;j++){
+			if(String1[i+j]!=rep[j]){ 
+				b=0; 
+				break; 
+			}
+		}	
+		if(b){
+			for(k=0;k<i;k++)tmp[k]=String1[k];
+			if(strlen(String2)>0){
+				for(m=0;m<=strlen(String2)-1;++m,k++)tmp[k]=String2[m];
+			}
+			for(l=i+j;l<=strlen(String1)-1;l++,k++)tmp[k]=String1[l];
+			tmp[k]=0;
+
+			for(k=0;k<strlen(tmp);k++)String1[k]=tmp[k];
+			if (String1[k-1]==10)String1[k-1]=0;
+			else 	String1[k]=0;	
+		}
+	}
+}
+
+void ReadConfiguration(struct config_ac *con_ac){
+	FILE *file;
+
+    file=fopen(CONFIGFILE,"r");
+
+	char ss[VARLENGTH];
+	
+	sprintf(con_ac->ip_ac,"");
+	sprintf(con_ac->path_unix_socket,"");
+	con_ac->ac_port=0;
+
+	while(1){
+		if (fgets(ss,VARLENGTH,file)==NULL)break;
+		if(ss[0]=='\r' || ss[0]=='\n' || ss[0]=='#')continue;
+
+		if(StartWith(ss,"ip_daemon_ac")){
+			ReplaceString(ss, "ip_daemon_ac", "");
+			ReplaceString(ss, "=", "");
+			ReplaceString(ss, "\n", "");
+			ReplaceString(ss, " ", "");
+			sprintf(con_ac->ip_ac, "%s", ss);
+			
+		}else if(StartWith(ss,"sock_path_ac")){
+			ReplaceString(ss, "sock_path_ac", "");
+			ReplaceString(ss, "=", "");
+			ReplaceString(ss, "\n", "");
+			ReplaceString(ss, " ", "");
+			sprintf(con_ac->path_unix_socket, "%s", ss);
+			
+		}else if(StartWith(ss,"port_daemon_ac")){
+			ReplaceString(ss, "port_daemon_ac","");
+			ReplaceString(ss, "\n", "");
+			ReplaceString(ss, " ", "");
+			ReplaceString(ss, "=", "");
+			con_ac->ac_port = atoi(ss);
+		}
+
+	}
+	fclose(file);
+	return;
+}
+
+
diff -purN hostapd-20130302/src/capwap/ipc_capwap_ac.c hostapd-20130302-linux/src/capwap/ipc_capwap_ac.c
--- hostapd-20130302/src/capwap/ipc_capwap_ac.c	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/ipc_capwap_ac.c	2013-07-07 03:52:10.000000000 -0400
@@ -0,0 +1,597 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+#include "eloop.h"
+#include "utils/includes.h"
+
+
+#include "utils/common.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "drivers/driver.h"
+#include "ap/hostapd.h"
+#include "ap/ap_config.h"
+#include "ap/ap_drv_ops.h"
+
+#include "file_conf.h"
+#include "smac_code.h"
+#include "ipc_capwap_ac.h"
+
+#define MAX_BUF 3000
+
+//#define LOCALUDP
+//#define NETUDP
+//#define USEIPV6
+
+struct config_ac con_ac;
+unsigned char wlan0_capa[21];
+
+int fd_con;
+
+
+#if defined(LOCALUDP)
+	struct sockaddr_un addr;
+	struct sockaddr_un local;
+	int rn;
+	
+#else
+	#if defined(USEIPV6)
+		struct sockaddr_in6 client;
+		struct sockaddr_in6 addr;
+	#else
+		struct sockaddr_in client;
+		struct sockaddr_in addr;
+	#endif
+#endif
+
+#define SETBIT(ADDRESS,BIT) (ADDRESS |= (1<<BIT))
+#define CLEARBIT(ADDRESS,BIT) (ADDRESS &= ~(1<<BIT))
+#define CHECKBIT(ADDRESS,BIT) (ADDRESS & (1<<BIT))
+
+
+
+int address_size;
+
+int capability_is_A(){
+	if( CHECKBIT(wlan0_capa[8],1))return 1;
+	else return 0;
+}
+int capability_is_B(){
+	if( CHECKBIT(wlan0_capa[8],0))return 1;
+	else return 0;
+}
+int capability_is_G(){
+	if( CHECKBIT(wlan0_capa[8],2))return 1;
+	else return 0;
+}
+int capability_is_N(){
+	if( CHECKBIT(wlan0_capa[8],3))return 1;
+	else return 0;
+}
+
+int capability_get_num_modes(){
+	int num_modes = 0;
+	
+	if( CHECKBIT(wlan0_capa[8],0)) num_modes++;
+	if( CHECKBIT(wlan0_capa[8],1)) num_modes++;
+	if( CHECKBIT(wlan0_capa[8],2)) num_modes++;
+	if( CHECKBIT(wlan0_capa[8],3)) num_modes++;
+	
+	return num_modes;
+}
+
+int capability_get_first_channel(){
+	return (int)wlan0_capa[10];
+}
+
+int capability_get_num_channels(){
+	return (int)wlan0_capa[12];
+}
+
+int capability_get_max_dBm(){
+	return (int)wlan0_capa[14];
+}
+
+int capability_get_rates(int *rate_arr){
+	int num_rates = 0;
+	int i;
+	for(i=0; i<8; i++){
+		if( wlan0_capa[i]==0 ) continue;
+
+		if( CHECKBIT(wlan0_capa[i],7) ){
+			CLEARBIT(wlan0_capa[i],7);
+			rate_arr[num_rates] = (int)(wlan0_capa[i] * -5);
+		}else{
+			rate_arr[num_rates] = (int)(wlan0_capa[i] * 5);
+		}
+		num_rates++;
+	}
+	return num_rates;
+}
+
+void capability_get_mac(char *buf){
+	memcpy(buf, wlan0_capa + 15, 6);
+}
+
+void prep_beacon(int fd,struct hostapd_data *hapd,struct wpa_driver_ap_params *params){
+	struct hostapd_data *h = hapd;
+	short ssid_len = (short)h->conf->ssid.ssid_len;
+	short key_len = (short) h->conf->ssid.wep.len[h->conf->ssid.wep.idx];
+	
+	
+	wpa_printf(MSG_DEBUG,"SSID: %s ssid_len:%d\n",h->conf->ssid.ssid,ssid_len);
+	wpa_printf(MSG_DEBUG,"IDX:%d   key_len:%d    key:%s  \n",h->conf->ssid.wep.idx,key_len,h->conf->ssid.wep.key[h->conf->ssid.wep.idx]);
+
+	unsigned char A1 = 0;
+	unsigned char A2 = 0;
+	
+	SETBIT(A1,7); 	//E (ESS)
+	CLEARBIT(A1,6); //I (IBSS)
+	CLEARBIT(A1,5); //C (CF Pollable)
+	CLEARBIT(A1,4); //F (CF Pollable Request)
+	if(params->privacy)		SETBIT(A1,3); //P (Privacy)
+	else					CLEARBIT(A1,3); //P (Privacy)
+	if(params->preamble)	SETBIT(A1,2); //S (Sort Preamble)
+	else    				CLEARBIT(A1,2); //S (Sort Preamble)
+	CLEARBIT(A1,1); //B (PBCC)
+	CLEARBIT(A1,0); //A (Channel Agility)
+	
+	CLEARBIT(A2,7); //I (IBSS)
+	CLEARBIT(A2,6); //I (IBSS)
+	if(params->short_slot_time)		SETBIT(A2,5); //I (IBSS)
+	else  							CLEARBIT(A2,5); //I (IBSS)
+	CLEARBIT(A2,4); //I (IBSS)
+	CLEARBIT(A2,3); //I (IBSS)
+	CLEARBIT(A2,2); //I (IBSS)
+	CLEARBIT(A2,1); //I (IBSS)
+	CLEARBIT(A2,0); //I (IBSS)
+	
+
+
+	int tot_len = 19 + ssid_len + key_len;
+	
+	
+	unsigned char buf[tot_len];
+	
+	wpa_printf(MSG_DEBUG,"Tot Len:%d \n",tot_len);
+	
+	buf[0] = 0; // Radio ID
+	buf[1] = 0; // WLAN ID
+	buf[2] = A1; // Flags Part1
+	buf[3] = A2;  // Flags Part2
+	
+	buf[4] = h->conf->ssid.wep.idx;  // Key Index
+	
+	if(params->privacy)	buf[5] = 1;  // Key Status
+	else 				buf[5] = 0;  // Key Status
+	
+	wpa_printf(MSG_DEBUG,"keylen: %d \n",key_len);
+	
+	
+	//memcpy(buf+6, &key_len, 1);
+	//memcpy(buf+7, &key_len, 1);
+	if (key_len > 0){
+	buf[6] = *(&key_len + 1);  // Key Length Part1
+	buf[7] = *(&key_len + 0);  // Key Length Part2
+	}
+	else {
+	buf[6] = *(&key_len + 0);
+	buf[7] = *(&key_len + 0);
+	}
+
+	wpa_printf(MSG_DEBUG,"keylen: %d %02X %02X \n",key_len,buf[6],buf[7]);
+	
+	if( key_len ) memcpy( buf + 8, h->conf->ssid.wep.key[h->conf->ssid.wep.idx], key_len);
+	
+	buf[8+key_len] = 0;   // Group TSC Part1
+	buf[9+key_len] = 0;   // Group TSC Part2
+	buf[10+key_len] = 0;  // Group TSC Part3
+	buf[11+key_len] = 0;  // Group TSC Part4
+	
+	buf[12+key_len] = 0;  // Group TSC Part5
+	buf[13+key_len] = 0;  // Group TSC Part6
+	buf[14+key_len] = 0;  // QoS
+	
+	if(params->privacy)	buf[15+key_len] = 1;  // Auth Type
+	else 				buf[15+key_len] = 0;  // Auth Type
+	
+	buf[16+key_len] = 1;  // Mac Mode
+	buf[17+key_len] = 2;  // Tunnel Mode
+	buf[18+key_len] = 1;  // Suppress SSID
+	
+	memcpy(buf + key_len + 19, h->conf->ssid.ssid, ssid_len);
+	
+	int i;
+	for(i=0; i<tot_len; i++){
+		if((i%4)==0)printf("\n");
+		wpa_printf(MSG_DEBUG,"%02X ",buf[i]);
+	}
+	wpa_printf(MSG_DEBUG,"\n");
+	
+	send_response(fd, ADD_WLAN, buf, tot_len);
+}
+
+void ipc_send_ADD_WLAN(int fd,char *ssid, int len){
+
+	int new_len = 19 + len;
+	unsigned char cmd[new_len];
+	
+	
+	int i;
+	for(i=0; i<new_len; i++)cmd[i]=0;
+	
+	cmd[0] = 0; // Radio ID
+	cmd[1] = 0; // WLAN ID
+	cmd[2] = 128; // Flags Part1
+	cmd[3] = 0;  // Flags Part2
+	
+	cmd[4] = 0;  // Key Index
+	cmd[5] = 0;  // Key Status
+	cmd[6] = 0;  // Key Length Part1
+	cmd[7] = 0;  // Key Length Part2
+	
+	cmd[8] = 0;   // Group TSC Part1
+	cmd[9] = 0;   // Group TSC Part2
+	cmd[10] = 0;  // Group TSC Part3
+	cmd[11] = 0;  // Group TSC Part4
+	
+	cmd[12] = 0;  // Group TSC Part5
+	cmd[13] = 0;  // Group TSC Part6
+	cmd[14] = 0;  // QoS
+	cmd[15] = 0;  // Auth Type
+	
+	cmd[16] = 1;  // Mac Mode
+	cmd[17] = 2;  // Tunnel Mode
+	cmd[18] = 1;  // Suppress SSID
+	
+	
+	memcpy(cmd+19, ssid, len);
+	
+	send_response(fd, ADD_WLAN, cmd, new_len);
+}
+
+
+void ipc_send_DEL_WLAN(int fd){
+	unsigned char cmd[2];
+
+	cmd[0] = 0; // Radio ID
+	cmd[1] = 0; // WLAN ID
+	wpa_printf(MSG_DEBUG,"DEL 1\n");
+	send_response(fd, DEL_WLAN, cmd, 2);
+}
+
+void ipc_send_CLOSE_to_AC(int fd){
+	char cmd[10];
+	send_response(fd, CLOSE, cmd, 10);
+}
+
+void ipc_send_add_station(int fd, u8 *buf, int len){
+	u16 fc;
+	int status = -1;
+	unsigned char cmd[6];
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_hdr *hdr;
+	mgmt = (struct ieee80211_mgmt *) buf;
+	hdr = (struct ieee80211_hdr *) buf;
+	
+	fc = le_to_host16(hdr->frame_control);
+	
+	if( WLAN_FC_GET_STYPE(fc)==WLAN_FC_STYPE_ASSOC_RESP ){
+		status = le_to_host16(mgmt->u.assoc_resp.status_code);
+		
+	}else if( WLAN_FC_GET_STYPE(fc)==WLAN_FC_STYPE_REASSOC_RESP){
+		status = le_to_host16(mgmt->u.reassoc_resp.status_code);
+		
+	}else{
+		wpa_printf(MSG_ERROR, "Error: ipc_send_add_station\n");
+		return;
+	}
+	
+	if(status == 0){
+		memcpy(cmd,mgmt->da,6);
+		send_response(fd, SET_ADDR, cmd, 6);
+	}
+	
+	
+}
+
+void ipc_send_del_station(int fd, u8 *buf, int len){
+	u16 fc;
+	unsigned char cmd[6];
+	struct ieee80211_hdr *hdr;
+	hdr = (struct ieee80211_hdr *) buf;
+	
+	fc = le_to_host16(hdr->frame_control);
+	
+	if( WLAN_FC_GET_STYPE(fc) != WLAN_FC_STYPE_DISASSOC ){
+		wpa_printf(MSG_DEBUG,"Il pacchetto non e' di tipo DISASSOC\n");
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG,"DEL ADDR: %02X %02X %02X %02X %02X %02X \n",hdr->addr2[0],hdr->addr2[1],hdr->addr2[2],hdr->addr2[3],hdr->addr2[4],hdr->addr2[5]);
+
+	memcpy(cmd,hdr->addr2,6);
+	send_response(fd, DEL_ADDR, cmd, 6);
+
+}
+
+void ipc_send_80211_to_wtp(int fd, u8 *buf, int len){
+	
+	send_response(fd, DATE_TO_WTP, buf, len);
+}
+
+void send_response(int fd, u8 code, u8 *buf, int len){
+	u8 tmp_buf[MAX_BUF];
+	tmp_buf[0] = code;
+	
+	int n;
+	
+	#if defined(LOCALUDP)
+		sprintf(tmp_buf + 1, "%05d", rn);
+		memcpy(tmp_buf + 6, buf, len);
+		n = sendto(fd, tmp_buf, len + 6, 0, (struct sockaddr *)&addr, address_size);
+	#else
+		memcpy(tmp_buf + 1, buf, len);
+		n = sendto(fd, tmp_buf, len + 1, 0, (struct sockaddr *)&addr, address_size);
+	#endif
+	
+
+	if ( n < 0 ) {
+		perror("send");
+		return;
+	}
+	
+}
+
+
+void management_recv(int fd, u8 code, u8 *buf, int len, void *hapd, void *inject_func){
+
+	if(code == PING){
+		send_response(fd, PONG, buf, len);
+		
+	}else if( code==DATE_TO_AC ){
+		struct hostapd_data *h = hapd;
+		void (*pointer_inject_frame_in_hostapd) (void*,unsigned char*,int);
+		pointer_inject_frame_in_hostapd = inject_func;
+		pointer_inject_frame_in_hostapd(h->drv_priv, buf, len);
+		//hostapd_inject_frame_in_hostapd(h, buf, len);
+		
+	}else{
+		wpa_printf(MSG_DEBUG,"ERROR IPC: received unrecognizedcode: %d\n",code);
+	}
+
+}
+
+void recv_request(int fd,void *hapd, void *inject_func){
+	char str[MAX_BUF];
+
+	int n;
+	
+	#if defined(LOCALUDP)
+		n = recvfrom(fd, str, MAX_BUF, 0, (struct sockaddr *)&local, &address_size);
+	#else
+		n = recvfrom(fd, str, MAX_BUF, 0, (struct sockaddr *)&addr, &address_size);
+	#endif
+	
+
+    if(n<=0){
+		end_ipc(fd);
+		return;
+	}
+	
+		
+	management_recv(fd, str[0], str + 1, n -1, hapd, inject_func);	
+}
+
+
+
+int open_socket(){
+	
+	
+	int fd_ac, n, con_res;
+	
+	char buffer[100];
+	
+	#if defined(LOCALUDP)
+		srand((unsigned)time(0));
+		fd_ac = socket(AF_UNIX, SOCK_DGRAM, 0);
+		
+	#elif defined(NETUDP)
+		#if defined(USEIPV6)
+			fd_ac = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+		#else
+			fd_ac = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+		#endif	
+		
+	#else
+		#if defined(USEIPV6)
+			fd_ac = socket(AF_INET6, SOCK_SEQPACKET, IPPROTO_SCTP);
+		#else
+			fd_ac = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP);
+		#endif
+
+	#endif
+	
+	#if defined(LOCALUDP)
+		addr.sun_family = AF_UNIX;
+		strcpy(addr.sun_path, con_ac.path_unix_socket);
+		local.sun_family = AF_UNIX;
+		
+		while(1){
+			rn = rand()%100000;
+			sprintf(local.sun_path, "%s%05d", con_ac.path_unix_socket, rn);
+			if( bind(fd_ac, (struct sockaddr *)&local, strlen(local.sun_path) + sizeof(local.sun_family))==-1){
+				sleep(1); 
+				continue; 
+			}
+			break;
+		}
+		wpa_printf(MSG_DEBUG,"Connect to %s from %s\n",addr.sun_path, local.sun_path);				
+			
+	#else
+		#if defined(USEIPV6)
+			addr.sin6_family = AF_INET6;
+			addr.sin6_port = con_ac.ac_port;
+			inet_pton(AF_INET6, con_ac.ip_ac, &addr.sin6_addr);
+		#else
+			addr.sin_family = AF_INET;
+			addr.sin_port = htons(con_ac.ac_port);
+			addr.sin_addr.s_addr = inet_addr(con_ac.ip_ac);
+			
+		#endif
+
+		wpa_printf(MSG_DEBUG,"Try connecting to %s:%d\n",con_ac.ip_ac, con_ac.ac_port);
+		
+	#endif
+	
+	address_size = sizeof(addr);
+
+
+		
+	while(1){
+		#if defined(LOCALUDP)
+			sprintf(buffer,"Z%05dconnect",rn);
+		#else
+			sprintf(buffer,"Zconnect");
+		#endif
+		
+		buffer[0] = CONNECT;
+		
+		n = sendto(fd_ac, buffer, strlen(buffer), 0, (struct sockaddr *)&addr, address_size);
+  
+		#if defined(LOCALUDP)
+			n = recvfrom(fd_ac, buffer, sizeof(buffer), 0, (struct sockaddr *)&local, &address_size);
+		#else
+			n = recvfrom(fd_ac, buffer, sizeof(buffer), 0, (struct sockaddr *)&addr, &address_size);
+		#endif
+		if(buffer[0] == CONNECT_R){
+			wpa_printf(MSG_DEBUG,"CONNECTED!!!");
+			break;
+
+		}else{
+			sleep(3);
+			
+		}
+	}
+	
+    return fd_ac;
+}
+
+
+void wait_capability_from_AC(int fd, void *hapd){
+	unsigned char buffer[10];
+	int n;
+	
+	sleep(0.5);
+	
+	while(1){
+		
+		#if defined(LOCALUDP)
+			sprintf(buffer,"X%05d",rn);
+		#else
+			sprintf(buffer,"X");
+		#endif
+		
+		buffer[0] = WANT_GOLIVE;
+		n = sendto(fd, buffer, strlen(buffer), 0, (struct sockaddr *)&addr, address_size);
+  
+
+
+		#if defined(LOCALUDP)
+			n = recvfrom(fd, buffer, 10, 0, (struct sockaddr *)&local, &address_size);
+		#else
+			n = recvfrom(fd, buffer, 10, 0, (struct sockaddr *)&addr, &address_size);
+		#endif
+	
+		if(n<=0){
+			end_ipc(fd);
+			return;
+		}
+		
+		if(buffer[0] == SET_WTPRINFO){
+			wpa_printf(MSG_DEBUG,"SET_WTPRINFO: %02X\n",buffer[1]);
+			memcpy( wlan0_capa+8, buffer+1, 1);
+			send_response(fd, SET_WTPRINFO_R, NULL, 0);
+			
+		}else if(buffer[0] == SET_RATES){
+			wpa_printf(MSG_DEBUG,"SET_RATES: %02X %02X %02X %02X %02X %02X %02X %02X\n",buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6],buffer[7],buffer[8]);
+			memcpy( wlan0_capa, buffer+1, 8);
+			send_response(fd, SET_RATES_R, NULL, 0);
+			
+		}else if(buffer[0] == SET_MDC){
+			wpa_printf(MSG_DEBUG,"SET_MDC: %02X %02X %02X %02X %02X %02X\n",buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6]);
+			memcpy( wlan0_capa+9, buffer+1, 6);
+			send_response(fd, SET_MDC_R, NULL, 0);
+			
+		}else if(buffer[0] == SET_MAC){
+			wpa_printf(MSG_DEBUG,"SET_MAC: %02X %02X %02X %02X %02X %02X\n",buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6]);
+			memcpy( wlan0_capa+15, buffer+1, 6);
+			send_response(fd, SET_MAC_R, NULL, 0);
+			
+		}else if(buffer[0] == GOLIVE){
+			wpa_printf(MSG_DEBUG,"GOLIVE:\n");
+			send_response(fd, GOLIVE_R, NULL, 0);
+			break;
+			
+		}else if(buffer[0] == HAVE_TO_WAIT){
+			wpa_printf(MSG_DEBUG,"WAIT");
+			sleep(1);
+		
+		}else if(buffer[0] == CLOSE){
+			wpa_printf(MSG_DEBUG,"CLOSE");
+			end_ipc(fd);
+			
+		}else{
+			wpa_printf(MSG_DEBUG,"Unknow code (%d) received in CONNECTed Fase\n",buffer[0]);
+		}
+	}
+	
+}
+
+int end_ipc(int fd){
+	
+	ipc_send_CLOSE_to_AC(fd);
+	if(fd>=0){
+		eloop_unregister_read_sock(fd);
+		if(close(fd)<0 ){
+			
+			return -1;
+		}
+	}
+	
+	if(	fd_con>=0 ){
+		if(close(fd_con)<0 ){
+			
+		}
+	}
+	
+	return 0;
+}
+
+int start_ipc(void *hapd,void *inject_func){
+	ReadConfiguration(&con_ac);
+	wpa_printf(MSG_DEBUG,"< DISCONNECTED >\n");
+	
+	int sockfd = open_socket();
+	wpa_printf(MSG_DEBUG,"< CONNECTED >\n");
+	
+	wait_capability_from_AC(sockfd, hapd);
+	wpa_printf(MSG_DEBUG,"< LIVE >\n");
+	
+
+	if(sockfd){
+		if (eloop_register_read_sock(sockfd, recv_request, hapd, inject_func)) {
+			wpa_printf(MSG_ERROR, "Clould not register IPC socket start_ipc");
+			return 0;
+		}
+	}
+	
+	return sockfd;
+}
+
+
diff -purN hostapd-20130302/src/capwap/ipc_capwap_ac.h hostapd-20130302-linux/src/capwap/ipc_capwap_ac.h
--- hostapd-20130302/src/capwap/ipc_capwap_ac.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/ipc_capwap_ac.h	2013-07-07 03:54:59.000000000 -0400
@@ -0,0 +1,7 @@
+void ipc_send_80211_to_wtp(int fd, u8 *buf, int len);
+
+int start_ipc(void *hapd,void *inject_func);
+
+int end_ipc(int fd);
+
+void send_response(int fd, u8 code, u8 *buf, int len);
diff -purN hostapd-20130302/src/capwap/Makefile hostapd-20130302-linux/src/capwap/Makefile
--- hostapd-20130302/src/capwap/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/Makefile	2013-07-06 07:04:12.000000000 -0400
@@ -0,0 +1,8 @@
+all:
+	@echo Nothing to be made.
+
+clean:
+	rm -f *~ *.o *.d
+
+install:
+	@echo Nothing to be made.
diff -purN hostapd-20130302/src/capwap/smac_code.h hostapd-20130302-linux/src/capwap/smac_code.h
--- hostapd-20130302/src/capwap/smac_code.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/capwap/smac_code.h	2013-07-06 06:07:00.000000000 -0400
@@ -0,0 +1,107 @@
+#include <linux/types.h>
+
+unsigned char ERROR = 0;
+
+unsigned char CLOSE = 1;
+
+unsigned char PING = 2; //  [2]ping
+unsigned char PONG = 3;//  [3]pong
+
+unsigned char START_WLAN = 4;
+unsigned char START_WLAN_R = 5;
+
+unsigned char STOP_WLAN = 6;
+unsigned char STOP_WLAN_R = 7;
+
+unsigned char SET_FREQ = 8; // FREQ sec_channel_offset ht_enabled channel MODE  ex. "[8]2462 0 0 11 0"
+unsigned char SET_FREQ_R = 9; // 0 or 1  ex. "[9]0"
+
+unsigned char GET_FREQ = 10; // ex. "[10]"
+unsigned char GET_FREQ_R = 11; // ex. "[11]2462 0 0 11 0"
+
+unsigned char SET_FRAG = 12; // Typically the range used for fragmentation threshold is 256-2346 (-1 == off) ex. "[12]2000"
+unsigned char SET_FRAG_R = 13;// ex. "[13]0"
+
+unsigned char GET_FRAG = 14; // ex. "[14]"   (-1 == off)
+unsigned char GET_FRAG_R = 15; // ex. "[15]2000" 
+
+unsigned char SET_BITRATE = 16; 
+unsigned char SET_BITRATE_R = 17;
+
+unsigned char GET_BITRATE = 18; 
+unsigned char GET_BITRATE_R = 19; 
+
+unsigned char SET_RTS = 20; // 0-2347 (-1 == off)  ex. "[20]100"  (-1 == off)
+unsigned char SET_RTS_R = 21;// ex. "[21]0"
+
+unsigned char GET_RTS = 22; // ex. "]22]"  (-1 == off)
+unsigned char GET_RTS_R = 23; // ex. "[23]100"
+
+unsigned char SET_TXPOWER = 24; 
+unsigned char SET_TXPOWER_R = 25;
+
+unsigned char GET_TXPOWER = 26; 
+unsigned char GET_TXPOWER_R = 27;
+
+/*
+ * VO - 0  CWMIN:3  CWMAX:7  AIFS:2
+ * VI - 1  CWMIN:7  CWMAX:15  AIFS:2
+ * BE - 2  CWMIN:15  CWMAX:1023  AIFS:3
+ * BK - 3  CWMIN:15  CWMAX:1023  AIFS:7
+ */
+unsigned char SET_TXQ = 28; 
+unsigned char SET_TXQ_R = 29; 
+
+unsigned char GET_TXQ = 30; 
+unsigned char GET_TXQ_R = 31;
+
+unsigned char SET_ADDR = 32;
+unsigned char SET_ADDR_R = 33;
+
+unsigned char DEL_ADDR = 34;
+unsigned char DEL_ADDR_R = 35;
+
+unsigned char ADD_WLAN = 36;
+unsigned char ADD_WLAN_R = 37;
+
+unsigned char DEL_WLAN = 38;
+unsigned char DEL_WLAN_R = 39;
+
+unsigned char WTPRINFO = 40;
+unsigned char WTPRINFO_R = 41;
+
+unsigned char GET_RATES = 42;
+unsigned char GET_RATES_R = 43;
+
+unsigned char GET_MDC = 44;
+unsigned char GET_MDC_R = 45;
+
+unsigned char SET_WTPRINFO = 46;
+unsigned char SET_WTPRINFO_R = 47;
+
+unsigned char SET_RATES = 48;
+unsigned char SET_RATES_R = 49;
+
+unsigned char SET_MDC = 50;
+unsigned char SET_MDC_R = 51;
+
+unsigned char GOLIVE = 52;
+unsigned char GOLIVE_R = 53;
+
+unsigned char WANT_GOLIVE = 54;
+unsigned char HAVE_TO_WAIT = 55;
+
+unsigned char GET_MAC = 56;
+unsigned char GET_MAC_R = 57;
+
+unsigned char SET_MAC = 58;
+unsigned char SET_MAC_R = 59;
+
+unsigned char DATE_TO_WTP = 100;
+unsigned char DATE_TO_AC = 	101;
+
+unsigned char CONNECT = 102;
+unsigned char CONNECT_R = 103;
+
+unsigned char GOWAITWLAN = 104;
+unsigned char GOWAITWLAN_R = 105;
diff -purN hostapd-20130302/src/common/wpa_common.c hostapd-20130302-linux/src/common/wpa_common.c
--- hostapd-20130302/src/common/wpa_common.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/common/wpa_common.c	2013-07-04 11:17:51.000000000 -0400
@@ -965,6 +965,31 @@ const char * wpa_key_mgmt_txt(int key_mg
 }
 
 
+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
+				 size_t rsn_ie_len)
+{
+	int pos, count;
+
+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
+	if (rsn_ie_len < pos + 2)
+		return;
+
+	count = WPA_GET_LE16(wpa_msg_ie + pos);
+	pos += 2 + count * RSN_SELECTOR_LEN;
+	if (rsn_ie_len < pos + 2)
+		return;
+
+	count = WPA_GET_LE16(wpa_msg_ie + pos);
+	pos += 2 + count * RSN_SELECTOR_LEN;
+	if (rsn_ie_len < pos + 2)
+		return;
+
+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
+}
+
+
 int wpa_compare_rsn_ie(int ft_initial_assoc,
 		       const u8 *ie1, size_t ie1len,
 		       const u8 *ie2, size_t ie2len)
@@ -972,8 +997,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
 	if (ie1 == NULL || ie2 == NULL)
 		return -1;
 
-	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
-		return 0; /* identical IEs */
+	if (ie1len == ie2len) {
+		u8 *ie_tmp;
+
+		if (os_memcmp(ie1, ie2, ie1len) == 0)
+			return 0; /* identical IEs */
+
+		ie_tmp = alloca(ie1len);
+		memcpy(ie_tmp, ie1, ie1len);
+		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
+
+		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
+			return 0; /* only mismatch in RSN capabilties */
+	}
 
 #ifdef CONFIG_IEEE80211R
 	if (ft_initial_assoc) {
diff -purN hostapd-20130302/src/drivers/capwap_copy.h hostapd-20130302-linux/src/drivers/capwap_copy.h
--- hostapd-20130302/src/drivers/capwap_copy.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/capwap_copy.h	2013-07-06 06:06:45.000000000 -0400
@@ -0,0 +1,9 @@
+enum capwap_iftype {
+	ADHOC,
+	STATION,
+	AP,
+	MONITOR,
+	P2P_CLIENT,
+	P2P_GO
+};
+
diff -purN hostapd-20130302/src/drivers/driver_capwap.c hostapd-20130302-linux/src/drivers/driver_capwap.c
--- hostapd-20130302/src/drivers/driver_capwap.c	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/driver_capwap.c	2013-07-07 03:56:47.000000000 -0400
@@ -0,0 +1,9603 @@
+/*
+ * Driver interaction with Linux capwap/cfg80211
+ * Copyright (c) 2002-2012, Jouni Malinen <j@w1.fi>
+ * Copyright (c) 2003-2004, Instant802 Networks, Inc.
+ * Copyright (c) 2005-2006, Devicescape Software, Inc.
+ * Copyright (c) 2007, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright (c) 2009-2010, Atheros Communications
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include "includes.h"
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <net/if.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/socket.h>
+#include <netinet/ip.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <linux/errqueue.h>
+#include "nl80211_copy.h"
+#include "capwap_copy.h"
+
+#include "common.h"
+#include "eloop.h"
+#include "utils/list.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "l2_packet/l2_packet.h"
+#include "capwap/capwap_mgmt_frame.h"
+#include "capwap/ipc_capwap_ac.h"
+#include "netlink_fake.h"
+#include "linux_ioctl_fake.h"
+#include "radiotap.h"
+#include "radiotap_iter.h"
+#include "rfkill.h"
+#include "driver.h"
+
+#define SETBIT(ADDRESS,BIT) (ADDRESS |= (1<<BIT))
+#define CLEARBIT(ADDRESS,BIT) (ADDRESS &= ~(1<<BIT))
+#define CHECKBIT(ADDRESS,BIT) (ADDRESS & (1<<BIT))
+
+#define BUFFER_SIZE 65000
+
+struct ac_info {
+       const char *pseudo_interface;
+       char *eth_interface;
+       char own_mac_addr[ETH_ALEN];
+       int fd_ipc;
+};
+
+struct ac_info generic_ac_info;
+void AC_inject_frame_in_hostapd(void *priv, u8 *buf, int len);
+
+
+#ifndef SO_WIFI_STATUS
+# if defined(__sparc__)
+#  define SO_WIFI_STATUS	0x0025
+# elif defined(__parisc__)
+#  define SO_WIFI_STATUS	0x4022
+# else
+#  define SO_WIFI_STATUS	41
+# endif
+
+# define SCM_WIFI_STATUS	SO_WIFI_STATUS
+#endif
+
+#ifndef SO_EE_ORIGIN_TXSTATUS
+#define SO_EE_ORIGIN_TXSTATUS	4
+#endif
+
+#ifndef PACKET_TX_TIMESTAMP
+#define PACKET_TX_TIMESTAMP	16
+#endif
+
+#ifdef ANDROID
+#include "android_drv.h"
+
+/* system/core/libnl_2 in AOSP does not include nla_put_u32() */
+int nla_put_u32(struct nl_msg *msg, int attrtype, uint32_t value)
+{
+	return nla_put(msg, attrtype, sizeof(uint32_t), &value);
+}
+#endif /* ANDROID */
+#ifdef CONFIG_LIBNL20
+/* libnl 2.0 compatibility code */
+#define nl_handle nl_sock
+#define capwap_handle_alloc nl_socket_alloc_cb
+#define capwap_handle_destroy nl_socket_free
+#else
+/*
+ * libnl 1.1 has a bug, it tries to allocate socket numbers densely
+ * but when you free a socket again it will mess up its bitmap and
+ * and use the wrong number the next time it needs a socket ID.
+ * Therefore, we wrap the handle alloc/destroy and add our own pid
+ * accounting.
+ */
+static uint32_t port_bitmap[32] = { 0 };
+
+static struct nl_handle *capwap_handle_alloc(void *cb)
+{
+	struct nl_handle *handle;
+	uint32_t pid = getpid() & 0x3FFFFF;
+	int i;
+
+	handle = nl_handle_alloc_cb(cb);
+
+	for (i = 0; i < 1024; i++) {
+		if (port_bitmap[i / 32] & (1 << (i % 32)))
+			continue;
+		port_bitmap[i / 32] |= 1 << (i % 32);
+		pid += i << 22;
+		break;
+	}
+
+	nl_socket_set_local_port(handle, pid);
+
+	return handle;
+}
+
+static void capwap_handle_destroy(struct nl_handle *handle)
+{
+	uint32_t port = nl_socket_get_local_port(handle);
+
+	port >>= 22;
+	port_bitmap[port / 32] &= ~(1 << (port % 32));
+
+	nl_handle_destroy(handle);
+}
+#endif /* CONFIG_LIBNL20 */
+
+
+static struct nl_handle * nl_create_handle(struct nl_cb *cb, const char *dbg)
+{
+	struct nl_handle *handle;
+	handle = capwap_handle_alloc(cb);
+	if (handle == NULL) {
+		wpa_printf(MSG_ERROR, "capwap: Failed to allocate netlink "
+			   "callbacks (%s)", dbg);
+		return NULL;
+	}
+
+	if (genl_connect(handle)) {
+		wpa_printf(MSG_DEBUG, "capwap: Failed to connect to generic "
+			   "netlink (%s)", dbg);
+		capwap_handle_destroy(handle);
+		return NULL;
+	}
+
+	return handle;
+}
+
+static struct nl_cache * nl_create_cache(struct nl_handle *handle)
+{
+        struct nl_cache *cache;
+	wpa_printf(MSG_ERROR, "nl_create_cache()");
+        if (genl_ctrl_alloc_cache(handle, &cache) < 0) {
+                wpa_printf(MSG_ERROR, "capwap: Failed to allocate generic "
+                           "netlink cache");
+                return NULL;
+        }
+
+	return cache;
+}
+
+
+
+static void nl_destroy_handles(struct nl_handle **handle)
+{
+	if (*handle == NULL)
+		return;
+	capwap_handle_destroy(*handle);
+	*handle = NULL;
+}
+
+static void nl_destroy_cache(struct nl_cache **cache)
+{
+	if (*cache == NULL)
+		return;
+	nl_cache_free(*cache);
+	*cache = NULL;
+}
+
+
+#ifndef IFF_LOWER_UP
+#define IFF_LOWER_UP   0x10000         /* driver signals L1 up         */
+#endif
+#ifndef IFF_DORMANT
+#define IFF_DORMANT    0x20000         /* driver signals dormant       */
+#endif
+
+#ifndef IF_OPER_DORMANT
+#define IF_OPER_DORMANT 5
+#endif
+#ifndef IF_OPER_UP
+#define IF_OPER_UP 6
+#endif
+
+struct capwap_global {
+	struct dl_list interfaces;
+	int if_add_ifindex;
+	struct netlink_data *netlink;
+	struct nl_cb *nl_cb;
+	struct nl_handle *nl;
+	struct genl_family *capwap;
+	int ioctl_sock; /* socket for ioctl() use */
+	struct nl_cache *nl_cache;
+	struct nl_cache *nl_event_cache;
+	struct nl_handle *nl_event;
+};
+
+struct capwap_wiphy_data {
+	struct dl_list list;
+	struct dl_list bsss;
+	struct dl_list drvs;
+
+	struct nl_handle *nl_beacons;
+	struct nl_cb *nl_cb;
+	struct nl_cache *nl_beacons_cache;
+	int wiphy_idx;
+};
+
+static void capwap_global_deinit(void *priv);
+
+struct i802_bss {
+	struct wpa_driver_capwap_data *drv;
+	struct i802_bss *next;
+	int ifindex;
+	char ifname[IFNAMSIZ + 1];
+	char brname[IFNAMSIZ];
+	unsigned int beacon_set:1;
+	unsigned int added_if_into_bridge:1;
+	unsigned int added_bridge:1;
+	unsigned int in_deinit:1;
+	struct nl_cache *nl_mgmt_cache;
+	struct nl_cache *nl_preq_cache;
+	u8 addr[ETH_ALEN];
+
+	int freq;
+
+	void *ctx;
+	struct nl_handle *nl_preq, *nl_mgmt;
+	struct nl_cb *nl_cb;
+
+	struct capwap_wiphy_data *wiphy_data;
+	struct dl_list wiphy_list;
+};
+
+struct wpa_driver_capwap_data {
+	struct capwap_global *global;
+	struct dl_list list;
+	struct dl_list wiphy_list;
+	u8 addr[ETH_ALEN];
+	char phyname[32];
+	void *ctx;
+	int ifindex;
+	int if_removed;
+	int if_disabled;
+	int ignore_if_down_event;
+#ifdef CONFIG_RFKILL
+	struct rfkill_data *rfkill;
+#endif
+	struct wpa_driver_capa capa;
+	int has_capability;
+
+	int operstate;
+
+	int scan_complete_events;
+
+	struct nl_cb *nl_cb;
+
+	u8 auth_bssid[ETH_ALEN];
+	u8 bssid[ETH_ALEN];
+	int associated;
+	u8 ssid[32];
+	size_t ssid_len;
+	enum nl80211_iftype nlmode;
+	enum nl80211_iftype ap_scan_as_station;
+	unsigned int assoc_freq;
+
+	int monitor_sock;
+	int monitor_ifidx;
+	int monitor_refcount;
+
+	unsigned int disabled_11b_rates:1;
+	unsigned int pending_remain_on_chan:1;
+	unsigned int in_interface_list:1;
+	unsigned int device_ap_sme:1;
+	unsigned int poll_command_supported:1;
+	unsigned int data_tx_status:1;
+	unsigned int scan_for_auth:1;
+	unsigned int retry_auth:1;
+	unsigned int use_monitor:1;
+	unsigned int ignore_next_local_disconnect:1;
+
+	u64 remain_on_chan_cookie;
+	u64 send_action_cookie;
+
+	unsigned int last_mgmt_freq;
+
+	struct wpa_driver_scan_filter *filter_ssids;
+	size_t num_filter_ssids;
+
+	struct i802_bss first_bss;
+
+	int eapol_tx_sock;
+
+#ifdef HOSTAPD
+	int eapol_sock; /* socket for EAPOL frames */
+
+	int default_if_indices[16];
+	int *if_indices;
+	int num_if_indices;
+
+	int last_freq;
+	int last_freq_ht;
+#endif /* HOSTAPD */
+
+	/* From failed authentication command */
+	int auth_freq;
+	u8 auth_bssid_[ETH_ALEN];
+	u8 auth_ssid[32];
+	size_t auth_ssid_len;
+	int auth_alg;
+	u8 *auth_ie;
+	size_t auth_ie_len;
+	u8 auth_wep_key[4][16];
+	size_t auth_wep_key_len[4];
+	int auth_wep_tx_keyidx;
+	int auth_local_state_change;
+	int auth_p2p;
+};
+
+
+static void wpa_driver_capwap_deinit(struct i802_bss *bss);
+static void wpa_driver_capwap_scan_timeout(void *eloop_ctx,
+					    void *timeout_ctx);
+static int wpa_driver_capwap_set_mode(struct i802_bss *bss,
+				       enum nl80211_iftype nlmode);
+static int
+wpa_driver_capwap_finish_drv_init(struct wpa_driver_capwap_data *drv);
+static int wpa_driver_capwap_mlme(struct wpa_driver_capwap_data *drv,
+				   const u8 *addr, int cmd, u16 reason_code,
+				   int local_state_change);
+static void capwap_remove_monitor_interface(
+	struct wpa_driver_capwap_data *drv);
+static int capwap_send_frame_cmd(struct i802_bss *bss,
+				  unsigned int freq, unsigned int wait,
+				  const u8 *buf, size_t buf_len, u64 *cookie,
+				  int no_cck, int no_ack, int offchanok);
+static int wpa_driver_capwap_probe_req_report(struct i802_bss *bss,
+					       int report);
+#ifdef ANDROID
+static int android_pno_start(struct i802_bss *bss,
+			     struct wpa_driver_scan_params *params);
+static int android_pno_stop(struct i802_bss *bss);
+#endif /* ANDROID */
+
+#ifdef HOSTAPD
+static void add_ifidx(struct wpa_driver_capwap_data *drv, int ifidx);
+static void del_ifidx(struct wpa_driver_capwap_data *drv, int ifidx);
+static int have_ifidx(struct wpa_driver_capwap_data *drv, int ifidx);
+static int wpa_driver_capwap_if_remove(struct i802_bss *bss,
+					enum wpa_driver_if_type type,
+					const char *ifname);
+#else /* HOSTAPD */
+static inline void add_ifidx(struct wpa_driver_capwap_data *drv, int ifidx)
+{
+}
+
+static inline void del_ifidx(struct wpa_driver_capwap_data *drv, int ifidx)
+{
+}
+
+static inline int have_ifidx(struct wpa_driver_capwap_data *drv, int ifidx)
+{
+	return 0;
+}
+#endif /* HOSTAPD */
+
+static int wpa_driver_capwap_set_freq(struct i802_bss *bss,
+				       struct hostapd_freq_params *freq);
+static int capwap_disable_11b_rates(struct wpa_driver_capwap_data *drv,
+				     int ifindex, int disabled);
+
+static int capwap_leave_ibss(struct wpa_driver_capwap_data *drv);
+static int wpa_driver_capwap_authenticate_retry(
+	struct wpa_driver_capwap_data *drv);
+
+
+static int is_ap_interface(enum nl80211_iftype nlmode)
+{
+	return (nlmode == NL80211_IFTYPE_AP ||
+		nlmode == NL80211_IFTYPE_P2P_GO);
+}
+
+
+static int is_sta_interface(enum nl80211_iftype nlmode)
+{
+	return (nlmode == NL80211_IFTYPE_STATION ||
+		nlmode == NL80211_IFTYPE_P2P_CLIENT);
+}
+
+
+static int is_p2p_interface(enum nl80211_iftype nlmode)
+{
+	return (nlmode == NL80211_IFTYPE_P2P_CLIENT ||
+		nlmode == NL80211_IFTYPE_P2P_GO);
+}
+
+
+struct capwap_bss_info_arg {
+	struct wpa_driver_capwap_data *drv;
+	struct wpa_scan_results *res;
+	unsigned int assoc_freq;
+	u8 assoc_bssid[ETH_ALEN];
+};
+
+static int bss_info_handler(struct nl_msg *msg, void *arg);
+
+
+/* capwap code */
+static int ack_handler(struct nl_msg *msg, void *arg)
+{
+	int *err = arg;
+	*err = 0;
+	return NL_STOP;
+}
+
+static int finish_handler(struct nl_msg *msg, void *arg)
+{
+	int *ret = arg;
+	*ret = 0;
+	return NL_SKIP;
+}
+
+static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err,
+			 void *arg)
+{
+	int *ret = arg;
+	*ret = err->error;
+	return NL_SKIP;
+}
+
+
+static int no_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+
+static int send_and_recv(struct capwap_global *global,
+			 struct nl_handle *nl_handle, struct nl_msg *msg,
+			 int (*valid_handler)(struct nl_msg *, void *),
+			 void *valid_data)
+{
+	struct nl_cb *cb;
+	int err = -ENOMEM;
+
+	cb = nl_cb_clone(global->nl_cb);
+	if (!cb)
+		goto out;
+
+	err = nl_send_auto_complete(nl_handle, msg);
+	if (err < 0)
+		goto out;
+
+	err = 1;
+
+	nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &err);
+	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &err);
+	nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &err);
+
+	if (valid_handler)
+		nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM,
+			  valid_handler, valid_data);
+
+	while (err > 0)
+		nl_recvmsgs(nl_handle, cb);
+ out:
+	nl_cb_put(cb);
+	nlmsg_free(msg);
+	return err;
+}
+
+
+static int send_and_recv_msgs_global(struct capwap_global *global,
+				     struct nl_msg *msg,
+				     int (*valid_handler)(struct nl_msg *, void *),
+				     void *valid_data)
+{
+	return send_and_recv(global, global->nl, msg, valid_handler,
+			     valid_data);
+}
+
+
+static int send_and_recv_msgs(struct wpa_driver_capwap_data *drv,
+			      struct nl_msg *msg,
+			      int (*valid_handler)(struct nl_msg *, void *),
+			      void *valid_data)
+{
+	return send_and_recv(drv->global, drv->global->nl, msg,
+			     valid_handler, valid_data);
+}
+
+
+struct family_data {
+	const char *group;
+	int id;
+};
+
+
+static int family_handler(struct nl_msg *msg, void *arg)
+{
+	struct family_data *res = arg;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *mcgrp;
+	int i;
+
+	nla_parse(tb, CTRL_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	if (!tb[CTRL_ATTR_MCAST_GROUPS])
+		return NL_SKIP;
+
+	nla_for_each_nested(mcgrp, tb[CTRL_ATTR_MCAST_GROUPS], i) {
+		struct nlattr *tb2[CTRL_ATTR_MCAST_GRP_MAX + 1];
+		nla_parse(tb2, CTRL_ATTR_MCAST_GRP_MAX, nla_data(mcgrp),
+			  nla_len(mcgrp), NULL);
+		if (!tb2[CTRL_ATTR_MCAST_GRP_NAME] ||
+		    !tb2[CTRL_ATTR_MCAST_GRP_ID] ||
+		    os_strncmp(nla_data(tb2[CTRL_ATTR_MCAST_GRP_NAME]),
+			       res->group,
+			       nla_len(tb2[CTRL_ATTR_MCAST_GRP_NAME])) != 0)
+			continue;
+		res->id = nla_get_u32(tb2[CTRL_ATTR_MCAST_GRP_ID]);
+		break;
+	};
+
+	return NL_SKIP;
+}
+
+
+static int nl_get_multicast_id(struct capwap_global *global,
+			       const char *family, const char *group)
+{
+	struct nl_msg *msg;
+	int ret = -1;
+	struct family_data res = { group, -ENOENT };
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+	genlmsg_put(msg, 0, 0, genl_ctrl_resolve(global->nl, "nlctrl"),
+		    0, 0, CTRL_CMD_GETFAMILY, 0);
+	NLA_PUT_STRING(msg, CTRL_ATTR_FAMILY_NAME, family);
+
+	ret = send_and_recv_msgs_global(global, msg, family_handler, &res);
+	msg = NULL;
+	if (ret == 0)
+		ret = res.id;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static void * capwap_cmd(struct wpa_driver_capwap_data *drv,
+			  struct nl_msg *msg, int flags, uint8_t cmd)
+{
+	return NULL;
+}
+
+
+struct wiphy_idx_data {
+	int wiphy_idx;
+};
+
+
+static int netdev_info_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct wiphy_idx_data *info = arg;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (tb[NL80211_ATTR_WIPHY])
+		info->wiphy_idx = nla_get_u32(tb[NL80211_ATTR_WIPHY]);
+
+	return NL_SKIP;
+}
+
+
+static int capwap_get_wiphy_index(struct i802_bss *bss)
+{
+	struct nl_msg *msg;
+	struct wiphy_idx_data data = {
+		.wiphy_idx = -1,
+	};
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(bss->drv, msg, 0, NL80211_CMD_GET_INTERFACE);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+
+	if (send_and_recv_msgs(bss->drv, msg, netdev_info_handler, &data) == 0)
+		return data.wiphy_idx;
+	msg = NULL;
+nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
+
+static int capwap_register_beacons(struct wpa_driver_capwap_data *drv,
+				    struct capwap_wiphy_data *w)
+{
+	struct nl_msg *msg;
+	int ret = -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_REGISTER_BEACONS);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, w->wiphy_idx);
+
+	ret = send_and_recv(drv->global, w->nl_beacons, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Register beacons command "
+			   "failed: ret=%d (%s)",
+			   ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+	ret = 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static void capwap_recv_beacons(int sock, void *eloop_ctx, void *handle)
+{
+	struct capwap_wiphy_data *w = eloop_ctx;
+
+	wpa_printf(MSG_EXCESSIVE, "capwap: Beacon event message available");
+
+	nl_recvmsgs(handle, w->nl_cb);
+}
+
+
+static int process_beacon_event(struct nl_msg *msg, void *arg)
+{
+	struct capwap_wiphy_data *w = arg;
+	struct wpa_driver_capwap_data *drv;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	union wpa_event_data event;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (gnlh->cmd != NL80211_CMD_FRAME) {
+		wpa_printf(MSG_DEBUG, "capwap: Unexpected beacon event? (%d)",
+			   gnlh->cmd);
+		return NL_SKIP;
+	}
+
+	if (!tb[NL80211_ATTR_FRAME])
+		return NL_SKIP;
+
+	dl_list_for_each(drv, &w->drvs, struct wpa_driver_capwap_data,
+			 wiphy_list) {
+		os_memset(&event, 0, sizeof(event));
+		event.rx_mgmt.frame = nla_data(tb[NL80211_ATTR_FRAME]);
+		event.rx_mgmt.frame_len = nla_len(tb[NL80211_ATTR_FRAME]);
+		wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
+	}
+
+	return NL_SKIP;
+}
+
+
+static struct capwap_wiphy_data *
+capwap_get_wiphy_data_ap(struct i802_bss *bss)
+{
+	static DEFINE_DL_LIST(capwap_wiphys);
+	struct capwap_wiphy_data *w;
+	int wiphy_idx, found = 0;
+	struct i802_bss *tmp_bss;
+
+	if (bss->wiphy_data != NULL)
+		return bss->wiphy_data;
+
+	wiphy_idx = capwap_get_wiphy_index(bss);
+
+	dl_list_for_each(w, &capwap_wiphys, struct capwap_wiphy_data, list) {
+		if (w->wiphy_idx == wiphy_idx)
+			goto add;
+	}
+
+	/* alloc new one */
+	w = os_zalloc(sizeof(*w));
+	if (w == NULL)
+		return NULL;
+	w->wiphy_idx = wiphy_idx;
+	dl_list_init(&w->bsss);
+	dl_list_init(&w->drvs);
+
+	w->nl_cb = nl_cb_alloc(NL_CB_DEFAULT);
+	if (!w->nl_cb) {
+		os_free(w);
+		return NULL;
+	}
+	nl_cb_set(w->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, no_seq_check, NULL);
+	nl_cb_set(w->nl_cb, NL_CB_VALID, NL_CB_CUSTOM, process_beacon_event,
+		  w);
+
+	w->nl_beacons = nl_create_handle(bss->drv->global->nl_cb,
+					 "wiphy beacons");
+
+        w->nl_beacons_cache = nl_create_cache(w->nl_beacons);
+
+	if (w->nl_beacons == NULL) {
+		os_free(w);
+		return NULL;
+	}
+
+	if (capwap_register_beacons(bss->drv, w)) {
+                nl_destroy_cache(&w->nl_beacons_cache);
+		nl_destroy_handles(&w->nl_beacons);
+		os_free(w);
+		return NULL;
+	}
+
+	eloop_register_read_sock(nl_socket_get_fd(w->nl_beacons),
+				 capwap_recv_beacons, w, w->nl_beacons);
+
+	dl_list_add(&capwap_wiphys, &w->list);
+
+add:
+	/* drv entry for this bss already there? */
+	dl_list_for_each(tmp_bss, &w->bsss, struct i802_bss, wiphy_list) {
+		if (tmp_bss->drv == bss->drv) {
+			found = 1;
+			break;
+		}
+	}
+	/* if not add it */
+	if (!found)
+		dl_list_add(&w->drvs, &bss->drv->wiphy_list);
+
+	dl_list_add(&w->bsss, &bss->wiphy_list);
+	bss->wiphy_data = w;
+	return w;
+}
+
+
+static void capwap_put_wiphy_data_ap(struct i802_bss *bss)
+{
+	struct capwap_wiphy_data *w = bss->wiphy_data;
+	struct i802_bss *tmp_bss;
+	int found = 0;
+
+	if (w == NULL)
+		return;
+	bss->wiphy_data = NULL;
+	dl_list_del(&bss->wiphy_list);
+
+	/* still any for this drv present? */
+	dl_list_for_each(tmp_bss, &w->bsss, struct i802_bss, wiphy_list) {
+		if (tmp_bss->drv == bss->drv) {
+			found = 1;
+			break;
+		}
+	}
+	/* if not remove it */
+	if (!found)
+		dl_list_del(&bss->drv->wiphy_list);
+
+	if (!dl_list_empty(&w->bsss))
+		return;
+
+	eloop_unregister_read_sock(nl_socket_get_fd(w->nl_beacons));
+
+	nl_cb_put(w->nl_cb);
+        nl_destroy_cache(&w->nl_beacons_cache);
+	nl_destroy_handles(&w->nl_beacons);
+	dl_list_del(&w->list);
+	os_free(w);
+}
+
+
+static int wpa_driver_capwap_get_bssid(void *priv, u8 *bssid)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (!drv->associated)
+		return -1;
+	os_memcpy(bssid, drv->bssid, ETH_ALEN);
+	return 0;
+}
+
+
+static int wpa_driver_capwap_get_ssid(void *priv, u8 *ssid)
+{
+	wpa_printf(MSG_DEBUG, "wpa_driver_capwap_get_ssid");
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (!drv->associated)
+		return -1;
+	os_memcpy(ssid, drv->ssid, drv->ssid_len);
+	return drv->ssid_len;
+}
+
+
+static void wpa_driver_capwap_event_link(struct wpa_driver_capwap_data *drv,
+					  char *buf, size_t len, int del)
+{
+	union wpa_event_data event;
+
+	os_memset(&event, 0, sizeof(event));
+	if (len > sizeof(event.interface_status.ifname))
+		len = sizeof(event.interface_status.ifname) - 1;
+	os_memcpy(event.interface_status.ifname, buf, len);
+	event.interface_status.ievent = del ? EVENT_INTERFACE_REMOVED :
+		EVENT_INTERFACE_ADDED;
+
+	wpa_printf(MSG_DEBUG, "RTM_%sLINK, IFLA_IFNAME: Interface '%s' %s",
+		   del ? "DEL" : "NEW",
+		   event.interface_status.ifname,
+		   del ? "removed" : "added");
+
+	if (os_strcmp(drv->first_bss.ifname, event.interface_status.ifname) == 0) {
+		if (del) {
+			if (drv->if_removed) {
+				wpa_printf(MSG_DEBUG, "capwap: if_removed "
+					   "already set - ignore event");
+				return;
+			}
+			drv->if_removed = 1;
+		} else {
+			if (if_nametoindex(drv->first_bss.ifname) == 0) {
+				wpa_printf(MSG_DEBUG, "capwap: Interface %s "
+					   "does not exist - ignore "
+					   "RTM_NEWLINK",
+					   drv->first_bss.ifname);
+				return;
+			}
+			if (!drv->if_removed) {
+				wpa_printf(MSG_DEBUG, "capwap: if_removed "
+					   "already cleared - ignore event");
+				return;
+			}
+			drv->if_removed = 0;
+		}
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_STATUS, &event);
+}
+
+
+static int wpa_driver_capwap_own_ifname(struct wpa_driver_capwap_data *drv,
+					 u8 *buf, size_t len)
+{
+	int attrlen, rta_len;
+	struct rtattr *attr;
+
+	attrlen = len;
+	attr = (struct rtattr *) buf;
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_IFNAME) {
+			if (os_strcmp(((char *) attr) + rta_len, drv->first_bss.ifname)
+			    == 0)
+				return 1;
+			else
+				break;
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+
+	return 0;
+}
+
+
+static int wpa_driver_capwap_own_ifindex(struct wpa_driver_capwap_data *drv,
+					  int ifindex, u8 *buf, size_t len)
+{
+	if (drv->ifindex == ifindex)
+		return 1;
+
+	if (drv->if_removed && wpa_driver_capwap_own_ifname(drv, buf, len)) {
+		drv->first_bss.ifindex = if_nametoindex(drv->first_bss.ifname);
+		wpa_printf(MSG_DEBUG, "capwap: Update ifindex for a removed "
+			   "interface");
+		wpa_driver_capwap_finish_drv_init(drv);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static struct wpa_driver_capwap_data *
+capwap_find_drv(struct capwap_global *global, int idx, u8 *buf, size_t len)
+{
+	struct wpa_driver_capwap_data *drv;
+	dl_list_for_each(drv, &global->interfaces,
+			 struct wpa_driver_capwap_data, list) {
+		if (wpa_driver_capwap_own_ifindex(drv, idx, buf, len) ||
+		    have_ifidx(drv, idx))
+			return drv;
+	}
+	return NULL;
+}
+
+
+static void wpa_driver_capwap_event_rtm_newlink(void *ctx,
+						 struct ifinfomsg *ifi,
+						 u8 *buf, size_t len)
+{
+	struct capwap_global *global = ctx;
+	struct wpa_driver_capwap_data *drv;
+	int attrlen, rta_len;
+	struct rtattr *attr;
+	u32 brid = 0;
+	char namebuf[IFNAMSIZ];
+
+	drv = capwap_find_drv(global, ifi->ifi_index, buf, len);
+	if (!drv) {
+		wpa_printf(MSG_DEBUG, "capwap: Ignore event for foreign "
+			   "ifindex %d", ifi->ifi_index);
+		return;
+	}
+
+	if (ifi->ifi_family == AF_BRIDGE &&
+	    drv->nlmode != NL80211_IFTYPE_AP)
+		return;
+
+	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
+		   "(%s%s%s%s)",
+		   drv->operstate, ifi->ifi_flags,
+		   (ifi->ifi_flags & IFF_UP) ? "[UP]" : "",
+		   (ifi->ifi_flags & IFF_RUNNING) ? "[RUNNING]" : "",
+		   (ifi->ifi_flags & IFF_LOWER_UP) ? "[LOWER_UP]" : "",
+		   (ifi->ifi_flags & IFF_DORMANT) ? "[DORMANT]" : "");
+
+	if (!drv->if_disabled && !(ifi->ifi_flags & IFF_UP)) {
+		if (if_indextoname(ifi->ifi_index, namebuf) &&
+		    linux_iface_fake_up(drv->global->ioctl_sock,
+				   drv->first_bss.ifname) > 0) {
+			wpa_printf(MSG_DEBUG, "capwap: Ignore interface down "
+				   "event since interface %s is up", namebuf);
+			return;
+		}
+		wpa_printf(MSG_DEBUG, "capwap: Interface down");
+		if (drv->ignore_if_down_event) {
+			wpa_printf(MSG_DEBUG, "capwap: Ignore interface down "
+				   "event generated by mode change");
+			drv->ignore_if_down_event = 0;
+		} else {
+			drv->if_disabled = 1;
+			wpa_supplicant_event(drv->ctx,
+					     EVENT_INTERFACE_DISABLED, NULL);
+		}
+	}
+
+	if (drv->if_disabled && (ifi->ifi_flags & IFF_UP)) {
+		if (if_indextoname(ifi->ifi_index, namebuf) &&
+		    linux_iface_fake_up(drv->global->ioctl_sock,
+				   drv->first_bss.ifname) == 0) {
+			wpa_printf(MSG_DEBUG, "capwap: Ignore interface up "
+				   "event since interface %s is down",
+				   namebuf);
+		} else if (if_nametoindex(drv->first_bss.ifname) == 0) {
+			wpa_printf(MSG_DEBUG, "capwap: Ignore interface up "
+				   "event since interface %s does not exist",
+				   drv->first_bss.ifname);
+		} else if (drv->if_removed) {
+			wpa_printf(MSG_DEBUG, "capwap: Ignore interface up "
+				   "event since interface %s is marked "
+				   "removed", drv->first_bss.ifname);
+		} else {
+			wpa_printf(MSG_DEBUG, "capwap: Interface up");
+			drv->if_disabled = 0;
+			wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_ENABLED,
+					     NULL);
+		}
+	}
+
+	/*
+	 * Some drivers send the association event before the operup event--in
+	 * this case, lifting operstate in wpa_driver_capwap_set_operstate()
+	 * fails. This will hit us when wpa_supplicant does not need to do
+	 * IEEE 802.1X authentication
+	 */
+	if (drv->operstate == 1 &&
+	    (ifi->ifi_flags & (IFF_LOWER_UP | IFF_DORMANT)) == IFF_LOWER_UP &&
+	    !(ifi->ifi_flags & IFF_RUNNING))
+		netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
+				       -1, IF_OPER_UP);
+
+	attrlen = len;
+	attr = (struct rtattr *) buf;
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_IFNAME) {
+			wpa_driver_capwap_event_link(
+				drv,
+				((char *) attr) + rta_len,
+				attr->rta_len - rta_len, 0);
+		} else if (attr->rta_type == IFLA_MASTER)
+			brid = nla_get_u32((struct nlattr *) attr);
+		attr = RTA_NEXT(attr, attrlen);
+	}
+
+	if (ifi->ifi_family == AF_BRIDGE && brid) {
+		/* device has been added to bridge */
+		if_indextoname(brid, namebuf);
+		wpa_printf(MSG_DEBUG, "capwap: Add ifindex %u for bridge %s",
+			   brid, namebuf);
+		add_ifidx(drv, brid);
+	}
+}
+
+
+static void wpa_driver_capwap_event_rtm_dellink(void *ctx,
+						 struct ifinfomsg *ifi,
+						 u8 *buf, size_t len)
+{
+	struct capwap_global *global = ctx;
+	struct wpa_driver_capwap_data *drv;
+	int attrlen, rta_len;
+	struct rtattr *attr;
+	u32 brid = 0;
+
+	drv = capwap_find_drv(global, ifi->ifi_index, buf, len);
+	if (!drv) {
+		wpa_printf(MSG_DEBUG, "capwap: Ignore dellink event for "
+			   "foreign ifindex %d", ifi->ifi_index);
+		return;
+	}
+
+	attrlen = len;
+	attr = (struct rtattr *) buf;
+
+	if (ifi->ifi_family == AF_BRIDGE &&
+	    drv->nlmode != NL80211_IFTYPE_AP)
+		return;
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_IFNAME) {
+			wpa_driver_capwap_event_link(
+				drv,
+				((char *) attr) + rta_len,
+				attr->rta_len - rta_len, 1);
+		} else if (attr->rta_type == IFLA_MASTER)
+			brid = nla_get_u32((struct nlattr *) attr);
+		attr = RTA_NEXT(attr, attrlen);
+	}
+
+	if (ifi->ifi_family == AF_BRIDGE && brid) {
+		/* device has been removed from bridge */
+		char namebuf[IFNAMSIZ];
+		if_indextoname(brid, namebuf);
+		wpa_printf(MSG_DEBUG, "capwap: Remove ifindex %u for bridge "
+			   "%s", brid, namebuf);
+		del_ifidx(drv, brid);
+	}
+}
+
+
+static void mlme_event_auth(struct wpa_driver_capwap_data *drv,
+			    const u8 *frame, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt;
+	union wpa_event_data event;
+
+	wpa_printf(MSG_DEBUG, "capwap: Authenticate event");
+	mgmt = (const struct ieee80211_mgmt *) frame;
+	if (len < 24 + sizeof(mgmt->u.auth)) {
+		wpa_printf(MSG_DEBUG, "capwap: Too short association event "
+			   "frame");
+		return;
+	}
+
+	os_memcpy(drv->auth_bssid, mgmt->sa, ETH_ALEN);
+	os_memset(&event, 0, sizeof(event));
+	os_memcpy(event.auth.peer, mgmt->sa, ETH_ALEN);
+	event.auth.auth_type = le_to_host16(mgmt->u.auth.auth_alg);
+	event.auth.auth_transaction =
+		le_to_host16(mgmt->u.auth.auth_transaction);
+	event.auth.status_code = le_to_host16(mgmt->u.auth.status_code);
+	if (len > 24 + sizeof(mgmt->u.auth)) {
+		event.auth.ies = mgmt->u.auth.variable;
+		event.auth.ies_len = len - 24 - sizeof(mgmt->u.auth);
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_AUTH, &event);
+}
+
+
+static unsigned int capwap_get_assoc_freq(struct wpa_driver_capwap_data *drv)
+{
+	struct nl_msg *msg;
+	int ret;
+	struct capwap_bss_info_arg arg;
+
+	os_memset(&arg, 0, sizeof(arg));
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto nla_put_failure;
+
+	capwap_cmd(drv, msg, NLM_F_DUMP, NL80211_CMD_GET_SCAN);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	arg.drv = drv;
+	ret = send_and_recv_msgs(drv, msg, bss_info_handler, &arg);
+	msg = NULL;
+	if (ret == 0) {
+		wpa_printf(MSG_DEBUG, "capwap: Operating frequency for the "
+			   "associated BSS from scan results: %u MHz",
+			   arg.assoc_freq);
+		return arg.assoc_freq ? arg.assoc_freq : drv->assoc_freq;
+	}
+	wpa_printf(MSG_DEBUG, "capwap: Scan result fetch failed: ret=%d "
+		   "(%s)", ret, strerror(-ret));
+nla_put_failure:
+	nlmsg_free(msg);
+	return drv->assoc_freq;
+}
+
+
+static void mlme_event_assoc(struct wpa_driver_capwap_data *drv,
+			    const u8 *frame, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt;
+	union wpa_event_data event;
+	u16 status;
+
+	wpa_printf(MSG_DEBUG, "capwap: Associate event");
+	mgmt = (const struct ieee80211_mgmt *) frame;
+	if (len < 24 + sizeof(mgmt->u.assoc_resp)) {
+		wpa_printf(MSG_DEBUG, "capwap: Too short association event "
+			   "frame");
+		return;
+	}
+
+	status = le_to_host16(mgmt->u.assoc_resp.status_code);
+	if (status != WLAN_STATUS_SUCCESS) {
+		os_memset(&event, 0, sizeof(event));
+		event.assoc_reject.bssid = mgmt->bssid;
+		if (len > 24 + sizeof(mgmt->u.assoc_resp)) {
+			event.assoc_reject.resp_ies =
+				(u8 *) mgmt->u.assoc_resp.variable;
+			event.assoc_reject.resp_ies_len =
+				len - 24 - sizeof(mgmt->u.assoc_resp);
+		}
+		event.assoc_reject.status_code = status;
+
+		wpa_supplicant_event(drv->ctx, EVENT_ASSOC_REJECT, &event);
+		return;
+	}
+
+	drv->associated = 1;
+	os_memcpy(drv->bssid, mgmt->sa, ETH_ALEN);
+
+	os_memset(&event, 0, sizeof(event));
+	if (len > 24 + sizeof(mgmt->u.assoc_resp)) {
+		event.assoc_info.resp_ies = (u8 *) mgmt->u.assoc_resp.variable;
+		event.assoc_info.resp_ies_len =
+			len - 24 - sizeof(mgmt->u.assoc_resp);
+	}
+
+	event.assoc_info.freq = drv->assoc_freq;
+
+	wpa_supplicant_event(drv->ctx, EVENT_ASSOC, &event);
+}
+
+
+static void mlme_event_connect(struct wpa_driver_capwap_data *drv,
+			       enum nl80211_commands cmd, struct nlattr *status,
+			       struct nlattr *addr, struct nlattr *req_ie,
+			       struct nlattr *resp_ie)
+{
+	union wpa_event_data event;
+
+	if (drv->capa.flags & WPA_DRIVER_FLAGS_SME) {
+		/*
+		 * Avoid reporting two association events that would confuse
+		 * the core code.
+		 */
+		wpa_printf(MSG_DEBUG, "capwap: Ignore connect event (cmd=%d) "
+			   "when using userspace SME", cmd);
+		return;
+	}
+
+	if (cmd == NL80211_CMD_CONNECT)
+		wpa_printf(MSG_DEBUG, "capwap: Connect event");
+	else if (cmd == NL80211_CMD_ROAM)
+		wpa_printf(MSG_DEBUG, "capwap: Roam event");
+
+	os_memset(&event, 0, sizeof(event));
+	if (cmd == NL80211_CMD_CONNECT &&
+	    nla_get_u16(status) != WLAN_STATUS_SUCCESS) {
+		if (addr)
+			event.assoc_reject.bssid = nla_data(addr);
+		if (resp_ie) {
+			event.assoc_reject.resp_ies = nla_data(resp_ie);
+			event.assoc_reject.resp_ies_len = nla_len(resp_ie);
+		}
+		event.assoc_reject.status_code = nla_get_u16(status);
+		wpa_supplicant_event(drv->ctx, EVENT_ASSOC_REJECT, &event);
+		return;
+	}
+
+	drv->associated = 1;
+	if (addr)
+		os_memcpy(drv->bssid, nla_data(addr), ETH_ALEN);
+
+	if (req_ie) {
+		event.assoc_info.req_ies = nla_data(req_ie);
+		event.assoc_info.req_ies_len = nla_len(req_ie);
+	}
+	if (resp_ie) {
+		event.assoc_info.resp_ies = nla_data(resp_ie);
+		event.assoc_info.resp_ies_len = nla_len(resp_ie);
+	}
+
+	event.assoc_info.freq = capwap_get_assoc_freq(drv);
+
+	wpa_supplicant_event(drv->ctx, EVENT_ASSOC, &event);
+}
+
+
+static void mlme_event_disconnect(struct wpa_driver_capwap_data *drv,
+				  struct nlattr *reason, struct nlattr *addr,
+				  struct nlattr *by_ap)
+{
+	union wpa_event_data data;
+	unsigned int locally_generated = by_ap == NULL;
+
+	if (drv->capa.flags & WPA_DRIVER_FLAGS_SME) {
+		/*
+		 * Avoid reporting two disassociation events that could
+		 * confuse the core code.
+		 */
+		wpa_printf(MSG_DEBUG, "capwap: Ignore disconnect "
+			   "event when using userspace SME");
+		return;
+	}
+
+	if (drv->ignore_next_local_disconnect) {
+		drv->ignore_next_local_disconnect = 0;
+		if (locally_generated) {
+			wpa_printf(MSG_DEBUG, "capwap: Ignore disconnect "
+				   "event triggered during reassociation");
+			return;
+		}
+		wpa_printf(MSG_WARNING, "capwap: Was expecting local "
+			   "disconnect but got another disconnect "
+			   "event first");
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Disconnect event");
+	drv->associated = 0;
+	os_memset(&data, 0, sizeof(data));
+	if (reason)
+		data.deauth_info.reason_code = nla_get_u16(reason);
+	data.deauth_info.locally_generated = by_ap == NULL;
+	wpa_supplicant_event(drv->ctx, EVENT_DEAUTH, &data);
+}
+
+
+static void mlme_event_ch_switch(struct wpa_driver_capwap_data *drv,
+				 struct nlattr *freq, struct nlattr *type)
+{
+	union wpa_event_data data;
+	int ht_enabled = 1;
+	int chan_offset = 0;
+
+	wpa_printf(MSG_DEBUG, "capwap: Channel switch event");
+
+	if (!freq || !type)
+		return;
+
+	switch (nla_get_u32(type)) {
+	case NL80211_CHAN_NO_HT:
+		ht_enabled = 0;
+		break;
+	case NL80211_CHAN_HT20:
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		chan_offset = 1;
+		break;
+	case NL80211_CHAN_HT40MINUS:
+		chan_offset = -1;
+		break;
+	}
+
+	data.ch_switch.freq = nla_get_u32(freq);
+	data.ch_switch.ht_enabled = ht_enabled;
+	data.ch_switch.ch_offset = chan_offset;
+
+	wpa_supplicant_event(drv->ctx, EVENT_CH_SWITCH, &data);
+}
+
+
+static void mlme_timeout_event(struct wpa_driver_capwap_data *drv,
+			       enum nl80211_commands cmd, struct nlattr *addr)
+{
+	union wpa_event_data event;
+	enum wpa_event_type ev;
+
+	if (nla_len(addr) != ETH_ALEN)
+		return;
+
+	wpa_printf(MSG_DEBUG, "capwap: MLME event %d; timeout with " MACSTR,
+		   cmd, MAC2STR((u8 *) nla_data(addr)));
+
+	if (cmd == NL80211_CMD_AUTHENTICATE)
+		ev = EVENT_AUTH_TIMED_OUT;
+	else if (cmd == NL80211_CMD_ASSOCIATE)
+		ev = EVENT_ASSOC_TIMED_OUT;
+	else
+		return;
+
+	os_memset(&event, 0, sizeof(event));
+	os_memcpy(event.timeout_event.addr, nla_data(addr), ETH_ALEN);
+	wpa_supplicant_event(drv->ctx, ev, &event);
+}
+
+
+static void mlme_event_mgmt(struct wpa_driver_capwap_data *drv,
+			    struct nlattr *freq, struct nlattr *sig,
+			    const u8 *frame, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt;
+	union wpa_event_data event;
+	u16 fc, stype;
+	int ssi_signal = 0;
+
+	wpa_printf(MSG_DEBUG, "capwap: Frame event");
+	mgmt = (const struct ieee80211_mgmt *) frame;
+	if (len < 24) {
+		wpa_printf(MSG_DEBUG, "capwap: Too short action frame");
+		return;
+	}
+
+	fc = le_to_host16(mgmt->frame_control);
+	stype = WLAN_FC_GET_STYPE(fc);
+
+	if (sig)
+		ssi_signal = (s32) nla_get_u32(sig);
+
+	os_memset(&event, 0, sizeof(event));
+	if (freq) {
+		event.rx_action.freq = nla_get_u32(freq);
+		drv->last_mgmt_freq = event.rx_action.freq;
+	}
+	if (stype == WLAN_FC_STYPE_ACTION) {
+		event.rx_action.da = mgmt->da;
+		event.rx_action.sa = mgmt->sa;
+		event.rx_action.bssid = mgmt->bssid;
+		event.rx_action.category = mgmt->u.action.category;
+		event.rx_action.data = &mgmt->u.action.category + 1;
+		event.rx_action.len = frame + len - event.rx_action.data;
+		wpa_supplicant_event(drv->ctx, EVENT_RX_ACTION, &event);
+	} else {
+		event.rx_mgmt.frame = frame;
+		event.rx_mgmt.frame_len = len;
+		event.rx_mgmt.ssi_signal = ssi_signal;
+		wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
+	}
+}
+
+
+static void mlme_event_mgmt_tx_status(struct wpa_driver_capwap_data *drv,
+				      struct nlattr *cookie, const u8 *frame,
+				      size_t len, struct nlattr *ack)
+{
+	union wpa_event_data event;
+	const struct ieee80211_hdr *hdr;
+	u16 fc;
+
+	wpa_printf(MSG_DEBUG, "capwap: Frame TX status event");
+	if (!is_ap_interface(drv->nlmode)) {
+		u64 cookie_val;
+
+		if (!cookie)
+			return;
+
+		cookie_val = nla_get_u64(cookie);
+		wpa_printf(MSG_DEBUG, "capwap: Action TX status:"
+			   " cookie=0%llx%s (ack=%d)",
+			   (long long unsigned int) cookie_val,
+			   cookie_val == drv->send_action_cookie ?
+			   " (match)" : " (unknown)", ack != NULL);
+		if (cookie_val != drv->send_action_cookie)
+			return;
+	}
+
+	hdr = (const struct ieee80211_hdr *) frame;
+	fc = le_to_host16(hdr->frame_control);
+
+	os_memset(&event, 0, sizeof(event));
+	event.tx_status.type = WLAN_FC_GET_TYPE(fc);
+	event.tx_status.stype = WLAN_FC_GET_STYPE(fc);
+	event.tx_status.dst = hdr->addr1;
+	event.tx_status.data = frame;
+	event.tx_status.data_len = len;
+	event.tx_status.ack = ack != NULL;
+	wpa_supplicant_event(drv->ctx, EVENT_TX_STATUS, &event);
+}
+
+
+static void mlme_event_deauth_disassoc(struct wpa_driver_capwap_data *drv,
+				       enum wpa_event_type type,
+				       const u8 *frame, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt;
+	union wpa_event_data event;
+	const u8 *bssid = NULL;
+	u16 reason_code = 0;
+
+	if (type == EVENT_DEAUTH)
+		wpa_printf(MSG_DEBUG, "capwap: Deauthenticate event");
+	else
+		wpa_printf(MSG_DEBUG, "capwap: Disassociate event");
+
+	mgmt = (const struct ieee80211_mgmt *) frame;
+	if (len >= 24) {
+		bssid = mgmt->bssid;
+
+		if (drv->associated != 0 &&
+		    os_memcmp(bssid, drv->bssid, ETH_ALEN) != 0 &&
+		    os_memcmp(bssid, drv->auth_bssid, ETH_ALEN) != 0) {
+			/*
+			 * We have presumably received this deauth as a
+			 * response to a clear_state_mismatch() outgoing
+			 * deauth.  Don't let it take us offline!
+			 */
+			wpa_printf(MSG_DEBUG, "capwap: Deauth received "
+				   "from Unknown BSSID " MACSTR " -- ignoring",
+				   MAC2STR(bssid));
+			return;
+		}
+	}
+
+	drv->associated = 0;
+	os_memset(&event, 0, sizeof(event));
+
+	/* Note: Same offset for Reason Code in both frame subtypes */
+	if (len >= 24 + sizeof(mgmt->u.deauth))
+		reason_code = le_to_host16(mgmt->u.deauth.reason_code);
+
+	if (type == EVENT_DISASSOC) {
+		event.disassoc_info.locally_generated =
+			!os_memcmp(mgmt->sa, drv->first_bss.addr, ETH_ALEN);
+		event.disassoc_info.addr = bssid;
+		event.disassoc_info.reason_code = reason_code;
+		if (frame + len > mgmt->u.disassoc.variable) {
+			event.disassoc_info.ie = mgmt->u.disassoc.variable;
+			event.disassoc_info.ie_len = frame + len -
+				mgmt->u.disassoc.variable;
+		}
+	} else {
+		event.deauth_info.locally_generated =
+			!os_memcmp(mgmt->sa, drv->first_bss.addr, ETH_ALEN);
+		event.deauth_info.addr = bssid;
+		event.deauth_info.reason_code = reason_code;
+		if (frame + len > mgmt->u.deauth.variable) {
+			event.deauth_info.ie = mgmt->u.deauth.variable;
+			event.deauth_info.ie_len = frame + len -
+				mgmt->u.deauth.variable;
+		}
+	}
+
+	wpa_supplicant_event(drv->ctx, type, &event);
+}
+
+
+static void mlme_event_unprot_disconnect(struct wpa_driver_capwap_data *drv,
+					 enum wpa_event_type type,
+					 const u8 *frame, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt;
+	union wpa_event_data event;
+	u16 reason_code = 0;
+
+	if (type == EVENT_UNPROT_DEAUTH)
+		wpa_printf(MSG_DEBUG, "capwap: Unprot Deauthenticate event");
+	else
+		wpa_printf(MSG_DEBUG, "capwap: Unprot Disassociate event");
+
+	if (len < 24)
+		return;
+
+	mgmt = (const struct ieee80211_mgmt *) frame;
+
+	os_memset(&event, 0, sizeof(event));
+	/* Note: Same offset for Reason Code in both frame subtypes */
+	if (len >= 24 + sizeof(mgmt->u.deauth))
+		reason_code = le_to_host16(mgmt->u.deauth.reason_code);
+
+	if (type == EVENT_UNPROT_DISASSOC) {
+		event.unprot_disassoc.sa = mgmt->sa;
+		event.unprot_disassoc.da = mgmt->da;
+		event.unprot_disassoc.reason_code = reason_code;
+	} else {
+		event.unprot_deauth.sa = mgmt->sa;
+		event.unprot_deauth.da = mgmt->da;
+		event.unprot_deauth.reason_code = reason_code;
+	}
+
+	wpa_supplicant_event(drv->ctx, type, &event);
+}
+
+
+static void mlme_event(struct wpa_driver_capwap_data *drv,
+		       enum nl80211_commands cmd, struct nlattr *frame,
+		       struct nlattr *addr, struct nlattr *timed_out,
+		       struct nlattr *freq, struct nlattr *ack,
+		       struct nlattr *cookie, struct nlattr *sig)
+{
+	if (timed_out && addr) {
+		mlme_timeout_event(drv, cmd, addr);
+		return;
+	}
+
+	if (frame == NULL) {
+		wpa_printf(MSG_DEBUG, "capwap: MLME event %d without frame "
+			   "data", cmd);
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: MLME event %d", cmd);
+	wpa_hexdump(MSG_MSGDUMP, "capwap: MLME event frame",
+		    nla_data(frame), nla_len(frame));
+
+	switch (cmd) {
+	case NL80211_CMD_AUTHENTICATE:
+		mlme_event_auth(drv, nla_data(frame), nla_len(frame));
+		break;
+	case NL80211_CMD_ASSOCIATE:
+		mlme_event_assoc(drv, nla_data(frame), nla_len(frame));
+		break;
+	case NL80211_CMD_DEAUTHENTICATE:
+		mlme_event_deauth_disassoc(drv, EVENT_DEAUTH,
+					   nla_data(frame), nla_len(frame));
+		break;
+	case NL80211_CMD_DISASSOCIATE:
+		mlme_event_deauth_disassoc(drv, EVENT_DISASSOC,
+					   nla_data(frame), nla_len(frame));
+		break;
+	case NL80211_CMD_FRAME:
+		mlme_event_mgmt(drv, freq, sig, nla_data(frame),
+				nla_len(frame));
+		break;
+	case NL80211_CMD_FRAME_TX_STATUS:
+		mlme_event_mgmt_tx_status(drv, cookie, nla_data(frame),
+					  nla_len(frame), ack);
+		break;
+	case NL80211_CMD_UNPROT_DEAUTHENTICATE:
+		mlme_event_unprot_disconnect(drv, EVENT_UNPROT_DEAUTH,
+					     nla_data(frame), nla_len(frame));
+		break;
+	case NL80211_CMD_UNPROT_DISASSOCIATE:
+		mlme_event_unprot_disconnect(drv, EVENT_UNPROT_DISASSOC,
+					     nla_data(frame), nla_len(frame));
+		break;
+	default:
+		break;
+	}
+}
+
+
+static void mlme_event_michael_mic_failure(struct i802_bss *bss,
+					   struct nlattr *tb[])
+{
+	union wpa_event_data data;
+
+	wpa_printf(MSG_DEBUG, "capwap: MLME event Michael MIC failure");
+	os_memset(&data, 0, sizeof(data));
+	if (tb[NL80211_ATTR_MAC]) {
+		wpa_hexdump(MSG_DEBUG, "capwap: Source MAC address",
+			    nla_data(tb[NL80211_ATTR_MAC]),
+			    nla_len(tb[NL80211_ATTR_MAC]));
+		data.michael_mic_failure.src = nla_data(tb[NL80211_ATTR_MAC]);
+	}
+	if (tb[NL80211_ATTR_KEY_SEQ]) {
+		wpa_hexdump(MSG_DEBUG, "capwap: TSC",
+			    nla_data(tb[NL80211_ATTR_KEY_SEQ]),
+			    nla_len(tb[NL80211_ATTR_KEY_SEQ]));
+	}
+	if (tb[NL80211_ATTR_KEY_TYPE]) {
+		enum nl80211_key_type key_type =
+			nla_get_u32(tb[NL80211_ATTR_KEY_TYPE]);
+		wpa_printf(MSG_DEBUG, "capwap: Key Type %d", key_type);
+		if (key_type == NL80211_KEYTYPE_PAIRWISE)
+			data.michael_mic_failure.unicast = 1;
+	} else
+		data.michael_mic_failure.unicast = 1;
+
+	if (tb[NL80211_ATTR_KEY_IDX]) {
+		u8 key_id = nla_get_u8(tb[NL80211_ATTR_KEY_IDX]);
+		wpa_printf(MSG_DEBUG, "capwap: Key Id %d", key_id);
+	}
+
+	wpa_supplicant_event(bss->ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
+}
+
+
+static void mlme_event_join_ibss(struct wpa_driver_capwap_data *drv,
+				 struct nlattr *tb[])
+{
+	if (tb[NL80211_ATTR_MAC] == NULL) {
+		wpa_printf(MSG_DEBUG, "capwap: No address in IBSS joined "
+			   "event");
+		return;
+	}
+	os_memcpy(drv->bssid, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	drv->associated = 1;
+	wpa_printf(MSG_DEBUG, "capwap: IBSS " MACSTR " joined",
+		   MAC2STR(drv->bssid));
+
+	wpa_supplicant_event(drv->ctx, EVENT_ASSOC, NULL);
+}
+
+
+static void mlme_event_remain_on_channel(struct wpa_driver_capwap_data *drv,
+					 int cancel_event, struct nlattr *tb[])
+{
+	unsigned int freq, chan_type, duration;
+	union wpa_event_data data;
+	u64 cookie;
+
+	if (tb[NL80211_ATTR_WIPHY_FREQ])
+		freq = nla_get_u32(tb[NL80211_ATTR_WIPHY_FREQ]);
+	else
+		freq = 0;
+
+	if (tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE])
+		chan_type = nla_get_u32(tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);
+	else
+		chan_type = 0;
+
+	if (tb[NL80211_ATTR_DURATION])
+		duration = nla_get_u32(tb[NL80211_ATTR_DURATION]);
+	else
+		duration = 0;
+
+	if (tb[NL80211_ATTR_COOKIE])
+		cookie = nla_get_u64(tb[NL80211_ATTR_COOKIE]);
+	else
+		cookie = 0;
+
+	wpa_printf(MSG_DEBUG, "capwap: Remain-on-channel event (cancel=%d "
+		   "freq=%u channel_type=%u duration=%u cookie=0x%llx (%s))",
+		   cancel_event, freq, chan_type, duration,
+		   (long long unsigned int) cookie,
+		   cookie == drv->remain_on_chan_cookie ? "match" : "unknown");
+
+	if (cookie != drv->remain_on_chan_cookie)
+		return; /* not for us */
+
+	if (cancel_event)
+		drv->pending_remain_on_chan = 0;
+
+	os_memset(&data, 0, sizeof(data));
+	data.remain_on_channel.freq = freq;
+	data.remain_on_channel.duration = duration;
+	wpa_supplicant_event(drv->ctx, cancel_event ?
+			     EVENT_CANCEL_REMAIN_ON_CHANNEL :
+			     EVENT_REMAIN_ON_CHANNEL, &data);
+}
+
+
+static void send_scan_event(struct wpa_driver_capwap_data *drv, int aborted,
+			    struct nlattr *tb[])
+{
+	union wpa_event_data event;
+	struct nlattr *nl;
+	int rem;
+	struct scan_info *info;
+#define MAX_REPORT_FREQS 50
+	int freqs[MAX_REPORT_FREQS];
+	int num_freqs = 0;
+
+	if (drv->scan_for_auth) {
+		drv->scan_for_auth = 0;
+		wpa_printf(MSG_DEBUG, "capwap: Scan results for missing "
+			   "cfg80211 BSS entry");
+		wpa_driver_capwap_authenticate_retry(drv);
+		return;
+	}
+
+	os_memset(&event, 0, sizeof(event));
+	info = &event.scan_info;
+	info->aborted = aborted;
+
+	if (tb[NL80211_ATTR_SCAN_SSIDS]) {
+		nla_for_each_nested(nl, tb[NL80211_ATTR_SCAN_SSIDS], rem) {
+			struct wpa_driver_scan_ssid *s =
+				&info->ssids[info->num_ssids];
+			s->ssid = nla_data(nl);
+			s->ssid_len = nla_len(nl);
+			info->num_ssids++;
+			if (info->num_ssids == WPAS_MAX_SCAN_SSIDS)
+				break;
+		}
+	}
+	if (tb[NL80211_ATTR_SCAN_FREQUENCIES]) {
+		nla_for_each_nested(nl, tb[NL80211_ATTR_SCAN_FREQUENCIES], rem)
+		{
+			freqs[num_freqs] = nla_get_u32(nl);
+			num_freqs++;
+			if (num_freqs == MAX_REPORT_FREQS - 1)
+				break;
+		}
+		info->freqs = freqs;
+		info->num_freqs = num_freqs;
+	}
+	wpa_supplicant_event(drv->ctx, EVENT_SCAN_RESULTS, &event);
+}
+
+
+static int get_link_signal(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *sinfo[NL80211_STA_INFO_MAX + 1];
+	static struct nla_policy policy[NL80211_STA_INFO_MAX + 1] = {
+		[NL80211_STA_INFO_SIGNAL] = { .type = NLA_U8 },
+	};
+	struct nlattr *rinfo[NL80211_RATE_INFO_MAX + 1];
+	static struct nla_policy rate_policy[NL80211_RATE_INFO_MAX + 1] = {
+		[NL80211_RATE_INFO_BITRATE] = { .type = NLA_U16 },
+		[NL80211_RATE_INFO_MCS] = { .type = NLA_U8 },
+		[NL80211_RATE_INFO_40_MHZ_WIDTH] = { .type = NLA_FLAG },
+		[NL80211_RATE_INFO_SHORT_GI] = { .type = NLA_FLAG },
+	};
+	struct wpa_signal_info *sig_change = arg;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	if (!tb[NL80211_ATTR_STA_INFO] ||
+	    nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
+			     tb[NL80211_ATTR_STA_INFO], policy))
+		return NL_SKIP;
+	if (!sinfo[NL80211_STA_INFO_SIGNAL])
+		return NL_SKIP;
+
+	sig_change->current_signal =
+		(s8) nla_get_u8(sinfo[NL80211_STA_INFO_SIGNAL]);
+
+	if (sinfo[NL80211_STA_INFO_TX_BITRATE]) {
+		if (nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
+				     sinfo[NL80211_STA_INFO_TX_BITRATE],
+				     rate_policy)) {
+			sig_change->current_txrate = 0;
+		} else {
+			if (rinfo[NL80211_RATE_INFO_BITRATE]) {
+				sig_change->current_txrate =
+					nla_get_u16(rinfo[
+					     NL80211_RATE_INFO_BITRATE]) * 100;
+			}
+		}
+	}
+
+	return NL_SKIP;
+}
+
+
+static int capwap_get_link_signal(struct wpa_driver_capwap_data *drv,
+				   struct wpa_signal_info *sig)
+{
+	struct nl_msg *msg;
+
+	sig->current_signal = -9999;
+	sig->current_txrate = 0;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_GET_STATION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, drv->bssid);
+
+	return send_and_recv_msgs(drv, msg, get_link_signal, sig);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int get_link_noise(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *sinfo[NL80211_SURVEY_INFO_MAX + 1];
+	static struct nla_policy survey_policy[NL80211_SURVEY_INFO_MAX + 1] = {
+		[NL80211_SURVEY_INFO_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_SURVEY_INFO_NOISE] = { .type = NLA_U8 },
+	};
+	struct wpa_signal_info *sig_change = arg;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_SURVEY_INFO]) {
+		wpa_printf(MSG_DEBUG, "capwap: survey data missing!");
+		return NL_SKIP;
+	}
+
+	if (nla_parse_nested(sinfo, NL80211_SURVEY_INFO_MAX,
+			     tb[NL80211_ATTR_SURVEY_INFO],
+			     survey_policy)) {
+		wpa_printf(MSG_DEBUG, "capwap: failed to parse nested "
+			   "attributes!");
+		return NL_SKIP;
+	}
+
+	if (!sinfo[NL80211_SURVEY_INFO_FREQUENCY])
+		return NL_SKIP;
+
+	if (nla_get_u32(sinfo[NL80211_SURVEY_INFO_FREQUENCY]) !=
+	    sig_change->frequency)
+		return NL_SKIP;
+
+	if (!sinfo[NL80211_SURVEY_INFO_NOISE])
+		return NL_SKIP;
+
+	sig_change->current_noise =
+		(s8) nla_get_u8(sinfo[NL80211_SURVEY_INFO_NOISE]);
+
+	return NL_SKIP;
+}
+
+
+static int capwap_get_link_noise(struct wpa_driver_capwap_data *drv,
+				  struct wpa_signal_info *sig_change)
+{
+	struct nl_msg *msg;
+
+	sig_change->current_noise = 9999;
+	sig_change->frequency = drv->assoc_freq;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, NLM_F_DUMP, NL80211_CMD_GET_SURVEY);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	return send_and_recv_msgs(drv, msg, get_link_noise, sig_change);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int get_noise_for_scan_results(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *sinfo[NL80211_SURVEY_INFO_MAX + 1];
+	static struct nla_policy survey_policy[NL80211_SURVEY_INFO_MAX + 1] = {
+		[NL80211_SURVEY_INFO_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_SURVEY_INFO_NOISE] = { .type = NLA_U8 },
+	};
+	struct wpa_scan_results *scan_results = arg;
+	struct wpa_scan_res *scan_res;
+	size_t i;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_SURVEY_INFO]) {
+		wpa_printf(MSG_DEBUG, "capwap: Survey data missing");
+		return NL_SKIP;
+	}
+
+	if (nla_parse_nested(sinfo, NL80211_SURVEY_INFO_MAX,
+			     tb[NL80211_ATTR_SURVEY_INFO],
+			     survey_policy)) {
+		wpa_printf(MSG_DEBUG, "capwap: Failed to parse nested "
+			   "attributes");
+		return NL_SKIP;
+	}
+
+	if (!sinfo[NL80211_SURVEY_INFO_NOISE])
+		return NL_SKIP;
+
+	if (!sinfo[NL80211_SURVEY_INFO_FREQUENCY])
+		return NL_SKIP;
+
+	for (i = 0; i < scan_results->num; ++i) {
+		scan_res = scan_results->res[i];
+		if (!scan_res)
+			continue;
+		if ((int) nla_get_u32(sinfo[NL80211_SURVEY_INFO_FREQUENCY]) !=
+		    scan_res->freq)
+			continue;
+		if (!(scan_res->flags & WPA_SCAN_NOISE_INVALID))
+			continue;
+		scan_res->noise = (s8)
+			nla_get_u8(sinfo[NL80211_SURVEY_INFO_NOISE]);
+		scan_res->flags &= ~WPA_SCAN_NOISE_INVALID;
+	}
+
+	return NL_SKIP;
+}
+
+
+static int capwap_get_noise_for_scan_results(
+	struct wpa_driver_capwap_data *drv,
+	struct wpa_scan_results *scan_res)
+{
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, NLM_F_DUMP, NL80211_CMD_GET_SURVEY);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	return send_and_recv_msgs(drv, msg, get_noise_for_scan_results,
+				  scan_res);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static void capwap_cqm_event(struct wpa_driver_capwap_data *drv,
+			      struct nlattr *tb[])
+{
+	static struct nla_policy cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {
+		[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_U32 },
+		[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U8 },
+		[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },
+		[NL80211_ATTR_CQM_PKT_LOSS_EVENT] = { .type = NLA_U32 },
+	};
+	struct nlattr *cqm[NL80211_ATTR_CQM_MAX + 1];
+	enum nl80211_cqm_rssi_threshold_event event;
+	union wpa_event_data ed;
+	struct wpa_signal_info sig;
+	int res;
+
+	if (tb[NL80211_ATTR_CQM] == NULL ||
+	    nla_parse_nested(cqm, NL80211_ATTR_CQM_MAX, tb[NL80211_ATTR_CQM],
+			     cqm_policy)) {
+		wpa_printf(MSG_DEBUG, "capwap: Ignore invalid CQM event");
+		return;
+	}
+
+	os_memset(&ed, 0, sizeof(ed));
+
+	if (cqm[NL80211_ATTR_CQM_PKT_LOSS_EVENT]) {
+		if (!tb[NL80211_ATTR_MAC])
+			return;
+		os_memcpy(ed.low_ack.addr, nla_data(tb[NL80211_ATTR_MAC]),
+			  ETH_ALEN);
+		wpa_supplicant_event(drv->ctx, EVENT_STATION_LOW_ACK, &ed);
+		return;
+	}
+
+	if (cqm[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] == NULL)
+		return;
+	event = nla_get_u32(cqm[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT]);
+
+	if (event == NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH) {
+		wpa_printf(MSG_DEBUG, "capwap: Connection quality monitor "
+			   "event: RSSI high");
+		ed.signal_change.above_threshold = 1;
+	} else if (event == NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW) {
+		wpa_printf(MSG_DEBUG, "capwap: Connection quality monitor "
+			   "event: RSSI low");
+		ed.signal_change.above_threshold = 0;
+	} else
+		return;
+
+	res = capwap_get_link_signal(drv, &sig);
+	if (res == 0) {
+		ed.signal_change.current_signal = sig.current_signal;
+		ed.signal_change.current_txrate = sig.current_txrate;
+		wpa_printf(MSG_DEBUG, "capwap: Signal: %d dBm  txrate: %d",
+			   sig.current_signal, sig.current_txrate);
+	}
+
+	res = capwap_get_link_noise(drv, &sig);
+	if (res == 0) {
+		ed.signal_change.current_noise = sig.current_noise;
+		wpa_printf(MSG_DEBUG, "capwap: Noise: %d dBm",
+			   sig.current_noise);
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_SIGNAL_CHANGE, &ed);
+}
+
+
+static void capwap_new_station_event(struct wpa_driver_capwap_data *drv,
+				      struct nlattr **tb)
+{
+	u8 *addr;
+	union wpa_event_data data;
+
+	if (tb[NL80211_ATTR_MAC] == NULL)
+		return;
+	addr = nla_data(tb[NL80211_ATTR_MAC]);
+	wpa_printf(MSG_DEBUG, "capwap: New station " MACSTR, MAC2STR(addr));
+
+	if (is_ap_interface(drv->nlmode) && drv->device_ap_sme) {
+		u8 *ies = NULL;
+		size_t ies_len = 0;
+		if (tb[NL80211_ATTR_IE]) {
+			ies = nla_data(tb[NL80211_ATTR_IE]);
+			ies_len = nla_len(tb[NL80211_ATTR_IE]);
+		}
+		wpa_hexdump(MSG_DEBUG, "capwap: Assoc Req IEs", ies, ies_len);
+		drv_event_assoc(drv->ctx, addr, ies, ies_len, 0);
+		return;
+	}
+
+	if (drv->nlmode != NL80211_IFTYPE_ADHOC)
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.ibss_rsn_start.peer, addr, ETH_ALEN);
+	wpa_supplicant_event(drv->ctx, EVENT_IBSS_RSN_START, &data);
+}
+
+
+static void capwap_del_station_event(struct wpa_driver_capwap_data *drv,
+				      struct nlattr **tb)
+{
+	u8 *addr;
+	union wpa_event_data data;
+
+	if (tb[NL80211_ATTR_MAC] == NULL)
+		return;
+	addr = nla_data(tb[NL80211_ATTR_MAC]);
+	wpa_printf(MSG_DEBUG, "capwap: Delete station " MACSTR,
+		   MAC2STR(addr));
+
+	if (is_ap_interface(drv->nlmode) && drv->device_ap_sme) {
+		drv_event_disassoc(drv->ctx, addr);
+		return;
+	}
+
+	if (drv->nlmode != NL80211_IFTYPE_ADHOC)
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.ibss_peer_lost.peer, addr, ETH_ALEN);
+	wpa_supplicant_event(drv->ctx, EVENT_IBSS_PEER_LOST, &data);
+}
+
+
+static void capwap_rekey_offload_event(struct wpa_driver_capwap_data *drv,
+					struct nlattr **tb)
+{
+	struct nlattr *rekey_info[NUM_NL80211_REKEY_DATA];
+	static struct nla_policy rekey_policy[NUM_NL80211_REKEY_DATA] = {
+		[NL80211_REKEY_DATA_KEK] = {
+			.minlen = NL80211_KEK_LEN,
+			.maxlen = NL80211_KEK_LEN,
+		},
+		[NL80211_REKEY_DATA_KCK] = {
+			.minlen = NL80211_KCK_LEN,
+			.maxlen = NL80211_KCK_LEN,
+		},
+		[NL80211_REKEY_DATA_REPLAY_CTR] = {
+			.minlen = NL80211_REPLAY_CTR_LEN,
+			.maxlen = NL80211_REPLAY_CTR_LEN,
+		},
+	};
+	union wpa_event_data data;
+
+	if (!tb[NL80211_ATTR_MAC])
+		return;
+	if (!tb[NL80211_ATTR_REKEY_DATA])
+		return;
+	if (nla_parse_nested(rekey_info, MAX_NL80211_REKEY_DATA,
+			     tb[NL80211_ATTR_REKEY_DATA], rekey_policy))
+		return;
+	if (!rekey_info[NL80211_REKEY_DATA_REPLAY_CTR])
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	data.driver_gtk_rekey.bssid = nla_data(tb[NL80211_ATTR_MAC]);
+	wpa_printf(MSG_DEBUG, "capwap: Rekey offload event for BSSID " MACSTR,
+		   MAC2STR(data.driver_gtk_rekey.bssid));
+	data.driver_gtk_rekey.replay_ctr =
+		nla_data(rekey_info[NL80211_REKEY_DATA_REPLAY_CTR]);
+	wpa_hexdump(MSG_DEBUG, "capwap: Rekey offload - Replay Counter",
+		    data.driver_gtk_rekey.replay_ctr, NL80211_REPLAY_CTR_LEN);
+	wpa_supplicant_event(drv->ctx, EVENT_DRIVER_GTK_REKEY, &data);
+}
+
+
+static void capwap_pmksa_candidate_event(struct wpa_driver_capwap_data *drv,
+					  struct nlattr **tb)
+{
+	struct nlattr *cand[NUM_NL80211_PMKSA_CANDIDATE];
+	static struct nla_policy cand_policy[NUM_NL80211_PMKSA_CANDIDATE] = {
+		[NL80211_PMKSA_CANDIDATE_INDEX] = { .type = NLA_U32 },
+		[NL80211_PMKSA_CANDIDATE_BSSID] = {
+			.minlen = ETH_ALEN,
+			.maxlen = ETH_ALEN,
+		},
+		[NL80211_PMKSA_CANDIDATE_PREAUTH] = { .type = NLA_FLAG },
+	};
+	union wpa_event_data data;
+
+	wpa_printf(MSG_DEBUG, "capwap: PMKSA candidate event");
+
+	if (!tb[NL80211_ATTR_PMKSA_CANDIDATE])
+		return;
+	if (nla_parse_nested(cand, MAX_NL80211_PMKSA_CANDIDATE,
+			     tb[NL80211_ATTR_PMKSA_CANDIDATE], cand_policy))
+		return;
+	if (!cand[NL80211_PMKSA_CANDIDATE_INDEX] ||
+	    !cand[NL80211_PMKSA_CANDIDATE_BSSID])
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.pmkid_candidate.bssid,
+		  nla_data(cand[NL80211_PMKSA_CANDIDATE_BSSID]), ETH_ALEN);
+	data.pmkid_candidate.index =
+		nla_get_u32(cand[NL80211_PMKSA_CANDIDATE_INDEX]);
+	data.pmkid_candidate.preauth =
+		cand[NL80211_PMKSA_CANDIDATE_PREAUTH] != NULL;
+	wpa_supplicant_event(drv->ctx, EVENT_PMKID_CANDIDATE, &data);
+}
+
+
+static void capwap_client_probe_event(struct wpa_driver_capwap_data *drv,
+				       struct nlattr **tb)
+{
+	union wpa_event_data data;
+
+	wpa_printf(MSG_DEBUG, "capwap: Probe client event");
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_ACK])
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.client_poll.addr,
+		  nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+
+	wpa_supplicant_event(drv->ctx, EVENT_DRIVER_CLIENT_POLL_OK, &data);
+}
+
+
+static void capwap_tdls_oper_event(struct wpa_driver_capwap_data *drv,
+				    struct nlattr **tb)
+{
+	union wpa_event_data data;
+
+	wpa_printf(MSG_DEBUG, "capwap: TDLS operation event");
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_TDLS_OPERATION])
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.tdls.peer, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	switch (nla_get_u8(tb[NL80211_ATTR_TDLS_OPERATION])) {
+	case NL80211_TDLS_SETUP:
+		wpa_printf(MSG_DEBUG, "capwap: TDLS setup request for peer "
+			   MACSTR, MAC2STR(data.tdls.peer));
+		data.tdls.oper = TDLS_REQUEST_SETUP;
+		break;
+	case NL80211_TDLS_TEARDOWN:
+		wpa_printf(MSG_DEBUG, "capwap: TDLS teardown request for peer "
+			   MACSTR, MAC2STR(data.tdls.peer));
+		data.tdls.oper = TDLS_REQUEST_TEARDOWN;
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "capwap: Unsupported TDLS operatione "
+			   "event");
+		return;
+	}
+	if (tb[NL80211_ATTR_REASON_CODE]) {
+		data.tdls.reason_code =
+			nla_get_u16(tb[NL80211_ATTR_REASON_CODE]);
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_TDLS, &data);
+}
+
+
+static void capwap_connect_failed_event(struct wpa_driver_capwap_data *drv,
+					 struct nlattr **tb)
+{
+	union wpa_event_data data;
+	u32 reason;
+
+	wpa_printf(MSG_DEBUG, "capwap: Connect failed event");
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_CONN_FAILED_REASON])
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.connect_failed_reason.addr,
+		  nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+
+	reason = nla_get_u32(tb[NL80211_ATTR_CONN_FAILED_REASON]);
+	switch (reason) {
+	case NL80211_CONN_FAIL_MAX_CLIENTS:
+		wpa_printf(MSG_DEBUG, "capwap: Max client reached");
+		data.connect_failed_reason.code = MAX_CLIENT_REACHED;
+		break;
+	case NL80211_CONN_FAIL_BLOCKED_CLIENT:
+		wpa_printf(MSG_DEBUG, "capwap: Blocked client " MACSTR
+			   " tried to connect",
+			   MAC2STR(data.connect_failed_reason.addr));
+		data.connect_failed_reason.code = BLOCKED_CLIENT;
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "nl8021l: Unknown connect failed reason "
+			   "%u", reason);
+		return;
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_CONNECT_FAILED_REASON, &data);
+}
+
+
+static void capwap_spurious_frame(struct i802_bss *bss, struct nlattr **tb,
+				   int wds)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	union wpa_event_data event;
+
+	if (!tb[NL80211_ATTR_MAC])
+		return;
+
+	os_memset(&event, 0, sizeof(event));
+	event.rx_from_unknown.bssid = bss->addr;
+	event.rx_from_unknown.addr = nla_data(tb[NL80211_ATTR_MAC]);
+	event.rx_from_unknown.wds = wds;
+
+	wpa_supplicant_event(drv->ctx, EVENT_RX_FROM_UNKNOWN, &event);
+}
+
+
+static void do_process_drv_event(struct i802_bss *bss, int cmd,
+				 struct nlattr **tb)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+
+	if (drv->ap_scan_as_station != NL80211_IFTYPE_UNSPECIFIED &&
+	    (cmd == NL80211_CMD_NEW_SCAN_RESULTS ||
+	     cmd == NL80211_CMD_SCAN_ABORTED)) {
+		wpa_driver_capwap_set_mode(&drv->first_bss,
+					    drv->ap_scan_as_station);
+		drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
+	}
+
+	switch (cmd) {
+	case NL80211_CMD_TRIGGER_SCAN:
+		wpa_printf(MSG_DEBUG, "capwap: Scan trigger");
+		break;
+	case NL80211_CMD_START_SCHED_SCAN:
+		wpa_printf(MSG_DEBUG, "capwap: Sched scan started");
+		break;
+	case NL80211_CMD_SCHED_SCAN_STOPPED:
+		wpa_printf(MSG_DEBUG, "capwap: Sched scan stopped");
+		wpa_supplicant_event(drv->ctx, EVENT_SCHED_SCAN_STOPPED, NULL);
+		break;
+	case NL80211_CMD_NEW_SCAN_RESULTS:
+		wpa_printf(MSG_DEBUG, "capwap: New scan results available");
+		drv->scan_complete_events = 1;
+		eloop_cancel_timeout(wpa_driver_capwap_scan_timeout, drv,
+				     drv->ctx);
+		send_scan_event(drv, 0, tb);
+		break;
+	case NL80211_CMD_SCHED_SCAN_RESULTS:
+		wpa_printf(MSG_DEBUG,
+			   "capwap: New sched scan results available");
+		send_scan_event(drv, 0, tb);
+		break;
+	case NL80211_CMD_SCAN_ABORTED:
+		wpa_printf(MSG_DEBUG, "capwap: Scan aborted");
+		/*
+		 * Need to indicate that scan results are available in order
+		 * not to make wpa_supplicant stop its scanning.
+		 */
+		eloop_cancel_timeout(wpa_driver_capwap_scan_timeout, drv,
+				     drv->ctx);
+		send_scan_event(drv, 1, tb);
+		break;
+	case NL80211_CMD_AUTHENTICATE:
+	case NL80211_CMD_ASSOCIATE:
+	case NL80211_CMD_DEAUTHENTICATE:
+	case NL80211_CMD_DISASSOCIATE:
+	case NL80211_CMD_FRAME_TX_STATUS:
+	case NL80211_CMD_UNPROT_DEAUTHENTICATE:
+	case NL80211_CMD_UNPROT_DISASSOCIATE:
+		mlme_event(drv, cmd, tb[NL80211_ATTR_FRAME],
+			   tb[NL80211_ATTR_MAC], tb[NL80211_ATTR_TIMED_OUT],
+			   tb[NL80211_ATTR_WIPHY_FREQ], tb[NL80211_ATTR_ACK],
+			   tb[NL80211_ATTR_COOKIE],
+			   tb[NL80211_ATTR_RX_SIGNAL_DBM]);
+		break;
+	case NL80211_CMD_CONNECT:
+	case NL80211_CMD_ROAM:
+		mlme_event_connect(drv, cmd,
+				   tb[NL80211_ATTR_STATUS_CODE],
+				   tb[NL80211_ATTR_MAC],
+				   tb[NL80211_ATTR_REQ_IE],
+				   tb[NL80211_ATTR_RESP_IE]);
+		break;
+	case NL80211_CMD_CH_SWITCH_NOTIFY:
+		mlme_event_ch_switch(drv, tb[NL80211_ATTR_WIPHY_FREQ],
+				     tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);
+		break;
+	case NL80211_CMD_DISCONNECT:
+		mlme_event_disconnect(drv, tb[NL80211_ATTR_REASON_CODE],
+				      tb[NL80211_ATTR_MAC],
+				      tb[NL80211_ATTR_DISCONNECTED_BY_AP]);
+		break;
+	case NL80211_CMD_MICHAEL_MIC_FAILURE:
+		mlme_event_michael_mic_failure(bss, tb);
+		break;
+	case NL80211_CMD_JOIN_IBSS:
+		mlme_event_join_ibss(drv, tb);
+		break;
+	case NL80211_CMD_REMAIN_ON_CHANNEL:
+		mlme_event_remain_on_channel(drv, 0, tb);
+		break;
+	case NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL:
+		mlme_event_remain_on_channel(drv, 1, tb);
+		break;
+	case NL80211_CMD_NOTIFY_CQM:
+		capwap_cqm_event(drv, tb);
+		break;
+	case NL80211_CMD_REG_CHANGE:
+		wpa_printf(MSG_DEBUG, "capwap: Regulatory domain change");
+		wpa_supplicant_event(drv->ctx, EVENT_CHANNEL_LIST_CHANGED,
+				     NULL);
+		break;
+	case NL80211_CMD_REG_BEACON_HINT:
+		wpa_printf(MSG_DEBUG, "capwap: Regulatory beacon hint");
+		wpa_supplicant_event(drv->ctx, EVENT_CHANNEL_LIST_CHANGED,
+				     NULL);
+		break;
+	case NL80211_CMD_NEW_STATION:
+		capwap_new_station_event(drv, tb);
+		break;
+	case NL80211_CMD_DEL_STATION:
+		capwap_del_station_event(drv, tb);
+		break;
+	case NL80211_CMD_SET_REKEY_OFFLOAD:
+		capwap_rekey_offload_event(drv, tb);
+		break;
+	case NL80211_CMD_PMKSA_CANDIDATE:
+		capwap_pmksa_candidate_event(drv, tb);
+		break;
+	case NL80211_CMD_PROBE_CLIENT:
+		capwap_client_probe_event(drv, tb);
+		break;
+	case NL80211_CMD_TDLS_OPER:
+		capwap_tdls_oper_event(drv, tb);
+		break;
+	case NL80211_CMD_CONN_FAILED:
+		capwap_connect_failed_event(drv, tb);
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "capwap: Ignored unknown event "
+			   "(cmd=%d)", cmd);
+		break;
+	}
+}
+
+
+static int process_drv_event(struct nl_msg *msg, void *arg)
+{
+	struct wpa_driver_capwap_data *drv = arg;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct i802_bss *bss;
+	int ifidx = -1;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (tb[NL80211_ATTR_IFINDEX])
+		ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
+
+	for (bss = &drv->first_bss; bss; bss = bss->next) {
+		if (ifidx == -1 || ifidx == bss->ifindex) {
+			do_process_drv_event(bss, gnlh->cmd, tb);
+			return NL_SKIP;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Ignored event (cmd=%d) for foreign "
+		   "interface (ifindex %d)", gnlh->cmd, ifidx);
+
+	return NL_SKIP;
+}
+
+
+static int process_global_event(struct nl_msg *msg, void *arg)
+{
+	struct capwap_global *global = arg;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct wpa_driver_capwap_data *drv, *tmp;
+	int ifidx = -1;
+	struct i802_bss *bss;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (tb[NL80211_ATTR_IFINDEX])
+		ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
+
+	dl_list_for_each_safe(drv, tmp, &global->interfaces,
+			      struct wpa_driver_capwap_data, list) {
+		for (bss = &drv->first_bss; bss; bss = bss->next) {
+			if (ifidx == -1 || ifidx == bss->ifindex) {
+				do_process_drv_event(bss, gnlh->cmd, tb);
+				return NL_SKIP;
+			}
+		}
+	}
+
+	return NL_SKIP;
+}
+
+
+static int process_bss_event(struct nl_msg *msg, void *arg)
+{
+	struct i802_bss *bss = arg;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	switch (gnlh->cmd) {
+	case NL80211_CMD_FRAME:
+	case NL80211_CMD_FRAME_TX_STATUS:
+		mlme_event(bss->drv, gnlh->cmd, tb[NL80211_ATTR_FRAME],
+			   tb[NL80211_ATTR_MAC], tb[NL80211_ATTR_TIMED_OUT],
+			   tb[NL80211_ATTR_WIPHY_FREQ], tb[NL80211_ATTR_ACK],
+			   tb[NL80211_ATTR_COOKIE],
+			   tb[NL80211_ATTR_RX_SIGNAL_DBM]);
+		break;
+	case NL80211_CMD_UNEXPECTED_FRAME:
+		capwap_spurious_frame(bss, tb, 0);
+		break;
+	case NL80211_CMD_UNEXPECTED_4ADDR_FRAME:
+		capwap_spurious_frame(bss, tb, 1);
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "capwap: Ignored unknown event "
+			   "(cmd=%d)", gnlh->cmd);
+		break;
+	}
+
+	return NL_SKIP;
+}
+
+
+static void wpa_driver_capwap_event_receive(int sock, void *eloop_ctx,
+					     void *handle)
+{
+ 	wpa_printf(MSG_DEBUG, "wpa_driver_capwap_event_receive");	
+	struct nl_cb *cb = eloop_ctx;
+
+	wpa_printf(MSG_DEBUG, "capwap: Event message available");
+
+	nl_recvmsgs(handle, cb);
+}
+
+
+/**
+ * wpa_driver_capwap_set_country - ask capwap to set the regulatory domain
+ * @priv: driver_capwap private data
+ * @alpha2_arg: country to which to switch to
+ * Returns: 0 on success, -1 on failure
+ *
+ * This asks capwap to set the regulatory domain for given
+ * country ISO / IEC alpha2.
+ */
+static int wpa_driver_capwap_set_country(void *priv, const char *alpha2_arg)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	char alpha2[3];
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	alpha2[0] = alpha2_arg[0];
+	alpha2[1] = alpha2_arg[1];
+	alpha2[2] = '\0';
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_REQ_SET_REG);
+
+	NLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2, alpha2);
+	if (send_and_recv_msgs(drv, msg, NULL, NULL))
+		return -EINVAL;
+	return 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	return -EINVAL;
+}
+
+
+struct wiphy_info_data {
+	struct wpa_driver_capa *capa;
+
+	unsigned int error:1;
+	unsigned int device_ap_sme:1;
+	unsigned int poll_command_supported:1;
+	unsigned int data_tx_status:1;
+	unsigned int monitor_supported:1;
+};
+
+
+static unsigned int probe_resp_offload_support(int supp_protocols)
+{
+	unsigned int prot = 0;
+
+	if (supp_protocols & NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS)
+		prot |= WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS;
+	if (supp_protocols & NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2)
+		prot |= WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS2;
+	if (supp_protocols & NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P)
+		prot |= WPA_DRIVER_PROBE_RESP_OFFLOAD_P2P;
+	if (supp_protocols & NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U)
+		prot |= WPA_DRIVER_PROBE_RESP_OFFLOAD_INTERWORKING;
+
+	return prot;
+}
+
+
+static int wiphy_info_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct wiphy_info_data *info = arg;
+	int p2p_go_supported = 0, p2p_client_supported = 0;
+	int p2p_concurrent = 0, p2p_multichan_concurrent = 0;
+	int auth_supported = 0, connect_supported = 0;
+	struct wpa_driver_capa *capa = info->capa;
+	static struct nla_policy
+	iface_combination_policy[NUM_NL80211_IFACE_COMB] = {
+		[NL80211_IFACE_COMB_LIMITS] = { .type = NLA_NESTED },
+		[NL80211_IFACE_COMB_MAXNUM] = { .type = NLA_U32 },
+		[NL80211_IFACE_COMB_STA_AP_BI_MATCH] = { .type = NLA_FLAG },
+		[NL80211_IFACE_COMB_NUM_CHANNELS] = { .type = NLA_U32 },
+	},
+	iface_limit_policy[NUM_NL80211_IFACE_LIMIT] = {
+		[NL80211_IFACE_LIMIT_TYPES] = { .type = NLA_NESTED },
+		[NL80211_IFACE_LIMIT_MAX] = { .type = NLA_U32 },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (tb[NL80211_ATTR_MAX_NUM_SCAN_SSIDS])
+		capa->max_scan_ssids =
+			nla_get_u8(tb[NL80211_ATTR_MAX_NUM_SCAN_SSIDS]);
+
+	if (tb[NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS])
+		capa->max_sched_scan_ssids =
+			nla_get_u8(tb[NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS]);
+
+	if (tb[NL80211_ATTR_MAX_MATCH_SETS])
+		capa->max_match_sets =
+			nla_get_u8(tb[NL80211_ATTR_MAX_MATCH_SETS]);
+
+	if (tb[NL80211_ATTR_SUPPORTED_IFTYPES]) {
+		struct nlattr *nl_mode;
+		int i;
+		nla_for_each_nested(nl_mode,
+				    tb[NL80211_ATTR_SUPPORTED_IFTYPES], i) {
+			switch (nla_type(nl_mode)) {
+			case NL80211_IFTYPE_AP:
+				capa->flags |= WPA_DRIVER_FLAGS_AP;
+				break;
+			case NL80211_IFTYPE_P2P_GO:
+				p2p_go_supported = 1;
+				break;
+			case NL80211_IFTYPE_P2P_CLIENT:
+				p2p_client_supported = 1;
+				break;
+			case NL80211_IFTYPE_MONITOR:
+				info->monitor_supported = 1;
+				break;
+			}
+		}
+	}
+
+	if (tb[NL80211_ATTR_INTERFACE_COMBINATIONS]) {
+		struct nlattr *nl_combi;
+		int rem_combi;
+
+		nla_for_each_nested(nl_combi,
+				    tb[NL80211_ATTR_INTERFACE_COMBINATIONS],
+				    rem_combi) {
+			struct nlattr *tb_comb[NUM_NL80211_IFACE_COMB];
+			struct nlattr *tb_limit[NUM_NL80211_IFACE_LIMIT];
+			struct nlattr *nl_limit, *nl_mode;
+			int err, rem_limit, rem_mode;
+			int combination_has_p2p = 0, combination_has_mgd = 0;
+
+			err = nla_parse_nested(tb_comb, MAX_NL80211_IFACE_COMB,
+					       nl_combi,
+					       iface_combination_policy);
+			if (err || !tb_comb[NL80211_IFACE_COMB_LIMITS] ||
+			    !tb_comb[NL80211_IFACE_COMB_MAXNUM] ||
+			    !tb_comb[NL80211_IFACE_COMB_NUM_CHANNELS])
+				goto broken_combination;
+
+			nla_for_each_nested(nl_limit,
+					    tb_comb[NL80211_IFACE_COMB_LIMITS],
+					    rem_limit) {
+				err = nla_parse_nested(tb_limit,
+						       MAX_NL80211_IFACE_LIMIT,
+						       nl_limit,
+						       iface_limit_policy);
+				if (err ||
+				    !tb_limit[NL80211_IFACE_LIMIT_TYPES])
+					goto broken_combination;
+
+				nla_for_each_nested(
+					nl_mode,
+					tb_limit[NL80211_IFACE_LIMIT_TYPES],
+					rem_mode) {
+					int ift = nla_type(nl_mode);
+					if (ift == NL80211_IFTYPE_P2P_GO ||
+					    ift == NL80211_IFTYPE_P2P_CLIENT)
+						combination_has_p2p = 1;
+					if (ift == NL80211_IFTYPE_STATION)
+						combination_has_mgd = 1;
+				}
+				if (combination_has_p2p && combination_has_mgd)
+					break;
+			}
+
+			if (combination_has_p2p && combination_has_mgd) {
+				p2p_concurrent = 1;
+				if (nla_get_u32(tb_comb[NL80211_IFACE_COMB_NUM_CHANNELS]) > 1)
+					p2p_multichan_concurrent = 1;
+				break;
+			}
+
+broken_combination:
+			;
+		}
+	}
+
+	if (tb[NL80211_ATTR_SUPPORTED_COMMANDS]) {
+		struct nlattr *nl_cmd;
+		int i;
+
+		nla_for_each_nested(nl_cmd,
+				    tb[NL80211_ATTR_SUPPORTED_COMMANDS], i) {
+			switch (nla_get_u32(nl_cmd)) {
+			case NL80211_CMD_AUTHENTICATE:
+				auth_supported = 1;
+				break;
+			case NL80211_CMD_CONNECT:
+				connect_supported = 1;
+				break;
+			case NL80211_CMD_START_SCHED_SCAN:
+				capa->sched_scan_supported = 1;
+				break;
+			case NL80211_CMD_PROBE_CLIENT:
+				info->poll_command_supported = 1;
+				break;
+			}
+		}
+	}
+
+	if (tb[NL80211_ATTR_OFFCHANNEL_TX_OK]) {
+		wpa_printf(MSG_DEBUG, "capwap: Using driver-based "
+			   "off-channel TX");
+		capa->flags |= WPA_DRIVER_FLAGS_OFFCHANNEL_TX;
+	}
+
+	if (tb[NL80211_ATTR_ROAM_SUPPORT]) {
+		wpa_printf(MSG_DEBUG, "capwap: Using driver-based roaming");
+		capa->flags |= WPA_DRIVER_FLAGS_BSS_SELECTION;
+	}
+
+	/* default to 5000 since early versions of mac80211 don't set it */
+	capa->max_remain_on_chan = 5000;
+
+	if (tb[NL80211_ATTR_SUPPORT_AP_UAPSD])
+		capa->flags |= WPA_DRIVER_FLAGS_AP_UAPSD;
+
+	if (tb[NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION])
+		capa->max_remain_on_chan =
+			nla_get_u32(tb[NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION]);
+
+	if (auth_supported)
+		capa->flags |= WPA_DRIVER_FLAGS_SME;
+	else if (!connect_supported) {
+		wpa_printf(MSG_INFO, "capwap: Driver does not support "
+			   "authentication/association or connect commands");
+		info->error = 1;
+	}
+
+	if (p2p_go_supported && p2p_client_supported)
+		capa->flags |= WPA_DRIVER_FLAGS_P2P_CAPABLE;
+	if (p2p_concurrent) {
+		wpa_printf(MSG_DEBUG, "capwap: Use separate P2P group "
+			   "interface (driver advertised support)");
+		capa->flags |= WPA_DRIVER_FLAGS_P2P_CONCURRENT;
+		capa->flags |= WPA_DRIVER_FLAGS_P2P_MGMT_AND_NON_P2P;
+
+		if (p2p_multichan_concurrent) {
+			wpa_printf(MSG_DEBUG, "capwap: Enable multi-channel "
+				   "concurrent (driver advertised support)");
+			capa->flags |=
+				WPA_DRIVER_FLAGS_MULTI_CHANNEL_CONCURRENT;
+		}
+	}
+
+	if (tb[NL80211_ATTR_TDLS_SUPPORT]) {
+		wpa_printf(MSG_DEBUG, "capwap: TDLS supported");
+		capa->flags |= WPA_DRIVER_FLAGS_TDLS_SUPPORT;
+
+		if (tb[NL80211_ATTR_TDLS_EXTERNAL_SETUP]) {
+			wpa_printf(MSG_DEBUG, "capwap: TDLS external setup");
+			capa->flags |=
+				WPA_DRIVER_FLAGS_TDLS_EXTERNAL_SETUP;
+		}
+	}
+
+	if (tb[NL80211_ATTR_DEVICE_AP_SME])
+		info->device_ap_sme = 1;
+
+	if (tb[NL80211_ATTR_FEATURE_FLAGS]) {
+		u32 flags = nla_get_u32(tb[NL80211_ATTR_FEATURE_FLAGS]);
+
+		if (flags & NL80211_FEATURE_SK_TX_STATUS)
+			info->data_tx_status = 1;
+
+		if (flags & NL80211_FEATURE_INACTIVITY_TIMER)
+			capa->flags |= WPA_DRIVER_FLAGS_INACTIVITY_TIMER;
+
+		if (flags & NL80211_FEATURE_SAE)
+			capa->flags |= WPA_DRIVER_FLAGS_SAE;
+
+		if (flags & NL80211_FEATURE_NEED_OBSS_SCAN)
+			capa->flags |= WPA_DRIVER_FLAGS_OBSS_SCAN;
+	}
+
+	if (tb[NL80211_ATTR_PROBE_RESP_OFFLOAD]) {
+		int protocols =
+			nla_get_u32(tb[NL80211_ATTR_PROBE_RESP_OFFLOAD]);
+		wpa_printf(MSG_DEBUG, "capwap: Supports Probe Response "
+			   "offload in AP mode");
+		capa->flags |= WPA_DRIVER_FLAGS_PROBE_RESP_OFFLOAD;
+		capa->probe_resp_offloads =
+			probe_resp_offload_support(protocols);
+	}
+
+	return NL_SKIP;
+}
+
+
+static int wpa_driver_capwap_get_info(struct wpa_driver_capwap_data *drv,
+				       struct wiphy_info_data *info)
+{
+	return 0;
+}
+
+
+static int wpa_driver_capwap_capa(struct wpa_driver_capwap_data *drv)
+{
+        wpa_printf(MSG_DEBUG, "                                                 4.wpa_driver_capwap_capa");
+ 	struct wiphy_info_data info;
+	if (wpa_driver_capwap_get_info(drv, &info))
+		return -1;
+
+	drv->has_capability = 1;
+	/* For now, assume TKIP, CCMP, WPA, WPA2 are supported */
+	drv->capa.key_mgmt = WPA_DRIVER_CAPA_KEY_MGMT_WPA |
+		WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK |
+		WPA_DRIVER_CAPA_KEY_MGMT_WPA2 |
+		WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK;
+	drv->capa.enc = WPA_DRIVER_CAPA_ENC_WEP40 |
+		WPA_DRIVER_CAPA_ENC_WEP104 |
+		WPA_DRIVER_CAPA_ENC_TKIP |
+		WPA_DRIVER_CAPA_ENC_CCMP;
+	drv->capa.auth = WPA_DRIVER_AUTH_OPEN |
+		WPA_DRIVER_AUTH_SHARED |
+		WPA_DRIVER_AUTH_LEAP;
+
+	drv->capa.flags |= WPA_DRIVER_FLAGS_SANE_ERROR_CODES;
+	drv->capa.flags |= WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC_DONE;
+	drv->capa.flags |= WPA_DRIVER_FLAGS_EAPOL_TX_STATUS;
+
+
+	if (!info.device_ap_sme) {
+		drv->capa.flags |= WPA_DRIVER_FLAGS_DEAUTH_TX_STATUS;
+
+		/*
+		 * No AP SME is currently assumed to also indicate no AP MLME
+		 * in the driver/firmware.
+		 */
+		drv->capa.flags |= WPA_DRIVER_FLAGS_AP_MLME;
+	}
+
+	drv->device_ap_sme = info.device_ap_sme;
+	drv->poll_command_supported = info.poll_command_supported;
+	drv->data_tx_status = info.data_tx_status;
+
+	/*
+	 * If poll command and tx status are supported, mac80211 is new enough
+	 * to have everything we need to not need monitor interfaces.
+	 */
+	drv->use_monitor = !info.poll_command_supported || !info.data_tx_status;
+
+	if (drv->device_ap_sme && drv->use_monitor) {
+		/*
+		 * Non-mac80211 drivers may not support monitor interface.
+		 * Make sure we do not get stuck with incorrect capability here
+		 * by explicitly testing this.
+		 */
+		if (!info.monitor_supported) {
+			wpa_printf(MSG_DEBUG, "capwap: Disable use_monitor "
+				   "with device_ap_sme since no monitor mode "
+				   "support detected");
+			drv->use_monitor = 0;
+		}
+	}
+
+	/*
+	 * If we aren't going to use monitor interfaces, but the
+	 * driver doesn't support data TX status, we won't get TX
+	 * status for EAPOL frames.
+	 */
+	if (!drv->use_monitor && !info.data_tx_status)
+		drv->capa.flags &= ~WPA_DRIVER_FLAGS_EAPOL_TX_STATUS;
+
+	return 0;
+}
+
+
+#ifdef ANDROID
+static int android_genl_ctrl_resolve(struct nl_handle *handle,
+				     const char *name)
+{
+	/*
+	 * Android ICS has very minimal genl_ctrl_resolve() implementation, so
+	 * need to work around that.
+	 */
+	struct nl_cache *cache = NULL;
+	struct genl_family *capwap = NULL;
+	int id = -1;
+
+	if (genl_ctrl_alloc_cache(handle, &cache) < 0) {
+		wpa_printf(MSG_ERROR, "capwap: Failed to allocate generic "
+			   "netlink cache");
+		goto fail;
+	}
+
+	capwap = genl_ctrl_search_by_name(cache, name);
+	if (capwap == NULL)
+		goto fail;
+
+	id = genl_family_get_id(capwap);
+
+fail:
+	if (capwap)
+		genl_family_put(capwap);
+	if (cache)
+		nl_cache_free(cache);
+
+	return id;
+}
+#define genl_ctrl_resolve android_genl_ctrl_resolve
+#endif /* ANDROID */
+
+
+static int wpa_driver_capwap_init_nl_global(struct capwap_global *global)
+{
+        wpa_printf(MSG_DEBUG, "                                 2.wpa_driver_capwap_init_nl_global\n");
+	int ret;
+	global->nl_cb = nl_cb_alloc(NL_CB_DEFAULT);
+	if (global->nl_cb == NULL) {
+		wpa_printf(MSG_ERROR, "capwap: Failed to allocate netlink "
+			   "callbacks");
+		return -1;
+	}
+
+	global->nl = nl_create_handle(global->nl_cb, "nl");
+	global->nl_cache = nl_create_cache(global->nl);
+	if (global->nl == NULL)
+		goto err;
+
+	global->capwap = genl_ctrl_search_by_name(global->nl_cache,  "nl80211");
+	if (global->capwap == NULL) {
+		wpa_printf(MSG_ERROR, "capwap: 'capwap' generic netlink not "
+			   "found");
+		goto err;
+	}
+
+	global->nl_event = nl_create_handle(global->nl_cb, "event");
+        global->nl_event_cache = nl_create_cache(global->nl_event); 
+	if (global->nl_event == NULL)
+		goto err;
+
+	ret = nl_get_multicast_id(global, "nl80211", "scan");
+	if (ret >= 0)
+		ret = nl_socket_add_membership(global->nl_event, ret);
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "capwap: Could not add multicast "
+			   "membership for scan events: %d (%s)",
+			   ret, strerror(-ret));
+		goto err;
+	}
+
+	ret = nl_get_multicast_id(global, "nl80211", "mlme");
+	if (ret >= 0)
+		ret = nl_socket_add_membership(global->nl_event, ret);
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "capwap: Could not add multicast "
+			   "membership for mlme events: %d (%s)",
+			   ret, strerror(-ret));
+		goto err;
+	}
+
+	ret = nl_get_multicast_id(global, "nl80211", "regulatory");
+	if (ret >= 0)
+		ret = nl_socket_add_membership(global->nl_event, ret);
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "capwap: Could not add multicast "
+			   "membership for regulatory events: %d (%s)",
+			   ret, strerror(-ret));
+		/* Continue without regulatory events */
+	}
+
+	nl_cb_set(global->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM,
+		  no_seq_check, NULL);
+	nl_cb_set(global->nl_cb, NL_CB_VALID, NL_CB_CUSTOM,
+		  process_global_event, global);
+
+	eloop_register_read_sock(nl_socket_get_fd(global->nl_event),
+				 wpa_driver_capwap_event_receive,
+				 global->nl_cb, global->nl_event);
+
+	return 0;
+
+err:
+        nl_destroy_cache(&global->nl_event_cache);
+        nl_destroy_cache(&global->nl_cache);
+	nl_destroy_handles(&global->nl_event);
+	nl_destroy_handles(&global->nl);
+	nl_cb_put(global->nl_cb);
+	global->nl_cb = NULL;
+	return -1;
+}
+
+
+static int wpa_driver_capwap_init_nl(struct wpa_driver_capwap_data *drv)
+{
+	return 0;
+}
+
+#ifdef CONFIG_RFKILL
+static void wpa_driver_capwap_rfkill_blocked(void *ctx)
+{
+	wpa_printf(MSG_DEBUG, "capwap: RFKILL blocked");
+	/*
+	 * This may be for any interface; use ifdown event to disable
+	 * interface.
+	 */
+}
+
+
+static void wpa_driver_capwap_rfkill_unblocked(void *ctx)
+{
+	struct wpa_driver_capwap_data *drv = ctx;
+	wpa_printf(MSG_DEBUG, "capwap: RFKILL unblocked");
+	if (linux_set_fake_iface_flags(drv->global->ioctl_sock,
+				  drv->first_bss.ifname, 1)) {
+		wpa_printf(MSG_DEBUG, "capwap: Could not set interface UP "
+			   "after rfkill unblock");
+		return;
+	}
+	/* rtnetlink ifup handler will report interface as enabled */
+}
+#endif /* CONFIG_RFKILL */
+
+
+static void capwap_get_phy_name(struct wpa_driver_capwap_data *drv)
+{
+	return;
+}
+
+static void wpa_driver_capwap_handle_eapol_tx_status(int sock,
+						      void *eloop_ctx,
+						      void *handle)
+{
+	struct wpa_driver_capwap_data *drv = eloop_ctx;
+	u8 data[2048];
+	struct msghdr msg;
+	struct iovec entry;
+	u8 control[512];
+	struct cmsghdr *cmsg;
+	int res, found_ee = 0, found_wifi = 0, acked = 0;
+	union wpa_event_data event;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &entry;
+	msg.msg_iovlen = 1;
+	entry.iov_base = data;
+	entry.iov_len = sizeof(data);
+	msg.msg_control = &control;
+	msg.msg_controllen = sizeof(control);
+
+	res = recvmsg(sock, &msg, MSG_ERRQUEUE);
+	/* if error or not fitting 802.3 header, return */
+	if (res < 14)
+		return;
+
+	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg))
+	{
+		if (cmsg->cmsg_level == SOL_SOCKET &&
+		    cmsg->cmsg_type == SCM_WIFI_STATUS) {
+			int *ack;
+
+			found_wifi = 1;
+			ack = (void *)CMSG_DATA(cmsg);
+			acked = *ack;
+		}
+
+		if (cmsg->cmsg_level == SOL_PACKET &&
+		    cmsg->cmsg_type == PACKET_TX_TIMESTAMP) {
+			struct sock_extended_err *err =
+				(struct sock_extended_err *)CMSG_DATA(cmsg);
+
+			if (err->ee_origin == SO_EE_ORIGIN_TXSTATUS)
+				found_ee = 1;
+		}
+	}
+
+	if (!found_ee || !found_wifi)
+		return;
+
+	memset(&event, 0, sizeof(event));
+	event.eapol_tx_status.dst = data;
+	event.eapol_tx_status.data = data + 14;
+	event.eapol_tx_status.data_len = res - 14;
+	event.eapol_tx_status.ack = acked;
+	wpa_supplicant_event(drv->ctx, EVENT_EAPOL_TX_STATUS, &event);
+}
+
+
+static int capwap_init_bss(struct i802_bss *bss)
+{
+	bss->nl_cb = nl_cb_alloc(NL_CB_DEFAULT);
+	if (!bss->nl_cb)
+		return -1;
+
+	nl_cb_set(bss->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM,
+		  no_seq_check, NULL);
+	nl_cb_set(bss->nl_cb, NL_CB_VALID, NL_CB_CUSTOM,
+		  process_bss_event, bss);
+
+	return 0;
+}
+
+
+static void capwap_destroy_bss(struct i802_bss *bss)
+{
+	nl_cb_put(bss->nl_cb);
+	bss->nl_cb = NULL;
+}
+
+
+/**
+ * wpa_driver_capwap_init - Initialize capwap driver interface
+ * @ctx: context to be used when calling wpa_supplicant functions,
+ * e.g., wpa_supplicant_event()
+ * @ifname: interface name, e.g., wlan0
+ * @global_priv: private driver global data from global_init()
+ * Returns: Pointer to private data, %NULL on failure
+ */
+static void * wpa_driver_capwap_init(void *ctx, const char *ifname,
+				      void *global_priv)
+{
+	wpa_printf(MSG_DEBUG, "                                 1.wpa_driver_capwap_init\n");
+	struct wpa_driver_capwap_data *drv;
+#ifdef CONFIG_RFKILL
+	struct rfkill_config *rcfg;
+#endif
+	struct i802_bss *bss;
+
+	if (global_priv == NULL)
+		return NULL;
+	drv = os_zalloc(sizeof(*drv));
+	if (drv == NULL)
+		return NULL;
+	drv->global = global_priv;
+	drv->ctx = ctx;
+	bss = &drv->first_bss;
+	bss->drv = drv;
+	bss->ctx = ctx;
+
+	os_strlcpy(bss->ifname, ifname, sizeof(bss->ifname));
+	drv->monitor_ifidx = -1;
+	drv->monitor_sock = -1;
+	drv->eapol_tx_sock = -1;
+	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
+	drv->nlmode = NL80211_IFTYPE_STATION;
+
+#ifdef HOSTAPD
+	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
+	drv->if_indices = drv->default_if_indices;
+#endif
+
+	if (wpa_driver_capwap_init_nl(drv)) {
+		os_free(drv);
+		return NULL;
+	}
+
+	if (capwap_init_bss(bss))
+		goto failed;
+
+	capwap_get_phy_name(drv);
+
+#ifdef CONFIG_RFKILL
+	rcfg = os_zalloc(sizeof(*rcfg));
+	if (rcfg == NULL)
+		goto failed;
+	rcfg->ctx = drv;
+	os_strlcpy(rcfg->ifname, ifname, sizeof(rcfg->ifname));
+	rcfg->blocked_cb = wpa_driver_capwap_rfkill_blocked;
+	rcfg->unblocked_cb = wpa_driver_capwap_rfkill_unblocked;
+	drv->rfkill = rfkill_init(rcfg);
+	if (drv->rfkill == NULL) {
+		wpa_printf(MSG_DEBUG, "capwap: RFKILL status not available");
+		os_free(rcfg);
+	}
+#endif /* CONFIG_RFKILL */
+
+	if (wpa_driver_capwap_finish_drv_init(drv))
+		goto failed;
+
+	drv->eapol_tx_sock = socket(PF_PACKET, SOCK_DGRAM, 0);
+	if (drv->eapol_tx_sock < 0)
+		goto failed;
+
+	if (drv->data_tx_status) {
+		int enabled = 1;
+
+		if (setsockopt(drv->eapol_tx_sock, SOL_SOCKET, SO_WIFI_STATUS,
+			       &enabled, sizeof(enabled)) < 0) {
+			wpa_printf(MSG_DEBUG,
+				"capwap: wifi status sockopt failed\n");
+			drv->data_tx_status = 0;
+			if (!drv->use_monitor)
+				drv->capa.flags &=
+					~WPA_DRIVER_FLAGS_EAPOL_TX_STATUS;
+		} else {
+			eloop_register_read_sock(drv->eapol_tx_sock,
+				wpa_driver_capwap_handle_eapol_tx_status,
+				drv, NULL);
+		}
+	}
+
+	if (drv->global) {
+		dl_list_add(&drv->global->interfaces, &drv->list);
+		drv->in_interface_list = 1;
+	}
+
+	return bss;
+
+failed:
+	wpa_driver_capwap_deinit(bss);
+	return NULL;
+}
+
+
+static int capwap_register_frame(struct i802_bss *bss,
+				  struct nl_handle *nl_handle,
+				  u16 type, const u8 *match, size_t match_len)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret = -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: Register frame type=0x%x nl_handle=%p",
+		   type, nl_handle);
+	wpa_hexdump(MSG_DEBUG, "capwap: Register frame match",
+		    match, match_len);
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_REGISTER_ACTION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+	NLA_PUT_U16(msg, NL80211_ATTR_FRAME_TYPE, type);
+	NLA_PUT(msg, NL80211_ATTR_FRAME_MATCH, match_len, match);
+
+	ret = send_and_recv(drv->global, nl_handle, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Register frame command "
+			   "failed (type=%u): ret=%d (%s)",
+			   type, ret, strerror(-ret));
+		wpa_hexdump(MSG_DEBUG, "capwap: Register frame match",
+			    match, match_len);
+		goto nla_put_failure;
+	}
+	ret = 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int capwap_alloc_mgmt_handle(struct i802_bss *bss)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+
+	if (bss->nl_mgmt) {
+		wpa_printf(MSG_DEBUG, "capwap: Mgmt reporting "
+			   "already on! (nl_mgmt=%p)", bss->nl_mgmt);
+		return -1;
+	}
+
+	bss->nl_mgmt = nl_create_handle(drv->nl_cb, "mgmt");
+	bss->nl_mgmt_cache = nl_create_cache(bss->nl_mgmt);
+	if (bss->nl_mgmt == NULL)
+		return -1;
+
+	eloop_register_read_sock(nl_socket_get_fd(bss->nl_mgmt),
+				 wpa_driver_capwap_event_receive, bss->nl_cb,
+				 bss->nl_mgmt);
+
+	return 0;
+}
+
+
+static int capwap_register_action_frame(struct i802_bss *bss,
+					 const u8 *match, size_t match_len)
+{
+	u16 type = (WLAN_FC_TYPE_MGMT << 2) | (WLAN_FC_STYPE_ACTION << 4);
+	return capwap_register_frame(bss, bss->nl_mgmt,
+				      type, match, match_len);
+}
+
+
+static int capwap_mgmt_subscribe_non_ap(struct i802_bss *bss)
+{
+	return 0;
+}
+
+
+static int capwap_register_spurious_class3(struct i802_bss *bss)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret = -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_UNEXPECTED_FRAME);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+
+	ret = send_and_recv(drv->global, bss->nl_mgmt, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Register spurious class3 "
+			   "failed: ret=%d (%s)",
+			   ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+	ret = 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int capwap_mgmt_subscribe_ap(struct i802_bss *bss)
+{
+	static const int stypes[] = {
+		WLAN_FC_STYPE_AUTH,
+		WLAN_FC_STYPE_ASSOC_REQ,
+		WLAN_FC_STYPE_REASSOC_REQ,
+		WLAN_FC_STYPE_DISASSOC,
+		WLAN_FC_STYPE_DEAUTH,
+		WLAN_FC_STYPE_ACTION,
+		WLAN_FC_STYPE_PROBE_REQ,
+/* Beacon doesn't work as mac80211 doesn't currently allow
+ * it, but it wouldn't really be the right thing anyway as
+ * it isn't per interface ... maybe just dump the scan
+ * results periodically for OLBC?
+ */
+//		WLAN_FC_STYPE_BEACON,
+	};
+	unsigned int i;
+
+	if (capwap_alloc_mgmt_handle(bss))
+		return -1;
+	wpa_printf(MSG_DEBUG, "capwap: Subscribe to mgmt frames with AP "
+		   "handle %p", bss->nl_mgmt);
+
+	for (i = 0; i < sizeof(stypes) / sizeof(stypes[0]); i++) {
+		if (capwap_register_frame(bss, bss->nl_mgmt,
+					   (WLAN_FC_TYPE_MGMT << 2) |
+					   (stypes[i] << 4),
+					   NULL, 0) < 0) {
+			goto out_err;
+		}
+	}
+
+	if (capwap_register_spurious_class3(bss))
+		goto out_err;
+
+	if (capwap_get_wiphy_data_ap(bss) == NULL)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	eloop_unregister_read_sock(nl_socket_get_fd(bss->nl_mgmt));
+	nl_destroy_cache(&bss->nl_mgmt_cache);
+	nl_destroy_handles(&bss->nl_mgmt);
+	return -1;
+}
+
+
+static int capwap_mgmt_subscribe_ap_dev_sme(struct i802_bss *bss)
+{
+	if (capwap_alloc_mgmt_handle(bss))
+		return -1;
+	wpa_printf(MSG_DEBUG, "capwap: Subscribe to mgmt frames with AP "
+		   "handle %p (device SME)", bss->nl_mgmt);
+
+	if (capwap_register_frame(bss, bss->nl_mgmt,
+				   (WLAN_FC_TYPE_MGMT << 2) |
+				   (WLAN_FC_STYPE_ACTION << 4),
+				   NULL, 0) < 0)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	eloop_unregister_read_sock(nl_socket_get_fd(bss->nl_mgmt));
+        nl_destroy_cache(&bss->nl_mgmt_cache);
+	nl_destroy_handles(&bss->nl_mgmt);
+	return -1;
+}
+
+
+static void capwap_mgmt_unsubscribe(struct i802_bss *bss, const char *reason)
+{
+	if (bss->nl_mgmt == NULL)
+		return;
+	wpa_printf(MSG_DEBUG, "capwap: Unsubscribe mgmt frames handle %p "
+		   "(%s)", bss->nl_mgmt, reason);
+	eloop_unregister_read_sock(nl_socket_get_fd(bss->nl_mgmt));
+        nl_destroy_cache(&bss->nl_mgmt_cache);
+	nl_destroy_handles(&bss->nl_mgmt);
+
+	capwap_put_wiphy_data_ap(bss);
+}
+
+
+#ifdef CONFIG_RFKILL
+static void wpa_driver_capwap_send_rfkill(void *eloop_ctx, void *timeout_ctx)
+{
+	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
+}
+#endif /* CONFIG_RFKILL */
+
+static int
+wpa_driver_capwap_finish_drv_init_sta(struct wpa_driver_capwap_data *drv,
+				       int *send_rfkill_event)
+{
+	struct i802_bss *bss = &drv->first_bss;
+
+	/*
+	 * Make sure the interface starts up in station mode unless this is a
+	 * dynamically added interface (e.g., P2P) that was already configured
+	 * with proper iftype.
+	 */
+	if (drv->ifindex != drv->global->if_add_ifindex &&
+	    wpa_driver_capwap_set_mode(bss, NL80211_IFTYPE_STATION) < 0) {
+		wpa_printf(MSG_ERROR, "capwap: Could not configure driver to "
+			   "use managed mode");
+		return -1;
+	}
+
+	if (linux_set_fake_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
+#ifdef CONFIG_RFKILL
+		if (rfkill_is_blocked(drv->rfkill)) {
+			wpa_printf(MSG_DEBUG, "capwap: Could not yet enable "
+				   "interface '%s' due to rfkill",
+				   bss->ifname);
+			drv->if_disabled = 1;
+			*send_rfkill_event = 1;
+		} else
+#endif
+		{
+			wpa_printf(MSG_ERROR, "capwap: Could not set "
+				   "interface '%s' UP", bss->ifname);
+			return -1;
+		}
+	}
+
+	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
+			       1, IF_OPER_DORMANT);
+}
+
+static int
+wpa_driver_capwap_finish_drv_init(struct wpa_driver_capwap_data *drv)
+{
+	wpa_printf(MSG_DEBUG, "                                         3.wpa_driver_capwap_finish_drv_init\n");
+	struct i802_bss *bss = &drv->first_bss;
+	int send_rfkill_event = 0;
+
+	drv->ifindex = if_nametoindex(bss->ifname);
+	drv->first_bss.ifindex = drv->ifindex;
+
+	if (drv->nlmode == NL80211_IFTYPE_STATION)
+		wpa_driver_capwap_finish_drv_init_sta(drv, &send_rfkill_event);
+
+
+	if (wpa_driver_capwap_capa(drv))
+		return -1;
+
+	if (linux_get_fake_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
+			       bss->addr))
+		return -1;
+
+	if (send_rfkill_event) {
+#ifdef CONFIG_RFKILL
+		eloop_register_timeout(0, 0, wpa_driver_capwap_send_rfkill,
+				       drv, drv->ctx);
+#endif
+	}
+
+	return 0;
+}
+
+
+static int wpa_driver_capwap_del_bss_beacon(struct i802_bss *bss)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+
+	bss->beacon_set = 0;
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+
+	return send_and_recv_msgs(drv, msg, NULL, NULL);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int wpa_driver_capwap_del_beacon(struct wpa_driver_capwap_data *drv)
+{
+	struct i802_bss *bss;
+
+	for (bss = &drv->first_bss; bss; bss = bss->next)
+		wpa_driver_capwap_del_bss_beacon(bss);
+
+	return 0;
+}
+
+static int wpa_driver_capwap_stop_ap(void *priv)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_del_beacon(bss->drv);
+}
+
+/**
+ * wpa_driver_capwap_deinit - Deinitialize capwap driver interface
+ * @bss: Pointer to private capwap data from wpa_driver_capwap_init()
+ *
+ * Shut down driver interface and processing of driver events. Free
+ * private data buffer if one was allocated in wpa_driver_capwap_init().
+ */
+static void wpa_driver_capwap_deinit(struct i802_bss *bss)
+{
+	wpa_printf(MSG_DEBUG,"wpa_driver_capwap_deinit\n");
+	struct wpa_driver_capwap_data *drv = bss->drv;
+}
+
+
+/**
+ * wpa_driver_capwap_scan_timeout - Scan timeout to report scan completion
+ * @eloop_ctx: Driver private data
+ * @timeout_ctx: ctx argument given to wpa_driver_capwap_init()
+ *
+ * This function can be used as registered timeout when starting a scan to
+ * generate a scan completed event if the driver does not report this.
+ */
+static void wpa_driver_capwap_scan_timeout(void *eloop_ctx, void *timeout_ctx)
+{
+	struct wpa_driver_capwap_data *drv = eloop_ctx;
+	if (drv->ap_scan_as_station != NL80211_IFTYPE_UNSPECIFIED) {
+		wpa_driver_capwap_set_mode(&drv->first_bss,
+					    drv->ap_scan_as_station);
+		drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
+	}
+	wpa_printf(MSG_DEBUG, "Scan timeout - try to get results");
+	wpa_supplicant_event(timeout_ctx, EVENT_SCAN_RESULTS, NULL);
+}
+
+
+static struct nl_msg *
+capwap_scan_common(struct wpa_driver_capwap_data *drv, u8 cmd,
+		    struct wpa_driver_scan_params *params)
+{
+	struct nl_msg *msg;
+	int err;
+	size_t i;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return NULL;
+
+	capwap_cmd(drv, msg, 0, cmd);
+
+	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, drv->ifindex) < 0)
+		goto fail;
+
+	if (params->num_ssids) {
+		struct nl_msg *ssids = nlmsg_alloc();
+		if (ssids == NULL)
+			goto fail;
+		for (i = 1; i < params->num_ssids; i++) {
+			wpa_hexdump_ascii(MSG_MSGDUMP, "capwap: Scan SSID",
+					  params->ssids[i].ssid,
+					  params->ssids[i].ssid_len);
+			if (nla_put(ssids, i + 1, params->ssids[i].ssid_len,
+				    params->ssids[i].ssid) < 0) {
+				nlmsg_free(ssids);
+				goto fail;
+			}
+		}
+		err = nla_put_nested(msg, NL80211_ATTR_SCAN_SSIDS, ssids);
+		nlmsg_free(ssids);
+		if (err < 0)
+			goto fail;
+	}
+
+	if (params->extra_ies) {
+		wpa_hexdump(MSG_MSGDUMP, "capwap: Scan extra IEs",
+			    params->extra_ies, params->extra_ies_len);
+		if (nla_put(msg, NL80211_ATTR_IE, params->extra_ies_len,
+			    params->extra_ies) < 0)
+			goto fail;
+	}
+
+	if (params->freqs) {
+		struct nl_msg *freqs = nlmsg_alloc();
+		if (freqs == NULL)
+			goto fail;
+		for (i = 0; params->freqs[i]; i++) {
+			wpa_printf(MSG_MSGDUMP, "capwap: Scan frequency %u "
+				   "MHz", params->freqs[i]);
+			if (nla_put_u32(freqs, i + 1, params->freqs[i]) < 0) {
+				nlmsg_free(freqs);
+				goto fail;
+			}
+		}
+		err = nla_put_nested(msg, NL80211_ATTR_SCAN_FREQUENCIES,
+				     freqs);
+		nlmsg_free(freqs);
+		if (err < 0)
+			goto fail;
+	}
+
+	os_free(drv->filter_ssids);
+	drv->filter_ssids = params->filter_ssids;
+	params->filter_ssids = NULL;
+	drv->num_filter_ssids = params->num_filter_ssids;
+
+	return msg;
+
+fail:
+	nlmsg_free(msg);
+	return NULL;
+}
+
+
+/**
+ * wpa_driver_capwap_scan - Request the driver to initiate scan
+ * @bss: Pointer to private driver data from wpa_driver_capwap_init()
+ * @params: Scan parameters
+ * Returns: 0 on success, -1 on failure
+ */
+static int wpa_driver_capwap_scan(struct i802_bss *bss,
+				   struct wpa_driver_scan_params *params)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = -1, timeout;
+	struct nl_msg *msg, *rates = NULL;
+
+	drv->scan_for_auth = 0;
+
+	msg = capwap_scan_common(drv, NL80211_CMD_TRIGGER_SCAN, params);
+	if (!msg)
+		return -1;
+
+	if (params->p2p_probe) {
+		wpa_printf(MSG_DEBUG, "capwap: P2P probe - mask SuppRates");
+
+		rates = nlmsg_alloc();
+		if (rates == NULL)
+			goto nla_put_failure;
+
+		/*
+		 * Remove 2.4 GHz rates 1, 2, 5.5, 11 Mbps from supported rates
+		 * by masking out everything else apart from the OFDM rates 6,
+		 * 9, 12, 18, 24, 36, 48, 54 Mbps from non-MCS rates. All 5 GHz
+		 * rates are left enabled.
+		 */
+		NLA_PUT(rates, NL80211_BAND_2GHZ, 8,
+			"\x0c\x12\x18\x24\x30\x48\x60\x6c");
+		if (nla_put_nested(msg, NL80211_ATTR_SCAN_SUPP_RATES, rates) <
+		    0)
+			goto nla_put_failure;
+
+		NLA_PUT_FLAG(msg, NL80211_ATTR_TX_NO_CCK_RATE);
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Scan trigger failed: ret=%d "
+			   "(%s)", ret, strerror(-ret));
+#ifdef HOSTAPD
+		if (is_ap_interface(drv->nlmode)) {
+			/*
+			 * mac80211 does not allow scan requests in AP mode, so
+			 * try to do this in station mode.
+			 */
+			if (wpa_driver_capwap_set_mode(
+				    bss, NL80211_IFTYPE_STATION))
+				goto nla_put_failure;
+
+			if (wpa_driver_capwap_scan(bss, params)) {
+				wpa_driver_capwap_set_mode(bss, drv->nlmode);
+				goto nla_put_failure;
+			}
+
+			/* Restore AP mode when processing scan results */
+			drv->ap_scan_as_station = drv->nlmode;
+			ret = 0;
+		} else
+			goto nla_put_failure;
+#else /* HOSTAPD */
+		goto nla_put_failure;
+#endif /* HOSTAPD */
+	}
+
+	/* Not all drivers generate "scan completed" wireless event, so try to
+	 * read results after a timeout. */
+	timeout = 10;
+	if (drv->scan_complete_events) {
+		/*
+		 * The driver seems to deliver events to notify when scan is
+		 * complete, so use longer timeout to avoid race conditions
+		 * with scanning and following association request.
+		 */
+		timeout = 30;
+	}
+	wpa_printf(MSG_DEBUG, "Scan requested (ret=%d) - scan timeout %d "
+		   "seconds", ret, timeout);
+	eloop_cancel_timeout(wpa_driver_capwap_scan_timeout, drv, drv->ctx);
+	eloop_register_timeout(timeout, 0, wpa_driver_capwap_scan_timeout,
+			       drv, drv->ctx);
+
+nla_put_failure:
+	nlmsg_free(msg);
+	nlmsg_free(rates);
+	return ret;
+}
+
+
+/**
+ * wpa_driver_capwap_sched_scan - Initiate a scheduled scan
+ * @priv: Pointer to private driver data from wpa_driver_capwap_init()
+ * @params: Scan parameters
+ * @interval: Interval between scan cycles in milliseconds
+ * Returns: 0 on success, -1 on failure or if not supported
+ */
+static int wpa_driver_capwap_sched_scan(void *priv,
+					 struct wpa_driver_scan_params *params,
+					 u32 interval)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = -1;
+	struct nl_msg *msg;
+	struct nl_msg *match_set_ssid = NULL, *match_sets = NULL;
+	struct nl_msg *match_set_rssi = NULL;
+	size_t i;
+
+#ifdef ANDROID
+	if (!drv->capa.sched_scan_supported)
+		return android_pno_start(bss, params);
+#endif /* ANDROID */
+
+	msg = capwap_scan_common(drv, NL80211_CMD_START_SCHED_SCAN, params);
+	if (!msg)
+		goto nla_put_failure;
+
+	NLA_PUT_U32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL, interval);
+
+	if ((drv->num_filter_ssids &&
+	    (int) drv->num_filter_ssids <= drv->capa.max_match_sets) ||
+	    params->filter_rssi) {
+		match_sets = nlmsg_alloc();
+		if (match_sets == NULL)
+			goto nla_put_failure;
+		
+		for (i = 1; i < drv->num_filter_ssids; i++) {
+			wpa_hexdump_ascii(MSG_MSGDUMP,
+					  "capwap: Sched scan filter SSID",
+					  drv->filter_ssids[i].ssid,
+					  drv->filter_ssids[i].ssid_len);
+
+			match_set_ssid = nlmsg_alloc();
+			if (match_set_ssid == NULL)
+				goto nla_put_failure;
+			NLA_PUT(match_set_ssid,
+				NL80211_ATTR_SCHED_SCAN_MATCH_SSID,
+				drv->filter_ssids[i].ssid_len,
+				drv->filter_ssids[i].ssid);
+
+			if (nla_put_nested(match_sets, i + 1, match_set_ssid) <
+			    0)
+				goto nla_put_failure;
+		}
+
+		if (params->filter_rssi) {
+			match_set_rssi = nlmsg_alloc();
+			if (match_set_rssi == NULL)
+				goto nla_put_failure;
+			NLA_PUT_U32(match_set_rssi,
+				    NL80211_SCHED_SCAN_MATCH_ATTR_RSSI,
+				    params->filter_rssi);
+			wpa_printf(MSG_MSGDUMP,
+				   "capwap: Sched scan RSSI filter %d dBm",
+				   params->filter_rssi);
+			if (nla_put_nested(match_sets, 0, match_set_rssi) < 0)
+				goto nla_put_failure;
+		}
+
+		if (nla_put_nested(msg, NL80211_ATTR_SCHED_SCAN_MATCH,
+				   match_sets) < 0)
+			goto nla_put_failure;
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+
+	/* TODO: if we get an error here, we should fall back to normal scan */
+
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Sched scan start failed: "
+			   "ret=%d (%s)", ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Sched scan requested (ret=%d) - "
+		   "scan interval %d msec", ret, interval);
+
+nla_put_failure:
+	nlmsg_free(match_set_ssid);
+	nlmsg_free(match_sets);
+	nlmsg_free(match_set_rssi);
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+/**
+ * wpa_driver_capwap_stop_sched_scan - Stop a scheduled scan
+ * @priv: Pointer to private driver data from wpa_driver_capwap_init()
+ * Returns: 0 on success, -1 on failure or if not supported
+ */
+static int wpa_driver_capwap_stop_sched_scan(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = 0;
+	struct nl_msg *msg;
+
+#ifdef ANDROID
+	if (!drv->capa.sched_scan_supported)
+		return android_pno_stop(bss);
+#endif /* ANDROID */
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_STOP_SCHED_SCAN);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Sched scan stop failed: "
+			   "ret=%d (%s)", ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Sched scan stop sent (ret=%d)", ret);
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static const u8 * capwap_get_ie(const u8 *ies, size_t ies_len, u8 ie)
+{
+	const u8 *end, *pos;
+
+	if (ies == NULL)
+		return NULL;
+
+	pos = ies;
+	end = ies + ies_len;
+
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		if (pos[0] == ie)
+			return pos;
+		pos += 2 + pos[1];
+	}
+
+	return NULL;
+}
+
+
+static int capwap_scan_filtered(struct wpa_driver_capwap_data *drv,
+				 const u8 *ie, size_t ie_len)
+{
+	const u8 *ssid;
+	size_t i;
+
+	if (drv->filter_ssids == NULL)
+		return 0;
+
+	ssid = capwap_get_ie(ie, ie_len, WLAN_EID_SSID);
+	if (ssid == NULL)
+		return 1;
+
+	for (i = 0; i < drv->num_filter_ssids; i++) {
+		if (ssid[1] == drv->filter_ssids[i].ssid_len &&
+		    os_memcmp(ssid + 2, drv->filter_ssids[i].ssid, ssid[1]) ==
+		    0)
+			return 0;
+	}
+
+	return 1;
+}
+
+
+static int bss_info_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *bss[NL80211_BSS_MAX + 1];
+	static struct nla_policy bss_policy[NL80211_BSS_MAX + 1] = {
+		[NL80211_BSS_BSSID] = { .type = NLA_UNSPEC },
+		[NL80211_BSS_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_BSS_TSF] = { .type = NLA_U64 },
+		[NL80211_BSS_BEACON_INTERVAL] = { .type = NLA_U16 },
+		[NL80211_BSS_CAPABILITY] = { .type = NLA_U16 },
+		[NL80211_BSS_INFORMATION_ELEMENTS] = { .type = NLA_UNSPEC },
+		[NL80211_BSS_SIGNAL_MBM] = { .type = NLA_U32 },
+		[NL80211_BSS_SIGNAL_UNSPEC] = { .type = NLA_U8 },
+		[NL80211_BSS_STATUS] = { .type = NLA_U32 },
+		[NL80211_BSS_SEEN_MS_AGO] = { .type = NLA_U32 },
+		[NL80211_BSS_BEACON_IES] = { .type = NLA_UNSPEC },
+	};
+	struct capwap_bss_info_arg *_arg = arg;
+	struct wpa_scan_results *res = _arg->res;
+	struct wpa_scan_res **tmp;
+	struct wpa_scan_res *r;
+	const u8 *ie, *beacon_ie;
+	size_t ie_len, beacon_ie_len;
+	u8 *pos;
+	size_t i;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	if (!tb[NL80211_ATTR_BSS])
+		return NL_SKIP;
+	if (nla_parse_nested(bss, NL80211_BSS_MAX, tb[NL80211_ATTR_BSS],
+			     bss_policy))
+		return NL_SKIP;
+	if (bss[NL80211_BSS_STATUS]) {
+		enum nl80211_bss_status status;
+		status = nla_get_u32(bss[NL80211_BSS_STATUS]);
+		if (status == NL80211_BSS_STATUS_ASSOCIATED &&
+		    bss[NL80211_BSS_FREQUENCY]) {
+			_arg->assoc_freq =
+				nla_get_u32(bss[NL80211_BSS_FREQUENCY]);
+			wpa_printf(MSG_DEBUG, "capwap: Associated on %u MHz",
+				   _arg->assoc_freq);
+		}
+		if (status == NL80211_BSS_STATUS_ASSOCIATED &&
+		    bss[NL80211_BSS_BSSID]) {
+			os_memcpy(_arg->assoc_bssid,
+				  nla_data(bss[NL80211_BSS_BSSID]), ETH_ALEN);
+			wpa_printf(MSG_DEBUG, "capwap: Associated with "
+				   MACSTR, MAC2STR(_arg->assoc_bssid));
+		}
+	}
+	if (!res)
+		return NL_SKIP;
+	if (bss[NL80211_BSS_INFORMATION_ELEMENTS]) {
+		ie = nla_data(bss[NL80211_BSS_INFORMATION_ELEMENTS]);
+		ie_len = nla_len(bss[NL80211_BSS_INFORMATION_ELEMENTS]);
+	} else {
+		ie = NULL;
+		ie_len = 0;
+	}
+	if (bss[NL80211_BSS_BEACON_IES]) {
+		beacon_ie = nla_data(bss[NL80211_BSS_BEACON_IES]);
+		beacon_ie_len = nla_len(bss[NL80211_BSS_BEACON_IES]);
+	} else {
+		beacon_ie = NULL;
+		beacon_ie_len = 0;
+	}
+
+	if (capwap_scan_filtered(_arg->drv, ie ? ie : beacon_ie,
+				  ie ? ie_len : beacon_ie_len))
+		return NL_SKIP;
+
+	r = os_zalloc(sizeof(*r) + ie_len + beacon_ie_len);
+	if (r == NULL)
+		return NL_SKIP;
+	if (bss[NL80211_BSS_BSSID])
+		os_memcpy(r->bssid, nla_data(bss[NL80211_BSS_BSSID]),
+			  ETH_ALEN);
+	if (bss[NL80211_BSS_FREQUENCY])
+		r->freq = nla_get_u32(bss[NL80211_BSS_FREQUENCY]);
+	if (bss[NL80211_BSS_BEACON_INTERVAL])
+		r->beacon_int = nla_get_u16(bss[NL80211_BSS_BEACON_INTERVAL]);
+	if (bss[NL80211_BSS_CAPABILITY])
+		r->caps = nla_get_u16(bss[NL80211_BSS_CAPABILITY]);
+	r->flags |= WPA_SCAN_NOISE_INVALID;
+	if (bss[NL80211_BSS_SIGNAL_MBM]) {
+		r->level = nla_get_u32(bss[NL80211_BSS_SIGNAL_MBM]);
+		r->level /= 100; /* mBm to dBm */
+		r->flags |= WPA_SCAN_LEVEL_DBM | WPA_SCAN_QUAL_INVALID;
+	} else if (bss[NL80211_BSS_SIGNAL_UNSPEC]) {
+		r->level = nla_get_u8(bss[NL80211_BSS_SIGNAL_UNSPEC]);
+		r->flags |= WPA_SCAN_QUAL_INVALID;
+	} else
+		r->flags |= WPA_SCAN_LEVEL_INVALID | WPA_SCAN_QUAL_INVALID;
+	if (bss[NL80211_BSS_TSF])
+		r->tsf = nla_get_u64(bss[NL80211_BSS_TSF]);
+	if (bss[NL80211_BSS_SEEN_MS_AGO])
+		r->age = nla_get_u32(bss[NL80211_BSS_SEEN_MS_AGO]);
+	r->ie_len = ie_len;
+	pos = (u8 *) (r + 1);
+	if (ie) {
+		os_memcpy(pos, ie, ie_len);
+		pos += ie_len;
+	}
+	r->beacon_ie_len = beacon_ie_len;
+	if (beacon_ie)
+		os_memcpy(pos, beacon_ie, beacon_ie_len);
+
+	if (bss[NL80211_BSS_STATUS]) {
+		enum nl80211_bss_status status;
+		status = nla_get_u32(bss[NL80211_BSS_STATUS]);
+		switch (status) {
+		case NL80211_BSS_STATUS_AUTHENTICATED:
+			r->flags |= WPA_SCAN_AUTHENTICATED;
+			break;
+		case NL80211_BSS_STATUS_ASSOCIATED:
+			r->flags |= WPA_SCAN_ASSOCIATED;
+			break;
+		default:
+			break;
+		}
+	}
+
+	/*
+	 * cfg80211 maintains separate BSS table entries for APs if the same
+	 * BSSID,SSID pair is seen on multiple channels. wpa_supplicant does
+	 * not use frequency as a separate key in the BSS table, so filter out
+	 * duplicated entries. Prefer associated BSS entry in such a case in
+	 * order to get the correct frequency into the BSS table.
+	 */
+	for (i = 0; i < res->num; i++) {
+		const u8 *s1, *s2;
+		if (os_memcmp(res->res[i]->bssid, r->bssid, ETH_ALEN) != 0)
+			continue;
+
+		s1 = capwap_get_ie((u8 *) (res->res[i] + 1),
+				    res->res[i]->ie_len, WLAN_EID_SSID);
+		s2 = capwap_get_ie((u8 *) (r + 1), r->ie_len, WLAN_EID_SSID);
+		if (s1 == NULL || s2 == NULL || s1[1] != s2[1] ||
+		    os_memcmp(s1, s2, 2 + s1[1]) != 0)
+			continue;
+
+		/* Same BSSID,SSID was already included in scan results */
+		wpa_printf(MSG_DEBUG, "capwap: Remove duplicated scan result "
+			   "for " MACSTR, MAC2STR(r->bssid));
+
+		if ((r->flags & WPA_SCAN_ASSOCIATED) &&
+		    !(res->res[i]->flags & WPA_SCAN_ASSOCIATED)) {
+			os_free(res->res[i]);
+			res->res[i] = r;
+		} else
+			os_free(r);
+		return NL_SKIP;
+	}
+
+	tmp = os_realloc_array(res->res, res->num + 1,
+			       sizeof(struct wpa_scan_res *));
+	if (tmp == NULL) {
+		os_free(r);
+		return NL_SKIP;
+	}
+	tmp[res->num++] = r;
+	res->res = tmp;
+
+	return NL_SKIP;
+}
+
+
+static void clear_state_mismatch(struct wpa_driver_capwap_data *drv,
+				 const u8 *addr)
+{
+	if (drv->capa.flags & WPA_DRIVER_FLAGS_SME) {
+		wpa_printf(MSG_DEBUG, "capwap: Clear possible state "
+			   "mismatch (" MACSTR ")", MAC2STR(addr));
+		wpa_driver_capwap_mlme(drv, addr,
+					NL80211_CMD_DEAUTHENTICATE,
+					WLAN_REASON_PREV_AUTH_NOT_VALID, 1);
+	}
+}
+
+
+static void wpa_driver_capwap_check_bss_status(
+	struct wpa_driver_capwap_data *drv, struct wpa_scan_results *res)
+{
+	size_t i;
+
+	for (i = 0; i < res->num; i++) {
+		struct wpa_scan_res *r = res->res[i];
+		if (r->flags & WPA_SCAN_AUTHENTICATED) {
+			wpa_printf(MSG_DEBUG, "capwap: Scan results "
+				   "indicates BSS status with " MACSTR
+				   " as authenticated",
+				   MAC2STR(r->bssid));
+			if (is_sta_interface(drv->nlmode) &&
+			    os_memcmp(r->bssid, drv->bssid, ETH_ALEN) != 0 &&
+			    os_memcmp(r->bssid, drv->auth_bssid, ETH_ALEN) !=
+			    0) {
+				wpa_printf(MSG_DEBUG, "capwap: Unknown BSSID"
+					   " in local state (auth=" MACSTR
+					   " assoc=" MACSTR ")",
+					   MAC2STR(drv->auth_bssid),
+					   MAC2STR(drv->bssid));
+				clear_state_mismatch(drv, r->bssid);
+			}
+		}
+
+		if (r->flags & WPA_SCAN_ASSOCIATED) {
+			wpa_printf(MSG_DEBUG, "capwap: Scan results "
+				   "indicate BSS status with " MACSTR
+				   " as associated",
+				   MAC2STR(r->bssid));
+			if (is_sta_interface(drv->nlmode) &&
+			    !drv->associated) {
+				wpa_printf(MSG_DEBUG, "capwap: Local state "
+					   "(not associated) does not match "
+					   "with BSS state");
+				clear_state_mismatch(drv, r->bssid);
+			} else if (is_sta_interface(drv->nlmode) &&
+				   os_memcmp(drv->bssid, r->bssid, ETH_ALEN) !=
+				   0) {
+				wpa_printf(MSG_DEBUG, "capwap: Local state "
+					   "(associated with " MACSTR ") does "
+					   "not match with BSS state",
+					   MAC2STR(drv->bssid));
+				clear_state_mismatch(drv, r->bssid);
+				clear_state_mismatch(drv, drv->bssid);
+			}
+		}
+	}
+}
+
+
+static struct wpa_scan_results *
+capwap_get_scan_results(struct wpa_driver_capwap_data *drv)
+{
+	struct nl_msg *msg;
+	struct wpa_scan_results *res;
+	int ret;
+	struct capwap_bss_info_arg arg;
+
+	res = os_zalloc(sizeof(*res));
+	if (res == NULL)
+		return NULL;
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto nla_put_failure;
+
+	capwap_cmd(drv, msg, NLM_F_DUMP, NL80211_CMD_GET_SCAN);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	arg.drv = drv;
+	arg.res = res;
+	ret = send_and_recv_msgs(drv, msg, bss_info_handler, &arg);
+	msg = NULL;
+	if (ret == 0) {
+		wpa_printf(MSG_DEBUG, "capwap: Received scan results (%lu "
+			   "BSSes)", (unsigned long) res->num);
+		capwap_get_noise_for_scan_results(drv, res);
+		return res;
+	}
+	wpa_printf(MSG_DEBUG, "capwap: Scan result fetch failed: ret=%d "
+		   "(%s)", ret, strerror(-ret));
+nla_put_failure:
+	nlmsg_free(msg);
+	wpa_scan_results_free(res);
+	return NULL;
+}
+
+
+/**
+ * wpa_driver_capwap_get_scan_results - Fetch the latest scan results
+ * @priv: Pointer to private wext data from wpa_driver_capwap_init()
+ * Returns: Scan results on success, -1 on failure
+ */
+static struct wpa_scan_results *
+wpa_driver_capwap_get_scan_results(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct wpa_scan_results *res;
+
+	res = capwap_get_scan_results(drv);
+	if (res)
+		wpa_driver_capwap_check_bss_status(drv, res);
+	return res;
+}
+
+
+static void capwap_dump_scan(struct wpa_driver_capwap_data *drv)
+{
+	struct wpa_scan_results *res;
+	size_t i;
+
+	res = capwap_get_scan_results(drv);
+	if (res == NULL) {
+		wpa_printf(MSG_DEBUG, "capwap: Failed to get scan results");
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Scan result dump");
+	for (i = 0; i < res->num; i++) {
+		struct wpa_scan_res *r = res->res[i];
+		wpa_printf(MSG_DEBUG, "capwap: %d/%d " MACSTR "%s%s",
+			   (int) i, (int) res->num, MAC2STR(r->bssid),
+			   r->flags & WPA_SCAN_AUTHENTICATED ? " [auth]" : "",
+			   r->flags & WPA_SCAN_ASSOCIATED ? " [assoc]" : "");
+	}
+
+	wpa_scan_results_free(res);
+}
+
+
+static int wpa_driver_capwap_set_key(const char *ifname, struct i802_bss *bss,
+				      enum wpa_alg alg, const u8 *addr,
+				      int key_idx, int set_tx,
+				      const u8 *seq, size_t seq_len,
+				      const u8 *key, size_t key_len)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ifindex = if_nametoindex(ifname);
+	struct nl_msg *msg;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s: ifindex=%d alg=%d addr=%p key_idx=%d "
+		   "set_tx=%d seq_len=%lu key_len=%lu",
+		   __func__, ifindex, alg, addr, key_idx, set_tx,
+		   (unsigned long) seq_len, (unsigned long) key_len);
+#ifdef CONFIG_TDLS
+	if (key_idx == -1)
+		key_idx = 0;
+#endif /* CONFIG_TDLS */
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	if (alg == WPA_ALG_NONE) {
+		capwap_cmd(drv, msg, 0, NL80211_CMD_DEL_KEY);
+	} else {
+		capwap_cmd(drv, msg, 0, NL80211_CMD_NEW_KEY);
+		NLA_PUT(msg, NL80211_ATTR_KEY_DATA, key_len, key);
+		switch (alg) {
+		case WPA_ALG_WEP:
+			if (key_len == 5)
+				NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+					    WLAN_CIPHER_SUITE_WEP40);
+			else
+				NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+					    WLAN_CIPHER_SUITE_WEP104);
+			break;
+		case WPA_ALG_TKIP:
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_TKIP);
+			break;
+		case WPA_ALG_CCMP:
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_CCMP);
+			break;
+		case WPA_ALG_GCMP:
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_GCMP);
+			break;
+		case WPA_ALG_IGTK:
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_AES_CMAC);
+			break;
+		case WPA_ALG_SMS4:
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_SMS4);
+			break;
+		case WPA_ALG_KRK:
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_KRK);
+			break;
+		default:
+			wpa_printf(MSG_ERROR, "%s: Unsupported encryption "
+				   "algorithm %d", __func__, alg);
+			nlmsg_free(msg);
+			return -1;
+		}
+	}
+
+	if (seq && seq_len)
+		NLA_PUT(msg, NL80211_ATTR_KEY_SEQ, seq_len, seq);
+
+	if (addr && !is_broadcast_ether_addr(addr)) {
+		wpa_printf(MSG_DEBUG, "   addr=" MACSTR, MAC2STR(addr));
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+
+		if (alg != WPA_ALG_WEP && key_idx && !set_tx) {
+			wpa_printf(MSG_DEBUG, "   RSN IBSS RX GTK");
+			NLA_PUT_U32(msg, NL80211_ATTR_KEY_TYPE,
+				    NL80211_KEYTYPE_GROUP);
+		}
+	} else if (addr && is_broadcast_ether_addr(addr)) {
+		struct nl_msg *types;
+		int err;
+		wpa_printf(MSG_DEBUG, "   broadcast key");
+		types = nlmsg_alloc();
+		if (!types)
+			goto nla_put_failure;
+		NLA_PUT_FLAG(types, NL80211_KEY_DEFAULT_TYPE_MULTICAST);
+		err = nla_put_nested(msg, NL80211_ATTR_KEY_DEFAULT_TYPES,
+				     types);
+		nlmsg_free(types);
+		if (err)
+			goto nla_put_failure;
+	}
+	NLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, key_idx);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	if ((ret == -ENOENT || ret == -ENOLINK) && alg == WPA_ALG_NONE)
+		ret = 0;
+	if (ret)
+		wpa_printf(MSG_DEBUG, "capwap: set_key failed; err=%d %s)",
+			   ret, strerror(-ret));
+
+	/*
+	 * If we failed or don't need to set the default TX key (below),
+	 * we're done here.
+	 */
+	if (ret || !set_tx || alg == WPA_ALG_NONE)
+		return ret;
+	if (is_ap_interface(drv->nlmode) && addr &&
+	    !is_broadcast_ether_addr(addr))
+		return ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_KEY);
+	NLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, key_idx);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
+	if (alg == WPA_ALG_IGTK)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_KEY_DEFAULT_MGMT);
+	else
+		NLA_PUT_FLAG(msg, NL80211_ATTR_KEY_DEFAULT);
+	if (addr && is_broadcast_ether_addr(addr)) {
+		struct nl_msg *types;
+		int err;
+		types = nlmsg_alloc();
+		if (!types)
+			goto nla_put_failure;
+		NLA_PUT_FLAG(types, NL80211_KEY_DEFAULT_TYPE_MULTICAST);
+		err = nla_put_nested(msg, NL80211_ATTR_KEY_DEFAULT_TYPES,
+				     types);
+		nlmsg_free(types);
+		if (err)
+			goto nla_put_failure;
+	} else if (addr) {
+		struct nl_msg *types;
+		int err;
+		types = nlmsg_alloc();
+		if (!types)
+			goto nla_put_failure;
+		NLA_PUT_FLAG(types, NL80211_KEY_DEFAULT_TYPE_UNICAST);
+		err = nla_put_nested(msg, NL80211_ATTR_KEY_DEFAULT_TYPES,
+				     types);
+		nlmsg_free(types);
+		if (err)
+			goto nla_put_failure;
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	if (ret == -ENOENT)
+		ret = 0;
+	if (ret)
+		wpa_printf(MSG_DEBUG, "capwap: set_key default failed; "
+			   "err=%d %s)", ret, strerror(-ret));
+	return ret;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int nl_add_key(struct nl_msg *msg, enum wpa_alg alg,
+		      int key_idx, int defkey,
+		      const u8 *seq, size_t seq_len,
+		      const u8 *key, size_t key_len)
+{
+	struct nlattr *key_attr = nla_nest_start(msg, NL80211_ATTR_KEY);
+	if (!key_attr)
+		return -1;
+
+	if (defkey && alg == WPA_ALG_IGTK)
+		NLA_PUT_FLAG(msg, NL80211_KEY_DEFAULT_MGMT);
+	else if (defkey)
+		NLA_PUT_FLAG(msg, NL80211_KEY_DEFAULT);
+
+	NLA_PUT_U8(msg, NL80211_KEY_IDX, key_idx);
+
+	switch (alg) {
+	case WPA_ALG_WEP:
+		if (key_len == 5)
+			NLA_PUT_U32(msg, NL80211_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_WEP40);
+		else
+			NLA_PUT_U32(msg, NL80211_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_WEP104);
+		break;
+	case WPA_ALG_TKIP:
+		NLA_PUT_U32(msg, NL80211_KEY_CIPHER, WLAN_CIPHER_SUITE_TKIP);
+		break;
+	case WPA_ALG_CCMP:
+		NLA_PUT_U32(msg, NL80211_KEY_CIPHER, WLAN_CIPHER_SUITE_CCMP);
+		break;
+	case WPA_ALG_GCMP:
+		NLA_PUT_U32(msg, NL80211_KEY_CIPHER, WLAN_CIPHER_SUITE_GCMP);
+		break;
+	case WPA_ALG_IGTK:
+		NLA_PUT_U32(msg, NL80211_KEY_CIPHER,
+			    WLAN_CIPHER_SUITE_AES_CMAC);
+		break;
+	default:
+		wpa_printf(MSG_ERROR, "%s: Unsupported encryption "
+			   "algorithm %d", __func__, alg);
+		return -1;
+	}
+
+	if (seq && seq_len)
+		NLA_PUT(msg, NL80211_KEY_SEQ, seq_len, seq);
+
+	NLA_PUT(msg, NL80211_KEY_DATA, key_len, key);
+
+	nla_nest_end(msg, key_attr);
+
+	return 0;
+ nla_put_failure:
+	return -1;
+}
+
+
+static int capwap_set_conn_keys(struct wpa_driver_associate_params *params,
+				 struct nl_msg *msg)
+{
+	int i, privacy = 0;
+	struct nlattr *nl_keys, *nl_key;
+
+	for (i = 0; i < 4; i++) {
+		if (!params->wep_key[i])
+			continue;
+		privacy = 1;
+		break;
+	}
+	if (params->wps == WPS_MODE_PRIVACY)
+		privacy = 1;
+	if (params->pairwise_suite &&
+	    params->pairwise_suite != WPA_CIPHER_NONE)
+		privacy = 1;
+
+	if (!privacy)
+		return 0;
+
+	NLA_PUT_FLAG(msg, NL80211_ATTR_PRIVACY);
+
+	nl_keys = nla_nest_start(msg, NL80211_ATTR_KEYS);
+	if (!nl_keys)
+		goto nla_put_failure;
+
+	for (i = 0; i < 4; i++) {
+		if (!params->wep_key[i])
+			continue;
+
+		nl_key = nla_nest_start(msg, i);
+		if (!nl_key)
+			goto nla_put_failure;
+
+		NLA_PUT(msg, NL80211_KEY_DATA, params->wep_key_len[i],
+			params->wep_key[i]);
+		if (params->wep_key_len[i] == 5)
+			NLA_PUT_U32(msg, NL80211_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_WEP40);
+		else
+			NLA_PUT_U32(msg, NL80211_KEY_CIPHER,
+				    WLAN_CIPHER_SUITE_WEP104);
+
+		NLA_PUT_U8(msg, NL80211_KEY_IDX, i);
+
+		if (i == params->wep_tx_keyidx)
+			NLA_PUT_FLAG(msg, NL80211_KEY_DEFAULT);
+
+		nla_nest_end(msg, nl_key);
+	}
+	nla_nest_end(msg, nl_keys);
+
+	return 0;
+
+nla_put_failure:
+	return -ENOBUFS;
+}
+
+
+static int wpa_driver_capwap_mlme(struct wpa_driver_capwap_data *drv,
+				   const u8 *addr, int cmd, u16 reason_code,
+				   int local_state_change)
+{
+	int ret = -1;
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, cmd);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason_code);
+	if (addr)
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+	if (local_state_change)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_LOCAL_STATE_CHANGE);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_dbg(drv->ctx, MSG_DEBUG,
+			"capwap: MLME command failed: reason=%u ret=%d (%s)",
+			reason_code, ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+	ret = 0;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wpa_driver_capwap_disconnect(struct wpa_driver_capwap_data *drv,
+					 int reason_code)
+{
+	wpa_printf(MSG_DEBUG, "%s(reason_code=%d)", __func__, reason_code);
+	drv->associated = 0;
+	drv->ignore_next_local_disconnect = 0;
+	/* Disconnect command doesn't need BSSID - it uses cached value */
+	return wpa_driver_capwap_mlme(drv, NULL, NL80211_CMD_DISCONNECT,
+				       reason_code, 0);
+}
+
+
+static int wpa_driver_capwap_deauthenticate(struct i802_bss *bss,
+					     const u8 *addr, int reason_code)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_SME))
+		return wpa_driver_capwap_disconnect(drv, reason_code);
+	wpa_printf(MSG_DEBUG, "%s(addr=" MACSTR " reason_code=%d)",
+		   __func__, MAC2STR(addr), reason_code);
+	drv->associated = 0;
+	if (drv->nlmode == NL80211_IFTYPE_ADHOC)
+		return capwap_leave_ibss(drv);
+	return wpa_driver_capwap_mlme(drv, addr, NL80211_CMD_DEAUTHENTICATE,
+				       reason_code, 0);
+}
+
+
+static void capwap_copy_auth_params(struct wpa_driver_capwap_data *drv,
+				     struct wpa_driver_auth_params *params)
+{
+	int i;
+
+	drv->auth_freq = params->freq;
+	drv->auth_alg = params->auth_alg;
+	drv->auth_wep_tx_keyidx = params->wep_tx_keyidx;
+	drv->auth_local_state_change = params->local_state_change;
+	drv->auth_p2p = params->p2p;
+
+	if (params->bssid)
+		os_memcpy(drv->auth_bssid_, params->bssid, ETH_ALEN);
+	else
+		os_memset(drv->auth_bssid_, 0, ETH_ALEN);
+
+	if (params->ssid) {
+		os_memcpy(drv->auth_ssid, params->ssid, params->ssid_len);
+		drv->auth_ssid_len = params->ssid_len;
+	} else
+		drv->auth_ssid_len = 0;
+
+
+	os_free(drv->auth_ie);
+	drv->auth_ie = NULL;
+	drv->auth_ie_len = 0;
+	if (params->ie) {
+		drv->auth_ie = os_malloc(params->ie_len);
+		if (drv->auth_ie) {
+			os_memcpy(drv->auth_ie, params->ie, params->ie_len);
+			drv->auth_ie_len = params->ie_len;
+		}
+	}
+
+	for (i = 0; i < 4; i++) {
+		if (params->wep_key[i] && params->wep_key_len[i] &&
+		    params->wep_key_len[i] <= 16) {
+			os_memcpy(drv->auth_wep_key[i], params->wep_key[i],
+				  params->wep_key_len[i]);
+			drv->auth_wep_key_len[i] = params->wep_key_len[i];
+		} else
+			drv->auth_wep_key_len[i] = 0;
+	}
+}
+
+
+static int wpa_driver_capwap_authenticate(
+	struct i802_bss *bss, struct wpa_driver_auth_params *params)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = -1, i;
+	struct nl_msg *msg;
+	enum nl80211_auth_type type;
+	enum nl80211_iftype nlmode;
+	int count = 0;
+	int is_retry;
+
+	is_retry = drv->retry_auth;
+	drv->retry_auth = 0;
+
+	drv->associated = 0;
+	os_memset(drv->auth_bssid, 0, ETH_ALEN);
+	/* FIX: IBSS mode */
+	nlmode = params->p2p ?
+		NL80211_IFTYPE_P2P_CLIENT : NL80211_IFTYPE_STATION;
+	if (drv->nlmode != nlmode &&
+	    wpa_driver_capwap_set_mode(bss, nlmode) < 0)
+		return -1;
+
+retry:
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: Authenticate (ifindex=%d)",
+		   drv->ifindex);
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_AUTHENTICATE);
+
+	for (i = 0; i < 4; i++) {
+		if (!params->wep_key[i])
+			continue;
+		wpa_driver_capwap_set_key(bss->ifname, bss, WPA_ALG_WEP,
+					   NULL, i,
+					   i == params->wep_tx_keyidx, NULL, 0,
+					   params->wep_key[i],
+					   params->wep_key_len[i]);
+		if (params->wep_tx_keyidx != i)
+			continue;
+		if (nl_add_key(msg, WPA_ALG_WEP, i, 1, NULL, 0,
+			       params->wep_key[i], params->wep_key_len[i])) {
+			nlmsg_free(msg);
+			return -1;
+		}
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	if (params->bssid) {
+		wpa_printf(MSG_DEBUG, "  * bssid=" MACSTR,
+			   MAC2STR(params->bssid));
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, params->bssid);
+	}
+	if (params->freq) {
+		wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
+	}
+	if (params->ssid) {
+		wpa_hexdump_ascii(MSG_DEBUG, "  * SSID",
+				  params->ssid, params->ssid_len);
+		NLA_PUT(msg, NL80211_ATTR_SSID, params->ssid_len,
+			params->ssid);
+	}
+	wpa_hexdump(MSG_DEBUG, "  * IEs", params->ie, params->ie_len);
+	if (params->ie)
+		NLA_PUT(msg, NL80211_ATTR_IE, params->ie_len, params->ie);
+	if (params->sae_data) {
+		wpa_hexdump(MSG_DEBUG, "  * SAE data", params->sae_data,
+			    params->sae_data_len);
+		NLA_PUT(msg, NL80211_ATTR_SAE_DATA, params->sae_data_len,
+			params->sae_data);
+	}
+	if (params->auth_alg & WPA_AUTH_ALG_OPEN)
+		type = NL80211_AUTHTYPE_OPEN_SYSTEM;
+	else if (params->auth_alg & WPA_AUTH_ALG_SHARED)
+		type = NL80211_AUTHTYPE_SHARED_KEY;
+	else if (params->auth_alg & WPA_AUTH_ALG_LEAP)
+		type = NL80211_AUTHTYPE_NETWORK_EAP;
+	else if (params->auth_alg & WPA_AUTH_ALG_FT)
+		type = NL80211_AUTHTYPE_FT;
+	else if (params->auth_alg & WPA_AUTH_ALG_SAE)
+		type = NL80211_AUTHTYPE_SAE;
+	else
+		goto nla_put_failure;
+	wpa_printf(MSG_DEBUG, "  * Auth Type %d", type);
+	NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE, type);
+	if (params->local_state_change) {
+		wpa_printf(MSG_DEBUG, "  * Local state change only");
+		NLA_PUT_FLAG(msg, NL80211_ATTR_LOCAL_STATE_CHANGE);
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_dbg(drv->ctx, MSG_DEBUG,
+			"capwap: MLME command failed (auth): ret=%d (%s)",
+			ret, strerror(-ret));
+		count++;
+		if (ret == -EALREADY && count == 1 && params->bssid &&
+		    !params->local_state_change) {
+			/*
+			 * mac80211 does not currently accept new
+			 * authentication if we are already authenticated. As a
+			 * workaround, force deauthentication and try again.
+			 */
+			wpa_printf(MSG_DEBUG, "capwap: Retry authentication "
+				   "after forced deauthentication");
+			wpa_driver_capwap_deauthenticate(
+				bss, params->bssid,
+				WLAN_REASON_PREV_AUTH_NOT_VALID);
+			nlmsg_free(msg);
+			goto retry;
+		}
+
+		if (ret == -ENOENT && params->freq && !is_retry) {
+			/*
+			 * cfg80211 has likely expired the BSS entry even
+			 * though it was previously available in our internal
+			 * BSS table. To recover quickly, start a single
+			 * channel scan on the specified channel.
+			 */
+			struct wpa_driver_scan_params scan;
+			int freqs[2];
+
+			os_memset(&scan, 0, sizeof(scan));
+			scan.num_ssids = 1;
+			if (params->ssid) {
+				scan.ssids[0].ssid = params->ssid;
+				scan.ssids[0].ssid_len = params->ssid_len;
+			}
+			freqs[0] = params->freq;
+			freqs[1] = 0;
+			scan.freqs = freqs;
+			wpa_printf(MSG_DEBUG, "capwap: Trigger single "
+				   "channel scan to refresh cfg80211 BSS "
+				   "entry");
+			ret = wpa_driver_capwap_scan(bss, &scan);
+			if (ret == 0) {
+				capwap_copy_auth_params(drv, params);
+				drv->scan_for_auth = 1;
+			}
+		} else if (is_retry) {
+			/*
+			 * Need to indicate this with an event since the return
+			 * value from the retry is not delivered to core code.
+			 */
+			union wpa_event_data event;
+			wpa_printf(MSG_DEBUG, "capwap: Authentication retry "
+				   "failed");
+			os_memset(&event, 0, sizeof(event));
+			os_memcpy(event.timeout_event.addr, drv->auth_bssid_,
+				  ETH_ALEN);
+			wpa_supplicant_event(drv->ctx, EVENT_AUTH_TIMED_OUT,
+					     &event);
+		}
+
+		goto nla_put_failure;
+	}
+	ret = 0;
+	wpa_printf(MSG_DEBUG, "capwap: Authentication request send "
+		   "successfully");
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wpa_driver_capwap_authenticate_retry(
+	struct wpa_driver_capwap_data *drv)
+{
+	struct wpa_driver_auth_params params;
+	struct i802_bss *bss = &drv->first_bss;
+	int i;
+
+	wpa_printf(MSG_DEBUG, "capwap: Try to authenticate again");
+
+	os_memset(&params, 0, sizeof(params));
+	params.freq = drv->auth_freq;
+	params.auth_alg = drv->auth_alg;
+	params.wep_tx_keyidx = drv->auth_wep_tx_keyidx;
+	params.local_state_change = drv->auth_local_state_change;
+	params.p2p = drv->auth_p2p;
+
+	if (!is_zero_ether_addr(drv->auth_bssid_))
+		params.bssid = drv->auth_bssid_;
+
+	if (drv->auth_ssid_len) {
+		params.ssid = drv->auth_ssid;
+		params.ssid_len = drv->auth_ssid_len;
+	}
+
+	params.ie = drv->auth_ie;
+	params.ie_len = drv->auth_ie_len;
+
+	for (i = 0; i < 4; i++) {
+		if (drv->auth_wep_key_len[i]) {
+			params.wep_key[i] = drv->auth_wep_key[i];
+			params.wep_key_len[i] = drv->auth_wep_key_len[i];
+		}
+	}
+
+	drv->retry_auth = 1;
+	return wpa_driver_capwap_authenticate(bss, &params);
+}
+
+
+struct phy_info_arg {
+	u16 *num_modes;
+	struct hostapd_hw_modes *modes;
+};
+
+static int phy_info_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct phy_info_arg *phy_info = arg;
+
+	struct nlattr *tb_band[NL80211_BAND_ATTR_MAX + 1];
+
+	struct nlattr *tb_freq[NL80211_FREQUENCY_ATTR_MAX + 1];
+	static struct nla_policy freq_policy[NL80211_FREQUENCY_ATTR_MAX + 1] = {
+		[NL80211_FREQUENCY_ATTR_FREQ] = { .type = NLA_U32 },
+		[NL80211_FREQUENCY_ATTR_DISABLED] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_PASSIVE_SCAN] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_NO_IBSS] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_RADAR] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_MAX_TX_POWER] = { .type = NLA_U32 },
+	};
+
+	struct nlattr *tb_rate[NL80211_BITRATE_ATTR_MAX + 1];
+	static struct nla_policy rate_policy[NL80211_BITRATE_ATTR_MAX + 1] = {
+		[NL80211_BITRATE_ATTR_RATE] = { .type = NLA_U32 },
+		[NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE] = { .type = NLA_FLAG },
+	};
+
+	struct nlattr *nl_band;
+	struct nlattr *nl_freq;
+	struct nlattr *nl_rate;
+	int rem_band, rem_freq, rem_rate;
+	struct hostapd_hw_modes *mode;
+	int idx, mode_is_set;
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb_msg[NL80211_ATTR_WIPHY_BANDS])
+		return NL_SKIP;
+
+	nla_for_each_nested(nl_band, tb_msg[NL80211_ATTR_WIPHY_BANDS], rem_band) {
+		mode = os_realloc_array(phy_info->modes,
+					*phy_info->num_modes + 1,
+					sizeof(*mode));
+		if (!mode)
+			return NL_SKIP;
+		phy_info->modes = mode;
+
+		mode_is_set = 0;
+
+		mode = &phy_info->modes[*(phy_info->num_modes)];
+		memset(mode, 0, sizeof(*mode));
+		mode->flags = HOSTAPD_MODE_FLAG_HT_INFO_KNOWN;
+		*(phy_info->num_modes) += 1;
+
+		nla_parse(tb_band, NL80211_BAND_ATTR_MAX, nla_data(nl_band),
+			  nla_len(nl_band), NULL);
+
+		if (tb_band[NL80211_BAND_ATTR_HT_CAPA]) {
+			mode->ht_capab = nla_get_u16(
+				tb_band[NL80211_BAND_ATTR_HT_CAPA]);
+		}
+
+		if (tb_band[NL80211_BAND_ATTR_HT_AMPDU_FACTOR]) {
+			mode->a_mpdu_params |= nla_get_u8(
+				tb_band[NL80211_BAND_ATTR_HT_AMPDU_FACTOR]) &
+				0x03;
+		}
+
+		if (tb_band[NL80211_BAND_ATTR_HT_AMPDU_DENSITY]) {
+			mode->a_mpdu_params |= nla_get_u8(
+				tb_band[NL80211_BAND_ATTR_HT_AMPDU_DENSITY]) <<
+				2;
+		}
+
+		if (tb_band[NL80211_BAND_ATTR_HT_MCS_SET] &&
+		    nla_len(tb_band[NL80211_BAND_ATTR_HT_MCS_SET])) {
+			u8 *mcs;
+			mcs = nla_data(tb_band[NL80211_BAND_ATTR_HT_MCS_SET]);
+			os_memcpy(mode->mcs_set, mcs, 16);
+		}
+
+		if (tb_band[NL80211_BAND_ATTR_VHT_CAPA]) {
+			mode->vht_capab = nla_get_u32(
+				tb_band[NL80211_BAND_ATTR_VHT_CAPA]);
+		}
+
+		if (tb_band[NL80211_BAND_ATTR_VHT_MCS_SET] &&
+		    nla_len(tb_band[NL80211_BAND_ATTR_VHT_MCS_SET])) {
+			u8 *mcs;
+			mcs = nla_data(tb_band[NL80211_BAND_ATTR_VHT_MCS_SET]);
+			os_memcpy(mode->vht_mcs_set, mcs, 8);
+		}
+
+		nla_for_each_nested(nl_freq, tb_band[NL80211_BAND_ATTR_FREQS], rem_freq) {
+			nla_parse(tb_freq, NL80211_FREQUENCY_ATTR_MAX, nla_data(nl_freq),
+				  nla_len(nl_freq), freq_policy);
+			if (!tb_freq[NL80211_FREQUENCY_ATTR_FREQ])
+				continue;
+			mode->num_channels++;
+		}
+
+		mode->channels = os_calloc(mode->num_channels,
+					   sizeof(struct hostapd_channel_data));
+		if (!mode->channels)
+			return NL_SKIP;
+
+		idx = 0;
+
+		nla_for_each_nested(nl_freq, tb_band[NL80211_BAND_ATTR_FREQS], rem_freq) {
+			nla_parse(tb_freq, NL80211_FREQUENCY_ATTR_MAX, nla_data(nl_freq),
+				  nla_len(nl_freq), freq_policy);
+			if (!tb_freq[NL80211_FREQUENCY_ATTR_FREQ])
+				continue;
+
+			mode->channels[idx].freq = nla_get_u32(tb_freq[NL80211_FREQUENCY_ATTR_FREQ]);
+			mode->channels[idx].flag = 0;
+
+			if (!mode_is_set) {
+				/* crude heuristic */
+				if (mode->channels[idx].freq < 4000)
+					mode->mode = HOSTAPD_MODE_IEEE80211B;
+				else if (mode->channels[idx].freq > 50000)
+					mode->mode = HOSTAPD_MODE_IEEE80211AD;
+				else
+					mode->mode = HOSTAPD_MODE_IEEE80211A;
+				mode_is_set = 1;
+			}
+
+			switch (mode->mode) {
+			case HOSTAPD_MODE_IEEE80211AD:
+				mode->channels[idx].chan =
+					(mode->channels[idx].freq - 56160) /
+					2160;
+				break;
+			case HOSTAPD_MODE_IEEE80211A:
+				mode->channels[idx].chan =
+					mode->channels[idx].freq / 5 - 1000;
+				break;
+			case HOSTAPD_MODE_IEEE80211B:
+			case HOSTAPD_MODE_IEEE80211G:
+				if (mode->channels[idx].freq == 2484)
+					mode->channels[idx].chan = 14;
+				else
+					mode->channels[idx].chan =
+						(mode->channels[idx].freq -
+						 2407) / 5;
+				break;
+			default:
+				break;
+			}
+
+			if (tb_freq[NL80211_FREQUENCY_ATTR_DISABLED])
+				mode->channels[idx].flag |=
+					HOSTAPD_CHAN_DISABLED;
+			if (tb_freq[NL80211_FREQUENCY_ATTR_PASSIVE_SCAN])
+				mode->channels[idx].flag |=
+					HOSTAPD_CHAN_PASSIVE_SCAN;
+			if (tb_freq[NL80211_FREQUENCY_ATTR_NO_IBSS])
+				mode->channels[idx].flag |=
+					HOSTAPD_CHAN_NO_IBSS;
+			if (tb_freq[NL80211_FREQUENCY_ATTR_RADAR])
+				mode->channels[idx].flag |=
+					HOSTAPD_CHAN_RADAR;
+
+			if (tb_freq[NL80211_FREQUENCY_ATTR_MAX_TX_POWER] &&
+			    !tb_freq[NL80211_FREQUENCY_ATTR_DISABLED])
+				mode->channels[idx].max_tx_power =
+					nla_get_u32(tb_freq[NL80211_FREQUENCY_ATTR_MAX_TX_POWER]) / 100;
+
+			idx++;
+		}
+
+		nla_for_each_nested(nl_rate, tb_band[NL80211_BAND_ATTR_RATES], rem_rate) {
+			nla_parse(tb_rate, NL80211_BITRATE_ATTR_MAX, nla_data(nl_rate),
+				  nla_len(nl_rate), rate_policy);
+			if (!tb_rate[NL80211_BITRATE_ATTR_RATE])
+				continue;
+			mode->num_rates++;
+		}
+
+		mode->rates = os_calloc(mode->num_rates, sizeof(int));
+		if (!mode->rates)
+			return NL_SKIP;
+
+		idx = 0;
+
+		nla_for_each_nested(nl_rate, tb_band[NL80211_BAND_ATTR_RATES], rem_rate) {
+			nla_parse(tb_rate, NL80211_BITRATE_ATTR_MAX, nla_data(nl_rate),
+				  nla_len(nl_rate), rate_policy);
+			if (!tb_rate[NL80211_BITRATE_ATTR_RATE])
+				continue;
+			mode->rates[idx] = nla_get_u32(tb_rate[NL80211_BITRATE_ATTR_RATE]);
+
+			/* crude heuristic */
+			if (mode->mode == HOSTAPD_MODE_IEEE80211B &&
+			    mode->rates[idx] > 200)
+				mode->mode = HOSTAPD_MODE_IEEE80211G;
+
+			idx++;
+		}
+	}
+
+	return NL_SKIP;
+}
+
+static struct hostapd_hw_modes *
+wpa_driver_capwap_add_11b(struct hostapd_hw_modes *modes, u16 *num_modes)
+{
+	u16 m;
+	struct hostapd_hw_modes *mode11g = NULL, *nmodes, *mode;
+	int i, mode11g_idx = -1;
+	int j;
+
+	/* If only 802.11g mode is included, use it to construct matching
+	 * 802.11b mode data. */
+
+	for (m = 0; m < *num_modes; m++) {
+		wpa_printf(MSG_DEBUG,"*** 2.2 %d\n",m);
+		if (modes[m].mode == HOSTAPD_MODE_IEEE80211B)
+			return modes; /* 802.11b already included */
+		if (modes[m].mode == HOSTAPD_MODE_IEEE80211G)
+			mode11g_idx = m;
+	}
+
+	if (mode11g_idx < 0)
+		return modes; /* 2.4 GHz band not supported at all */
+
+	nmodes = os_realloc_array(modes, *num_modes + 1, sizeof(*nmodes));
+	if (nmodes == NULL)
+		return modes; /* Could not add 802.11b mode */
+
+	mode = &nmodes[*num_modes];
+	os_memset(mode, 0, sizeof(*mode));
+	(*num_modes)++;
+	modes = nmodes;
+
+	mode->mode = HOSTAPD_MODE_IEEE80211B;
+
+	mode11g = &modes[mode11g_idx];
+	mode->num_channels = mode11g->num_channels;
+	mode->channels = os_malloc(mode11g->num_channels *
+				   sizeof(struct hostapd_channel_data));
+	if (mode->channels == NULL) {
+		(*num_modes)--;
+		return modes; /* Could not add 802.11b mode */
+	}
+	os_memcpy(mode->channels, mode11g->channels,
+		  mode11g->num_channels * sizeof(struct hostapd_channel_data));
+
+	mode->num_rates = 0;
+	mode->rates = os_malloc(4 * sizeof(int));
+	if (mode->rates == NULL) {
+		os_free(mode->channels);
+		(*num_modes)--;
+		return modes; /* Could not add 802.11b mode */
+	}
+
+	for (i = 0; i < mode11g->num_rates; i++) {
+		if (mode11g->rates[i] != 10 && mode11g->rates[i] != 20 &&
+		    mode11g->rates[i] != 55 && mode11g->rates[i] != 110)
+			continue;
+		mode->rates[mode->num_rates] = mode11g->rates[i];
+		mode->num_rates++;
+		if (mode->num_rates == 4)
+			break;
+	}
+
+	if (mode->num_rates == 0) {
+		os_free(mode->channels);
+		os_free(mode->rates);
+		(*num_modes)--;
+		return modes; /* No 802.11b rates */
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Added 802.11b mode based on 802.11g information");
+	wpa_printf(MSG_DEBUG,"*** Num_channels:%d Num_rates:%d capab:%d flags:%d MODE:%d mpdu:%02X",modes->num_channels,modes->num_rates,modes->ht_capab,modes->flags,modes->mode,modes->a_mpdu_params);
+
+	for(j=0;j < 16;j++){
+		wpa_printf(MSG_DEBUG,"%02X ",modes->mcs_set[j]);
+	}
+
+	for(j=0;j < modes->num_channels;j++){
+		wpa_printf(MSG_DEBUG,"*** %d freq:%d flag:%d chan:%d freq:%d maxPower:%02X ",j,modes->channels[j].freq,modes->channels[j].flag,modes->channels[j].chan,modes->channels[j].freq,modes->channels[j].max_tx_power);
+	}
+	for(j=0;j < modes->num_rates;j++){
+		wpa_printf(MSG_DEBUG,"*** %d rate:%d  ",j,modes->rates[j]);
+	}
+
+	return modes;
+}
+
+
+static void capwap_set_ht40_mode(struct hostapd_hw_modes *mode, int start,
+				  int end)
+{
+	int c;
+
+	for (c = 0; c < mode->num_channels; c++) {
+		struct hostapd_channel_data *chan = &mode->channels[c];
+		if (chan->freq - 10 >= start && chan->freq + 10 <= end)
+			chan->flag |= HOSTAPD_CHAN_HT40;
+	}
+}
+
+
+static void capwap_set_ht40_mode_sec(struct hostapd_hw_modes *mode, int start,
+				      int end)
+{
+	int c;
+
+	for (c = 0; c < mode->num_channels; c++) {
+		struct hostapd_channel_data *chan = &mode->channels[c];
+		if (!(chan->flag & HOSTAPD_CHAN_HT40))
+			continue;
+		if (chan->freq - 30 >= start && chan->freq - 10 <= end)
+			chan->flag |= HOSTAPD_CHAN_HT40MINUS;
+		if (chan->freq + 10 >= start && chan->freq + 30 <= end)
+			chan->flag |= HOSTAPD_CHAN_HT40PLUS;
+	}
+}
+
+
+static void capwap_reg_rule_ht40(struct nlattr *tb[],
+				  struct phy_info_arg *results)
+{
+	u32 start, end, max_bw;
+	u16 m;
+
+	if (tb[NL80211_ATTR_FREQ_RANGE_START] == NULL ||
+	    tb[NL80211_ATTR_FREQ_RANGE_END] == NULL ||
+	    tb[NL80211_ATTR_FREQ_RANGE_MAX_BW] == NULL)
+		return;
+
+	start = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]) / 1000;
+	end = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]) / 1000;
+	max_bw = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]) / 1000;
+
+	wpa_printf(MSG_DEBUG, "capwap: %u-%u @ %u MHz",
+		   start, end, max_bw);
+	if (max_bw < 40)
+		return;
+
+	for (m = 0; m < *results->num_modes; m++) {
+		if (!(results->modes[m].ht_capab &
+		      HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET))
+			continue;
+		capwap_set_ht40_mode(&results->modes[m], start, end);
+	}
+}
+
+
+static void capwap_reg_rule_sec(struct nlattr *tb[],
+				 struct phy_info_arg *results)
+{
+	u32 start, end, max_bw;
+	u16 m;
+
+	if (tb[NL80211_ATTR_FREQ_RANGE_START] == NULL ||
+	    tb[NL80211_ATTR_FREQ_RANGE_END] == NULL ||
+	    tb[NL80211_ATTR_FREQ_RANGE_MAX_BW] == NULL)
+		return;
+
+	start = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]) / 1000;
+	end = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]) / 1000;
+	max_bw = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]) / 1000;
+
+	if (max_bw < 20)
+		return;
+
+	for (m = 0; m < *results->num_modes; m++) {
+		if (!(results->modes[m].ht_capab &
+		      HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET))
+			continue;
+		capwap_set_ht40_mode_sec(&results->modes[m], start, end);
+	}
+}
+
+
+static int capwap_get_reg(struct nl_msg *msg, void *arg)
+{
+	struct phy_info_arg *results = arg;
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_rule;
+	struct nlattr *tb_rule[NL80211_FREQUENCY_ATTR_MAX + 1];
+	int rem_rule;
+	static struct nla_policy reg_policy[NL80211_FREQUENCY_ATTR_MAX + 1] = {
+		[NL80211_ATTR_REG_RULE_FLAGS] = { .type = NLA_U32 },
+		[NL80211_ATTR_FREQ_RANGE_START] = { .type = NLA_U32 },
+		[NL80211_ATTR_FREQ_RANGE_END] = { .type = NLA_U32 },
+		[NL80211_ATTR_FREQ_RANGE_MAX_BW] = { .type = NLA_U32 },
+		[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN] = { .type = NLA_U32 },
+		[NL80211_ATTR_POWER_RULE_MAX_EIRP] = { .type = NLA_U32 },
+	};
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	if (!tb_msg[NL80211_ATTR_REG_ALPHA2] ||
+	    !tb_msg[NL80211_ATTR_REG_RULES]) {
+		wpa_printf(MSG_DEBUG, "capwap: No regulatory information "
+			   "available");
+		return NL_SKIP;
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Regulatory information - country=%s",
+		   (char *) nla_data(tb_msg[NL80211_ATTR_REG_ALPHA2]));
+
+	nla_for_each_nested(nl_rule, tb_msg[NL80211_ATTR_REG_RULES], rem_rule)
+	{
+		nla_parse(tb_rule, NL80211_FREQUENCY_ATTR_MAX,
+			  nla_data(nl_rule), nla_len(nl_rule), reg_policy);
+		capwap_reg_rule_ht40(tb_rule, results);
+	}
+
+	nla_for_each_nested(nl_rule, tb_msg[NL80211_ATTR_REG_RULES], rem_rule)
+	{
+		nla_parse(tb_rule, NL80211_FREQUENCY_ATTR_MAX,
+			  nla_data(nl_rule), nla_len(nl_rule), reg_policy);
+		capwap_reg_rule_sec(tb_rule, results);
+	}
+
+	return NL_SKIP;
+}
+
+
+static int capwap_set_ht40_flags(struct wpa_driver_capwap_data *drv,
+				  struct phy_info_arg *results)
+{
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_GET_REG);
+	return send_and_recv_msgs(drv, msg, capwap_get_reg, results);
+}
+
+
+static struct hostapd_hw_modes *
+AC_wpa_driver_capwap_get_hw_feature_data(void *priv, u16 *num_modes, u16 *flags)
+{
+	int rate_arrays[8];
+	int num_rates;
+	int num_modes1;
+	int i;
+
+	num_rates = capability_get_rates(rate_arrays);
+	num_modes1 = capability_get_num_modes();
+
+	struct hostapd_hw_modes *mode;
+	int clen, rlen;
+	const short chan2freq[14] = {
+		2412, 2417, 2422, 2427, 2432, 2437, 2442,
+		2447, 2452, 2457, 2462, 2467, 2472, 2484
+        };
+
+
+	*flags = 0;
+	mode = os_zalloc(sizeof(struct hostapd_hw_modes));
+	if (mode == NULL)
+		return NULL;
+
+	*num_modes = 1;
+
+	if(capability_is_B()){
+		mode->mode = HOSTAPD_MODE_IEEE80211B;
+	}else{
+		wpa_printf(MSG_ERROR, "ERROR AC_wpa_driver_capwap_get_hw_feature_data\n");
+		exit(1);
+	}
+
+	mode->num_channels = capability_get_num_channels();
+	mode->num_rates = num_rates ;
+
+	clen = mode->num_channels * sizeof(struct hostapd_channel_data);
+	rlen = mode->num_rates * sizeof(int);
+
+	mode->channels = os_zalloc(clen);
+	mode->rates = os_zalloc(rlen);
+	if (mode->channels == NULL || mode->rates == NULL) {
+		os_free(mode->channels);
+		os_free(mode->rates);
+		os_free(mode);
+		return NULL;
+	}
+	for (i = 0; i < mode->num_channels; i++) {
+		mode->channels[i].chan = i + 1;
+		mode->channels[i].freq = chan2freq[i];
+		/* TODO: Get allowed channel list from the driver */
+		if (i >= 11)
+			mode->channels[i].flag = HOSTAPD_CHAN_DISABLED;
+	}
+
+	for( i=0; i<mode->num_rates ; i++){
+		if( rate_arrays[i] < 0 )
+			mode->rates[i] = -1 * rate_arrays[i];
+		else
+			mode->rates[i] =  rate_arrays[i];
+	}
+
+	return mode;
+
+}
+
+static struct hostapd_hw_modes *
+wpa_driver_capwap_get_hw_feature_data(void *priv, u16 *num_modes, u16 *flags) {
+	return AC_wpa_driver_capwap_get_hw_feature_data(priv,num_modes,flags);
+}
+
+
+static int wpa_driver_capwap_send_mntr(struct wpa_driver_capwap_data *drv,
+					const void *data, size_t len,
+					int encrypt, int noack)
+{
+
+	wpa_printf(MSG_DEBUG, "                                                                                 1.wpa_driver_capwap_send_frame ");
+	unsigned char buf[3000];
+
+	__u8 rtap_hdr[] = {
+		0x00, 0x00, /* radiotap version */
+		0x0e, 0x00, /* radiotap length */
+		0x02, 0xc0, 0x00, 0x00, /* bmap: flags, tx and rx flags */
+		IEEE80211_RADIOTAP_F_FRAG, /* F_FRAG (fragment if required) */
+		0x00,       /* padding */
+		0x00, 0x00, /* RX and TX flags to indicate that */
+		0x00, 0x00, /* this is the injected frame directly */
+	};
+	struct iovec iov[2] = {
+		{
+			.iov_base = &rtap_hdr,
+			.iov_len = sizeof(rtap_hdr),
+		},
+		{
+			.iov_base = (void *) data,
+			.iov_len = len,
+		}
+	};
+	struct msghdr msg = {
+		.msg_name = NULL,
+		.msg_namelen = 0,
+		.msg_iov = iov,
+		.msg_iovlen = 2,
+		.msg_control = NULL,
+		.msg_controllen = 0,
+		.msg_flags = 0,
+	};
+	int res;
+	u16 txflags = 0;
+
+	if (encrypt)
+		rtap_hdr[8] |= IEEE80211_RADIOTAP_F_WEP;
+
+	if (noack)
+		txflags |= IEEE80211_RADIOTAP_F_TX_NOACK;
+	WPA_PUT_LE16(&rtap_hdr[12], txflags);
+
+	memcpy(buf,(u8 *)(data),len);
+	//AC_handle_send_data_to_WTP(buf, len, generic_ac_info.own_mac_addr);
+
+	//Switch_Mac_Address_AC_to_WTP(buf, generic_ac_info.own_mac_addr);
+	ipc_send_80211_to_wtp(generic_ac_info.fd_ipc, buf, len);
+	
+	return 0;
+
+	res = sendmsg(drv->monitor_sock, &msg, 0);
+	if (res < 0) {
+		wpa_printf(MSG_INFO, "capwap: sendmsg: %s", strerror(errno));
+		return -1;
+	}
+	return 0;
+}
+
+
+static int wpa_driver_capwap_send_frame(struct i802_bss *bss,
+					 const void *data, size_t len,
+					 int encrypt, int noack,
+					 unsigned int freq, int no_cck,
+					 int offchanok, unsigned int wait_time)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	u64 cookie;
+
+	if (freq == 0)
+		freq = bss->freq;
+
+	if (drv->use_monitor)
+		return wpa_driver_capwap_send_mntr(drv, data, len,
+						    encrypt, noack);
+
+	return capwap_send_frame_cmd(bss, freq, wait_time, data, len,
+				      &cookie, no_cck, noack, offchanok);
+}
+
+
+static int wpa_driver_capwap_send_mlme(struct i802_bss *bss, const u8 *data,
+					size_t data_len, int noack,
+					unsigned int freq, int no_cck,
+					int offchanok,
+					unsigned int wait_time)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct ieee80211_mgmt *mgmt;
+	int encrypt = 1;
+	u16 fc;
+
+	mgmt = (struct ieee80211_mgmt *) data;
+	fc = le_to_host16(mgmt->frame_control);
+
+	if (is_sta_interface(drv->nlmode) &&
+	    WLAN_FC_GET_TYPE(fc) == WLAN_FC_TYPE_MGMT &&
+	    WLAN_FC_GET_STYPE(fc) == WLAN_FC_STYPE_PROBE_RESP) {
+		/*
+		 * The use of last_mgmt_freq is a bit of a hack,
+		 * but it works due to the single-threaded nature
+		 * of wpa_supplicant.
+		 */
+		if (freq == 0)
+			freq = drv->last_mgmt_freq;
+		return capwap_send_frame_cmd(bss, freq, 0,
+					      data, data_len, NULL, 1, noack,
+					      1);
+	}
+
+	if (drv->device_ap_sme && is_ap_interface(drv->nlmode)) {
+		if (freq == 0)
+			freq = bss->freq;
+		return capwap_send_frame_cmd(bss, freq,
+					      (int) freq == bss->freq ? 0 :
+					      wait_time,
+					      data, data_len,
+					      &drv->send_action_cookie,
+					      no_cck, noack, offchanok);
+	}
+
+	if (WLAN_FC_GET_TYPE(fc) == WLAN_FC_TYPE_MGMT &&
+	    WLAN_FC_GET_STYPE(fc) == WLAN_FC_STYPE_AUTH) {
+		/*
+		 * Only one of the authentication frame types is encrypted.
+		 * In order for static WEP encryption to work properly (i.e.,
+		 * to not encrypt the frame), we need to tell mac80211 about
+		 * the frames that must not be encrypted.
+		 */
+		u16 auth_alg = le_to_host16(mgmt->u.auth.auth_alg);
+		u16 auth_trans = le_to_host16(mgmt->u.auth.auth_transaction);
+		if (auth_alg != WLAN_AUTH_SHARED_KEY || auth_trans != 3)
+			encrypt = 0;
+	}
+
+	return wpa_driver_capwap_send_frame(bss, data, data_len, encrypt,
+					     noack, freq, no_cck, offchanok,
+					     wait_time);
+}
+
+
+int round1=0;
+
+static int capwap_set_bss(struct i802_bss *bss, int cts, int preamble,
+			   int slot, int ht_opmode, int ap_isolate,
+			   int *basic_rates)
+{
+	wpa_printf(MSG_DEBUG,"> capwap_set_bss\n");
+	if(round1)return 0;
+	else round1=1;
+
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_BSS);
+
+	if (cts >= 0)
+		NLA_PUT_U8(msg, NL80211_ATTR_BSS_CTS_PROT, cts);
+	if (preamble >= 0)
+		NLA_PUT_U8(msg, NL80211_ATTR_BSS_SHORT_PREAMBLE, preamble);
+	if (slot >= 0)
+		NLA_PUT_U8(msg, NL80211_ATTR_BSS_SHORT_SLOT_TIME, slot);
+	if (ht_opmode >= 0)
+		NLA_PUT_U16(msg, NL80211_ATTR_BSS_HT_OPMODE, ht_opmode);
+	if (ap_isolate >= 0)
+		NLA_PUT_U8(msg, NL80211_ATTR_AP_ISOLATE, ap_isolate);
+
+	if (basic_rates) {
+		u8 rates[NL80211_MAX_SUPP_RATES];
+		u8 rates_len = 0;
+		int i;
+
+		for (i = 0; i < NL80211_MAX_SUPP_RATES && basic_rates[i] >= 0;
+		     i++)
+			rates[rates_len++] = basic_rates[i] / 5;
+
+		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, rates_len, rates);
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(bss->ifname));
+
+	return send_and_recv_msgs(drv, msg, NULL, NULL);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int wpa_driver_capwap_set_ap(void *priv,
+				     struct wpa_driver_ap_params *params)
+{
+	wpa_printf(MSG_DEBUG, "> wpa_driver_capwap_set_ap \n");
+ 	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	u8 cmd = NL80211_CMD_NEW_BEACON;
+	int ret;
+	int beacon_set;
+	int ifindex = if_nametoindex(bss->ifname);
+	int num_suites;
+	u32 suites[10];
+	u32 ver;
+
+	beacon_set = bss->beacon_set;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	wpa_printf(MSG_DEBUG, "capwap: Set beacon (beacon_set=%d)",
+		   beacon_set);
+	if (beacon_set)
+		cmd = NL80211_CMD_SET_BEACON;
+
+	capwap_cmd(drv, msg, 0, cmd);
+	NLA_PUT(msg, NL80211_ATTR_BEACON_HEAD, params->head_len, params->head);
+	NLA_PUT(msg, NL80211_ATTR_BEACON_TAIL, params->tail_len, params->tail);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL, params->beacon_int);
+	NLA_PUT_U32(msg, NL80211_ATTR_DTIM_PERIOD, params->dtim_period);
+	NLA_PUT(msg, NL80211_ATTR_SSID, params->ssid_len,
+		params->ssid);
+	if (params->proberesp && params->proberesp_len)
+		NLA_PUT(msg, NL80211_ATTR_PROBE_RESP, params->proberesp_len,
+			params->proberesp);
+	switch (params->hide_ssid) {
+	case NO_SSID_HIDING:
+		NLA_PUT_U32(msg, NL80211_ATTR_HIDDEN_SSID,
+			    NL80211_HIDDEN_SSID_NOT_IN_USE);
+		break;
+	case HIDDEN_SSID_ZERO_LEN:
+		NLA_PUT_U32(msg, NL80211_ATTR_HIDDEN_SSID,
+			    NL80211_HIDDEN_SSID_ZERO_LEN);
+		break;
+	case HIDDEN_SSID_ZERO_CONTENTS:
+		NLA_PUT_U32(msg, NL80211_ATTR_HIDDEN_SSID,
+			    NL80211_HIDDEN_SSID_ZERO_CONTENTS);
+		break;
+	}
+	if (params->privacy)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_PRIVACY);
+	if ((params->auth_algs & (WPA_AUTH_ALG_OPEN | WPA_AUTH_ALG_SHARED)) ==
+	    (WPA_AUTH_ALG_OPEN | WPA_AUTH_ALG_SHARED)) {
+		/* Leave out the attribute */
+	} else if (params->auth_algs & WPA_AUTH_ALG_SHARED)
+		NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE,
+			    NL80211_AUTHTYPE_SHARED_KEY);
+	else
+		NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE,
+			    NL80211_AUTHTYPE_OPEN_SYSTEM);
+
+	ver = 0;
+	if (params->wpa_version & WPA_PROTO_WPA)
+		ver |= NL80211_WPA_VERSION_1;
+	if (params->wpa_version & WPA_PROTO_RSN)
+		ver |= NL80211_WPA_VERSION_2;
+	if (ver)
+		NLA_PUT_U32(msg, NL80211_ATTR_WPA_VERSIONS, ver);
+
+	num_suites = 0;
+	if (params->key_mgmt_suites & WPA_KEY_MGMT_IEEE8021X)
+		suites[num_suites++] = WLAN_AKM_SUITE_8021X;
+	if (params->key_mgmt_suites & WPA_KEY_MGMT_PSK)
+		suites[num_suites++] = WLAN_AKM_SUITE_PSK;
+	if (num_suites) {
+		NLA_PUT(msg, NL80211_ATTR_AKM_SUITES,
+			num_suites * sizeof(u32), suites);
+	}
+
+	if (params->key_mgmt_suites & WPA_KEY_MGMT_IEEE8021X &&
+	    params->pairwise_ciphers & (WPA_CIPHER_WEP104 | WPA_CIPHER_WEP40))
+		NLA_PUT_FLAG(msg, NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT);
+
+	num_suites = 0;
+	if (params->pairwise_ciphers & WPA_CIPHER_CCMP)
+		suites[num_suites++] = WLAN_CIPHER_SUITE_CCMP;
+	if (params->pairwise_ciphers & WPA_CIPHER_GCMP)
+		suites[num_suites++] = WLAN_CIPHER_SUITE_GCMP;
+	if (params->pairwise_ciphers & WPA_CIPHER_TKIP)
+		suites[num_suites++] = WLAN_CIPHER_SUITE_TKIP;
+	if (params->pairwise_ciphers & WPA_CIPHER_WEP104)
+		suites[num_suites++] = WLAN_CIPHER_SUITE_WEP104;
+	if (params->pairwise_ciphers & WPA_CIPHER_WEP40)
+		suites[num_suites++] = WLAN_CIPHER_SUITE_WEP40;
+	if (num_suites) {
+		NLA_PUT(msg, NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
+			num_suites * sizeof(u32), suites);
+	}
+
+	switch (params->group_cipher) {
+	case WPA_CIPHER_CCMP:
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP,
+			    WLAN_CIPHER_SUITE_CCMP);
+		break;
+	case WPA_CIPHER_GCMP:
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP,
+			    WLAN_CIPHER_SUITE_GCMP);
+		break;
+	case WPA_CIPHER_TKIP:
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP,
+			    WLAN_CIPHER_SUITE_TKIP);
+		break;
+	case WPA_CIPHER_WEP104:
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP,
+			    WLAN_CIPHER_SUITE_WEP104);
+		break;
+	case WPA_CIPHER_WEP40:
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP,
+			    WLAN_CIPHER_SUITE_WEP40);
+		break;
+	}
+
+	if (params->beacon_ies) {
+		NLA_PUT(msg, NL80211_ATTR_IE, wpabuf_len(params->beacon_ies),
+			wpabuf_head(params->beacon_ies));
+	}
+	if (params->proberesp_ies) {
+		NLA_PUT(msg, NL80211_ATTR_IE_PROBE_RESP,
+			wpabuf_len(params->proberesp_ies),
+			wpabuf_head(params->proberesp_ies));
+	}
+	if (params->assocresp_ies) {
+		NLA_PUT(msg, NL80211_ATTR_IE_ASSOC_RESP,
+			wpabuf_len(params->assocresp_ies),
+			wpabuf_head(params->assocresp_ies));
+	}
+
+	if (drv->capa.flags & WPA_DRIVER_FLAGS_INACTIVITY_TIMER)  {
+		NLA_PUT_U16(msg, NL80211_ATTR_INACTIVITY_TIMEOUT,
+			    params->ap_max_inactivity);
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Beacon set failed: %d (%s)",
+			   ret, strerror(-ret));
+	} else {
+		bss->beacon_set = 1;
+		capwap_set_bss(bss, params->cts_protect, params->preamble,
+				params->short_slot_time, params->ht_opmode,
+				params->isolate, params->basic_rates);
+	}
+
+	wpa_printf(MSG_DEBUG, "=== (P) privacy: %d\n",params->privacy);
+	wpa_printf(MSG_DEBUG, "=== (T) short_slot_time: %d\n",params->short_slot_time);
+	wpa_printf(MSG_DEBUG, "=== (S) preamble: %d\n",params->preamble);
+
+	prep_beacon(generic_ac_info.fd_ipc,drv->ctx,params);
+
+	//ipc_send_ADD_WLAN(generic_ac_info.fd_ipc, params->ssid, params->ssid_len);
+
+	return ret;
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int wpa_driver_capwap_set_freq(struct i802_bss *bss,
+				       struct hostapd_freq_params *freq)
+{
+	wpa_printf(MSG_DEBUG,"                                          1.wpa_driver_capwap_set_freq\n");
+	return 0;
+}
+
+
+static u32 sta_flags_capwap(int flags)
+{
+	u32 f = 0;
+
+	if (flags & WPA_STA_AUTHORIZED)
+		f |= BIT(NL80211_STA_FLAG_AUTHORIZED);
+	if (flags & WPA_STA_WMM)
+		f |= BIT(NL80211_STA_FLAG_WME);
+	if (flags & WPA_STA_SHORT_PREAMBLE)
+		f |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);
+	if (flags & WPA_STA_MFP)
+		f |= BIT(NL80211_STA_FLAG_MFP);
+	if (flags & WPA_STA_TDLS_PEER)
+		f |= BIT(NL80211_STA_FLAG_TDLS_PEER);
+
+	return f;
+}
+
+
+static int wpa_driver_capwap_sta_add(void *priv,
+				      struct hostapd_sta_add_params *params)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg, *wme = NULL;
+	struct nl80211_sta_flag_update upd;
+	int ret = -ENOBUFS;
+
+	if ((params->flags & WPA_STA_TDLS_PEER) &&
+	    !(drv->capa.flags & WPA_DRIVER_FLAGS_TDLS_SUPPORT))
+		return -EOPNOTSUPP;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	wpa_printf(MSG_DEBUG, "capwap: %s STA " MACSTR,
+		   params->set ? "Set" : "Add", MAC2STR(params->addr));
+	capwap_cmd(drv, msg, 0, params->set ? NL80211_CMD_SET_STATION :
+		    NL80211_CMD_NEW_STATION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(bss->ifname));
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, params->addr);
+	NLA_PUT(msg, NL80211_ATTR_STA_SUPPORTED_RATES, params->supp_rates_len,
+		params->supp_rates);
+	wpa_hexdump(MSG_DEBUG, "  * supported rates", params->supp_rates,
+		    params->supp_rates_len);
+	if (!params->set) {
+		wpa_printf(MSG_DEBUG, "  * aid=%u", params->aid);
+		NLA_PUT_U16(msg, NL80211_ATTR_STA_AID, params->aid);
+		wpa_printf(MSG_DEBUG, "  * listen_interval=%u",
+			   params->listen_interval);
+		NLA_PUT_U16(msg, NL80211_ATTR_STA_LISTEN_INTERVAL,
+			    params->listen_interval);
+	}
+	if (params->ht_capabilities) {
+		wpa_hexdump(MSG_DEBUG, "  * ht_capabilities",
+			    (u8 *) params->ht_capabilities,
+			    sizeof(*params->ht_capabilities));
+		NLA_PUT(msg, NL80211_ATTR_HT_CAPABILITY,
+			sizeof(*params->ht_capabilities),
+			params->ht_capabilities);
+	}
+
+	if (params->vht_capabilities) {
+		wpa_hexdump(MSG_DEBUG, "  * vht_capabilities",
+			    (u8 *) params->vht_capabilities,
+			    sizeof(*params->vht_capabilities));
+		NLA_PUT(msg, NL80211_ATTR_VHT_CAPABILITY,
+			sizeof(*params->vht_capabilities),
+			params->vht_capabilities);
+	}
+
+	wpa_printf(MSG_DEBUG, "  * capability=0x%x", params->capability);
+	NLA_PUT_U16(msg, NL80211_ATTR_STA_CAPABILITY, params->capability);
+
+	if (params->ext_capab) {
+		wpa_hexdump(MSG_DEBUG, "  * ext_capab",
+			    params->ext_capab, params->ext_capab_len);
+		NLA_PUT(msg, NL80211_ATTR_STA_EXT_CAPABILITY,
+			params->ext_capab_len, params->ext_capab);
+	}
+
+	os_memset(&upd, 0, sizeof(upd));
+	upd.mask = sta_flags_capwap(params->flags);
+	upd.set = upd.mask;
+	wpa_printf(MSG_DEBUG, "  * flags set=0x%x mask=0x%x",
+		   upd.set, upd.mask);
+	NLA_PUT(msg, NL80211_ATTR_STA_FLAGS2, sizeof(upd), &upd);
+
+	if (params->flags & WPA_STA_WMM) {
+		wme = nlmsg_alloc();
+		if (!wme)
+			goto nla_put_failure;
+
+		wpa_printf(MSG_DEBUG, "  * qosinfo=0x%x", params->qosinfo);
+		NLA_PUT_U8(wme, NL80211_STA_WME_UAPSD_QUEUES,
+				params->qosinfo & WMM_QOSINFO_STA_AC_MASK);
+		NLA_PUT_U8(wme, NL80211_STA_WME_MAX_SP,
+				(params->qosinfo >> WMM_QOSINFO_STA_SP_SHIFT) &
+				WMM_QOSINFO_STA_SP_MASK);
+		if (nla_put_nested(msg, NL80211_ATTR_STA_WME, wme) < 0)
+			goto nla_put_failure;
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret)
+		wpa_printf(MSG_DEBUG, "capwap: NL80211_CMD_%s_STATION "
+			   "result: %d (%s)", params->set ? "SET" : "NEW", ret,
+			   strerror(-ret));
+	if (ret == -EEXIST)
+		ret = 0;
+ nla_put_failure:
+	nlmsg_free(wme);
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wpa_driver_capwap_sta_remove(struct i802_bss *bss, const u8 *addr)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_DEL_STATION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX,
+		    if_nametoindex(bss->ifname));
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	if (ret == -ENOENT)
+		return 0;
+	return ret;
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static void capwap_remove_iface(struct wpa_driver_capwap_data *drv,
+				 int ifidx)
+{
+	struct nl_msg *msg;
+
+	wpa_printf(MSG_DEBUG, "capwap: Remove interface ifindex=%d", ifidx);
+
+	/* stop listening for EAPOL on this interface */
+	del_ifidx(drv, ifidx);
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		goto nla_put_failure;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_DEL_INTERFACE);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifidx);
+
+	if (send_and_recv_msgs(drv, msg, NULL, NULL) == 0)
+		return;
+	msg = NULL;
+ nla_put_failure:
+	nlmsg_free(msg);
+	wpa_printf(MSG_ERROR, "Failed to remove interface (ifidx=%d)", ifidx);
+}
+
+
+static const char * capwap_iftype_str(enum nl80211_iftype mode)
+{
+	switch (mode) {
+	case NL80211_IFTYPE_ADHOC:
+		return "ADHOC";
+	case NL80211_IFTYPE_STATION:
+		return "STATION";
+	case NL80211_IFTYPE_AP:
+		return "AP";
+	case NL80211_IFTYPE_MONITOR:
+		return "MONITOR";
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return "P2P_CLIENT";
+	case NL80211_IFTYPE_P2P_GO:
+		return "P2P_GO";
+	default:
+		return "unknown";
+	}
+}
+
+
+static int capwap_create_iface_once(struct wpa_driver_capwap_data *drv,
+				     const char *ifname,
+				     enum nl80211_iftype iftype,
+				     const u8 *addr, int wds)
+{
+	wpa_printf(MSG_DEBUG, "# capwap_create_iface_once\n");
+	struct nl_msg *msg, *flags = NULL;
+	int ifidx;
+	int ret = -ENOBUFS;
+
+	wpa_printf(MSG_DEBUG, "capwap: Create interface iftype %d (%s)",
+		   iftype, capwap_iftype_str(iftype));
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_NEW_INTERFACE);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, ifname);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, iftype);
+
+	if (iftype == NL80211_IFTYPE_MONITOR) {
+		int err;
+
+		flags = nlmsg_alloc();
+		if (!flags)
+			goto nla_put_failure;
+
+		NLA_PUT_FLAG(flags, NL80211_MNTR_FLAG_COOK_FRAMES);
+
+		err = nla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);
+
+		nlmsg_free(flags);
+
+		if (err)
+			goto nla_put_failure;
+	} else if (wds) {
+		NLA_PUT_U8(msg, NL80211_ATTR_4ADDR, wds);
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+ nla_put_failure:
+		nlmsg_free(msg);
+		wpa_printf(MSG_ERROR, "Failed to create interface %s: %d (%s)",
+			   ifname, ret, strerror(-ret));
+		return ret;
+	}
+
+	ifidx = if_nametoindex(ifname);
+	wpa_printf(MSG_DEBUG, "capwap: New interface %s created: ifindex=%d",
+		   ifname, ifidx);
+
+	/* start listening for EAPOL on this interface */
+ 	wpa_printf(MSG_DEBUG, "start listening for EAPOL on this interface\n");	
+	add_ifidx(drv, ifidx);
+
+	if (addr && iftype != NL80211_IFTYPE_MONITOR &&
+	    linux_set_fake_ifhwaddr(drv->global->ioctl_sock, ifname, addr)) {
+		capwap_remove_iface(drv, ifidx);
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "#9 %d\n",ifidx);
+
+	return ifidx;
+}
+
+
+static int capwap_create_iface(struct wpa_driver_capwap_data *drv,
+				const char *ifname, enum nl80211_iftype iftype,
+				const u8 *addr, int wds)
+{
+	int ret;
+
+	ret = capwap_create_iface_once(drv, ifname, iftype, addr, wds);
+
+	/* if error occurred and interface exists already */
+	if (ret == -ENFILE && if_nametoindex(ifname)) {
+		wpa_printf(MSG_INFO, "Try to remove and re-create %s", ifname);
+
+		/* Try to remove the interface that was already there. */
+		capwap_remove_iface(drv, if_nametoindex(ifname));
+
+		/* Try to create the interface again */
+		ret = capwap_create_iface_once(drv, ifname, iftype, addr,
+						wds);
+	}
+
+	if (ret >= 0 && is_p2p_interface(iftype))
+		capwap_disable_11b_rates(drv, ret, 1);
+
+	return ret;
+}
+
+
+static void handle_tx_callback(void *ctx, u8 *buf, size_t len, int ok)
+{
+	struct ieee80211_hdr *hdr;
+	u16 fc;
+	union wpa_event_data event;
+
+	hdr = (struct ieee80211_hdr *) buf;
+	fc = le_to_host16(hdr->frame_control);
+
+	os_memset(&event, 0, sizeof(event));
+	event.tx_status.type = WLAN_FC_GET_TYPE(fc);
+	event.tx_status.stype = WLAN_FC_GET_STYPE(fc);
+	event.tx_status.dst = hdr->addr1;
+	event.tx_status.data = buf;
+	event.tx_status.data_len = len;
+	event.tx_status.ack = ok;
+	wpa_supplicant_event(ctx, EVENT_TX_STATUS, &event);
+}
+
+
+static void from_unknown_sta(struct wpa_driver_capwap_data *drv,
+			     u8 *buf, size_t len)
+{
+	struct ieee80211_hdr *hdr = (void *)buf;
+	u16 fc;
+	union wpa_event_data event;
+
+	if (len < sizeof(*hdr))
+		return;
+
+	fc = le_to_host16(hdr->frame_control);
+
+	os_memset(&event, 0, sizeof(event));
+	event.rx_from_unknown.bssid = get_hdr_bssid(hdr, len);
+	event.rx_from_unknown.addr = hdr->addr2;
+	event.rx_from_unknown.wds = (fc & (WLAN_FC_FROMDS | WLAN_FC_TODS)) ==
+		(WLAN_FC_FROMDS | WLAN_FC_TODS);
+	wpa_supplicant_event(drv->ctx, EVENT_RX_FROM_UNKNOWN, &event);
+}
+
+
+static void handle_frame(struct wpa_driver_capwap_data *drv,
+			 u8 *buf, size_t len, int datarate, int ssi_signal)
+{
+	struct ieee80211_hdr *hdr;
+	u16 fc;
+	union wpa_event_data event;
+
+	hdr = (struct ieee80211_hdr *) buf;
+	fc = le_to_host16(hdr->frame_control);
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case WLAN_FC_TYPE_MGMT:
+		os_memset(&event, 0, sizeof(event));
+		event.rx_mgmt.frame = buf;
+		event.rx_mgmt.frame_len = len;
+		event.rx_mgmt.datarate = datarate;
+		event.rx_mgmt.ssi_signal = ssi_signal;
+		wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
+		break;
+	case WLAN_FC_TYPE_CTRL:
+		/* can only get here with PS-Poll frames */
+		wpa_printf(MSG_DEBUG, "CTRL");
+		from_unknown_sta(drv, buf, len);
+		break;
+	case WLAN_FC_TYPE_DATA:
+		from_unknown_sta(drv, buf, len);
+		break;
+	}
+}
+
+
+static void handle_monitor_read(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	struct wpa_driver_capwap_data *drv = eloop_ctx;
+	int len;
+	unsigned char buf[3000];
+	struct ieee80211_radiotap_iterator iter;
+	int ret;
+	int datarate = 0, ssi_signal = 0;
+	int injected = 0, failed = 0, rxflags = 0;
+	len = recv(sock, buf, sizeof(buf), 0);
+
+	if (len < 0) {
+		perror("recv");
+		return;
+	}
+
+	if (ieee80211_radiotap_iterator_init(&iter, (void*)buf, len)) {
+		wpa_printf(MSG_DEBUG, "received invalid radiotap frame\n");
+		return;
+	}
+
+	while (1) {
+		ret = ieee80211_radiotap_iterator_next(&iter);
+		if (ret == -ENOENT)
+			break;
+		if (ret) {
+			wpa_printf(MSG_DEBUG, "received invalid radiotap frame (%d)\n", ret);
+			return;
+		}
+		switch (iter.this_arg_index) {
+		case IEEE80211_RADIOTAP_FLAGS:
+			if (*iter.this_arg & IEEE80211_RADIOTAP_F_FCS)
+				len -= 4;
+			break;
+		case IEEE80211_RADIOTAP_RX_FLAGS:
+			rxflags = 1;
+			break;
+		case IEEE80211_RADIOTAP_TX_FLAGS:
+			injected = 1;
+			failed = le_to_host16((*(uint16_t *) iter.this_arg)) &
+					IEEE80211_RADIOTAP_F_TX_FAIL;
+			break;
+		case IEEE80211_RADIOTAP_DATA_RETRIES:
+			break;
+		case IEEE80211_RADIOTAP_CHANNEL:
+			/* TODO: convert from freq/flags to channel number */
+			break;
+		case IEEE80211_RADIOTAP_RATE:
+			datarate = *iter.this_arg * 5;
+			break;
+		case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:
+			ssi_signal = (s8) *iter.this_arg;
+			break;
+		}
+	}
+
+	if (rxflags && injected)
+		return;
+
+	if (!injected)
+		handle_frame(drv, buf + iter.max_length,
+			     len - iter.max_length, datarate, ssi_signal);
+	else
+		handle_tx_callback(drv->ctx, buf + iter.max_length,
+				   len - iter.max_length, !failed);
+}
+
+
+/*
+ * we post-process the filter code later and rewrite
+ * this to the offset to the last instruction
+ */
+#define PASS	0xFF
+#define FAIL	0xFE
+
+static struct sock_filter msock_filter_insns[] = {
+	/*
+	 * do a little-endian load of the radiotap length field
+	 */
+	/* load lower byte into A */
+	BPF_STMT(BPF_LD  | BPF_B | BPF_ABS, 2),
+	/* put it into X (== index register) */
+	BPF_STMT(BPF_MISC| BPF_TAX, 0),
+	/* load upper byte into A */
+	BPF_STMT(BPF_LD  | BPF_B | BPF_ABS, 3),
+	/* left-shift it by 8 */
+	BPF_STMT(BPF_ALU | BPF_LSH | BPF_K, 8),
+	/* or with X */
+	BPF_STMT(BPF_ALU | BPF_OR | BPF_X, 0),
+	/* put result into X */
+	BPF_STMT(BPF_MISC| BPF_TAX, 0),
+
+	/*
+	 * Allow management frames through, this also gives us those
+	 * management frames that we sent ourselves with status
+	 */
+	/* load the lower byte of the IEEE 802.11 frame control field */
+	BPF_STMT(BPF_LD  | BPF_B | BPF_IND, 0),
+	/* mask off frame type and version */
+	BPF_STMT(BPF_ALU | BPF_AND | BPF_K, 0xF),
+	/* accept frame if it's both 0, fall through otherwise */
+	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0, PASS, 0),
+
+	/*
+	 * TODO: add a bit to radiotap RX flags that indicates
+	 * that the sending station is not associated, then
+	 * add a filter here that filters on our DA and that flag
+	 * to allow us to deauth frames to that bad station.
+	 *
+	 * For now allow all To DS data frames through.
+	 */
+	/* load the IEEE 802.11 frame control field */
+	BPF_STMT(BPF_LD  | BPF_H | BPF_IND, 0),
+	/* mask off frame type, version and DS status */
+	BPF_STMT(BPF_ALU | BPF_AND | BPF_K, 0x0F03),
+	/* accept frame if version 0, type 2 and To DS, fall through otherwise
+	 */
+	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0x0801, PASS, 0),
+
+#if 0
+	/*
+	 * drop non-data frames
+	 */
+	/* load the lower byte of the frame control field */
+	BPF_STMT(BPF_LD   | BPF_B | BPF_IND, 0),
+	/* mask off QoS bit */
+	BPF_STMT(BPF_ALU  | BPF_AND | BPF_K, 0x0c),
+	/* drop non-data frames */
+	BPF_JUMP(BPF_JMP  | BPF_JEQ | BPF_K, 8, 0, FAIL),
+#endif
+	/* load the upper byte of the frame control field */
+	BPF_STMT(BPF_LD   | BPF_B | BPF_IND, 1),
+	/* mask off toDS/fromDS */
+	BPF_STMT(BPF_ALU  | BPF_AND | BPF_K, 0x03),
+	/* accept WDS frames */
+	BPF_JUMP(BPF_JMP  | BPF_JEQ | BPF_K, 3, PASS, 0),
+
+	/*
+	 * add header length to index
+	 */
+	/* load the lower byte of the frame control field */
+	BPF_STMT(BPF_LD   | BPF_B | BPF_IND, 0),
+	/* mask off QoS bit */
+	BPF_STMT(BPF_ALU  | BPF_AND | BPF_K, 0x80),
+	/* right shift it by 6 to give 0 or 2 */
+	BPF_STMT(BPF_ALU  | BPF_RSH | BPF_K, 6),
+	/* add data frame header length */
+	BPF_STMT(BPF_ALU  | BPF_ADD | BPF_K, 24),
+	/* add index, was start of 802.11 header */
+	BPF_STMT(BPF_ALU  | BPF_ADD | BPF_X, 0),
+	/* move to index, now start of LL header */
+	BPF_STMT(BPF_MISC | BPF_TAX, 0),
+
+	/*
+	 * Accept empty data frames, we use those for
+	 * polling activity.
+	 */
+	BPF_STMT(BPF_LD  | BPF_W | BPF_LEN, 0),
+	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_X, 0, PASS, 0),
+
+	/*
+	 * Accept EAPOL frames
+	 */
+	BPF_STMT(BPF_LD  | BPF_W | BPF_IND, 0),
+	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0xAAAA0300, 0, FAIL),
+	BPF_STMT(BPF_LD  | BPF_W | BPF_IND, 4),
+	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0x0000888E, PASS, FAIL),
+
+	/* keep these last two statements or change the code below */
+	/* return 0 == "DROP" */
+	BPF_STMT(BPF_RET | BPF_K, 0),
+	/* return ~0 == "keep all" */
+	BPF_STMT(BPF_RET | BPF_K, ~0),
+};
+
+static struct sock_fprog msock_filter = {
+	.len = sizeof(msock_filter_insns)/sizeof(msock_filter_insns[0]),
+	.filter = msock_filter_insns,
+};
+
+
+static int add_monitor_filter(int s)
+{
+	int idx;
+
+	/* rewrite all PASS/FAIL jump offsets */
+	for (idx = 0; idx < msock_filter.len; idx++) {
+		struct sock_filter *insn = &msock_filter_insns[idx];
+
+		if (BPF_CLASS(insn->code) == BPF_JMP) {
+			if (insn->code == (BPF_JMP|BPF_JA)) {
+				if (insn->k == PASS)
+					insn->k = msock_filter.len - idx - 2;
+				else if (insn->k == FAIL)
+					insn->k = msock_filter.len - idx - 3;
+			}
+
+			if (insn->jt == PASS)
+				insn->jt = msock_filter.len - idx - 2;
+			else if (insn->jt == FAIL)
+				insn->jt = msock_filter.len - idx - 3;
+
+			if (insn->jf == PASS)
+				insn->jf = msock_filter.len - idx - 2;
+			else if (insn->jf == FAIL)
+				insn->jf = msock_filter.len - idx - 3;
+		}
+	}
+
+	if (setsockopt(s, SOL_SOCKET, SO_ATTACH_FILTER,
+		       &msock_filter, sizeof(msock_filter))) {
+		perror("SO_ATTACH_FILTER");
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static void capwap_remove_monitor_interface(
+	struct wpa_driver_capwap_data *drv)
+{
+	return;
+	drv->monitor_refcount--;
+	if (drv->monitor_refcount > 0)
+		return;
+
+	if (drv->monitor_ifidx >= 0) {
+		capwap_remove_iface(drv, drv->monitor_ifidx);
+		drv->monitor_ifidx = -1;
+	}
+	if (drv->monitor_sock >= 0) {
+		eloop_unregister_read_sock(drv->monitor_sock);
+		close(drv->monitor_sock);
+		drv->monitor_sock = -1;
+	}
+}
+
+
+static int
+capwap_create_monitor_interface(struct wpa_driver_capwap_data *drv)
+{
+	wpa_printf(MSG_DEBUG, "8.5   capwap_create_monitor_interface\n");
+	char buf[IFNAMSIZ];
+	struct sockaddr_ll ll;
+	int optval;
+	socklen_t optlen;
+
+	if (drv->monitor_ifidx >= 0) {
+		drv->monitor_refcount++;
+		return 0;
+	}
+
+	if (os_strncmp(drv->first_bss.ifname, "p2p-", 4) == 0) {
+		/*
+		 * P2P interface name is of the format p2p-%s-%d. For monitor
+		 * interface name corresponding to P2P GO, replace "p2p-" with
+		 * "mon-" to retain the same interface name length and to
+		 * indicate that it is a monitor interface.
+		 */
+		snprintf(buf, IFNAMSIZ, "mon-%s", drv->first_bss.ifname + 4);
+	} else {
+		/* Non-P2P interface with AP functionality. */
+		snprintf(buf, IFNAMSIZ, "mon.%s", drv->first_bss.ifname);
+	}
+
+	buf[IFNAMSIZ - 1] = '\0';
+
+	drv->monitor_ifidx =
+		capwap_create_iface(drv, buf, NL80211_IFTYPE_MONITOR, NULL,
+				     0);
+
+	if (drv->monitor_ifidx == -EOPNOTSUPP) {
+		/*
+		 * This is backward compatibility for a few versions of
+		 * the kernel only that didn't advertise the right
+		 * attributes for the only driver that then supported
+		 * AP mode w/o monitor -- ath6kl.
+		 */
+		wpa_printf(MSG_DEBUG, "capwap: Driver does not support "
+			   "monitor interface type - try to run without it");
+		drv->device_ap_sme = 1;
+	}
+
+	if (drv->monitor_ifidx < 0)
+		return -1;
+
+	if (linux_set_fake_iface_flags(drv->global->ioctl_sock, buf, 1))
+		goto error;
+
+	memset(&ll, 0, sizeof(ll));
+	ll.sll_family = AF_PACKET;
+	ll.sll_ifindex = drv->monitor_ifidx;
+	drv->monitor_sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
+	if (drv->monitor_sock < 0) {
+		perror("socket[PF_PACKET,SOCK_RAW]");
+		goto error;
+	}
+
+	if (add_monitor_filter(drv->monitor_sock)) {
+		wpa_printf(MSG_INFO, "Failed to set socket filter for monitor "
+			   "interface; do filtering in user space");
+		/* This works, but will cost in performance. */
+	}
+
+	if (bind(drv->monitor_sock, (struct sockaddr *) &ll, sizeof(ll)) < 0) {
+		perror("monitor socket bind");
+		goto error;
+	}
+
+	optlen = sizeof(optval);
+	optval = 20;
+	if (setsockopt
+	    (drv->monitor_sock, SOL_SOCKET, SO_PRIORITY, &optval, optlen)) {
+		perror("Failed to set socket priority");
+		goto error;
+	}
+
+	if (eloop_register_read_sock(drv->monitor_sock, handle_monitor_read,
+				     drv, NULL)) {
+		wpa_printf(MSG_DEBUG, "Could not register monitor read socket\n");
+		goto error;
+	}
+
+	return 0;
+ error:
+	capwap_remove_monitor_interface(drv);
+	return -1;
+}
+
+
+static int capwap_setup_ap(struct i802_bss *bss)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+
+	wpa_printf(MSG_DEBUG, "capwap: Setup AP - device_ap_sme=%d "
+		   "use_monitor=%d", drv->device_ap_sme, drv->use_monitor);
+
+	/*
+	 * Disable Probe Request reporting unless we need it in this way for
+	 * devices that include the AP SME, in the other case (unless using
+	 * monitor iface) we'll get it through the nl_mgmt socket instead.
+	 */
+	if (!drv->device_ap_sme)
+		wpa_driver_capwap_probe_req_report(bss, 0);
+
+	if (!drv->device_ap_sme && !drv->use_monitor)
+		if (capwap_mgmt_subscribe_ap(bss))
+			return -1;
+
+	if (drv->device_ap_sme && !drv->use_monitor)
+		if (capwap_mgmt_subscribe_ap_dev_sme(bss))
+			return -1;
+
+	if (!drv->device_ap_sme && drv->use_monitor &&
+	    capwap_create_monitor_interface(drv) &&
+	    !drv->device_ap_sme)
+		return -1;
+
+	if (drv->device_ap_sme &&
+	    wpa_driver_capwap_probe_req_report(bss, 1) < 0) {
+		wpa_printf(MSG_DEBUG, "capwap: Failed to enable "
+			   "Probe Request frame reporting in AP mode");
+		/* Try to survive without this */
+	}
+
+	return 0;
+}
+
+
+static void capwap_teardown_ap(struct i802_bss *bss)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+
+	if (drv->device_ap_sme) {
+		wpa_driver_capwap_probe_req_report(bss, 0);
+		if (!drv->use_monitor)
+			capwap_mgmt_unsubscribe(bss, "AP teardown (dev SME)");
+	} else if (drv->use_monitor)
+		capwap_remove_monitor_interface(drv);
+	else
+		capwap_mgmt_unsubscribe(bss, "AP teardown");
+
+	bss->beacon_set = 0;
+}
+
+
+static int capwap_send_eapol_data(struct i802_bss *bss,
+				   const u8 *addr, const u8 *data,
+				   size_t data_len)
+{
+	wpa_printf(MSG_DEBUG, "capwap_send_eapol_data\n");
+	struct sockaddr_ll ll;
+	int ret;
+
+	if (bss->drv->eapol_tx_sock < 0) {
+		wpa_printf(MSG_DEBUG, "capwap: No socket to send EAPOL");
+		return -1;
+	}
+
+	os_memset(&ll, 0, sizeof(ll));
+	ll.sll_family = AF_PACKET;
+	ll.sll_ifindex = bss->ifindex;
+	ll.sll_protocol = htons(ETH_P_PAE);
+	ll.sll_halen = ETH_ALEN;
+	os_memcpy(ll.sll_addr, addr, ETH_ALEN);
+	ret = sendto(bss->drv->eapol_tx_sock, data, data_len, 0,
+		     (struct sockaddr *) &ll, sizeof(ll));
+	if (ret < 0)
+		wpa_printf(MSG_ERROR, "capwap: EAPOL TX: %s",
+			   strerror(errno));
+
+	return ret;
+}
+
+
+static const u8 rfc1042_header[6] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+
+static int wpa_driver_capwap_hapd_send_eapol(
+	void *priv, const u8 *addr, const u8 *data,
+	size_t data_len, int encrypt, const u8 *own_addr, u32 flags)
+{
+        wpa_printf(MSG_DEBUG, "-------------- wpa_driver_capwap_hapd_send_eapol\n");
+        return;
+
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct ieee80211_hdr *hdr;
+	size_t len;
+	u8 *pos;
+	int res;
+	int qos = flags & WPA_STA_WMM;
+
+	if (drv->device_ap_sme || !drv->use_monitor)
+		return capwap_send_eapol_data(bss, addr, data, data_len);
+
+	len = sizeof(*hdr) + (qos ? 2 : 0) + sizeof(rfc1042_header) + 2 +
+		data_len;
+	hdr = os_zalloc(len);
+	if (hdr == NULL) {
+		wpa_printf(MSG_DEBUG, "malloc() failed for i802_send_data(len=%lu)\n",
+                       (unsigned long) len);
+		return -1;
+	}
+
+	hdr->frame_control =
+		IEEE80211_FC(WLAN_FC_TYPE_DATA, WLAN_FC_STYPE_DATA);
+	hdr->frame_control |= host_to_le16(WLAN_FC_FROMDS);
+	if (encrypt)
+		hdr->frame_control |= host_to_le16(WLAN_FC_ISWEP);
+	if (qos) {
+		hdr->frame_control |=
+			host_to_le16(WLAN_FC_STYPE_QOS_DATA << 4);
+	}
+
+	memcpy(hdr->IEEE80211_DA_FROMDS, addr, ETH_ALEN);
+	memcpy(hdr->IEEE80211_BSSID_FROMDS, own_addr, ETH_ALEN);
+	memcpy(hdr->IEEE80211_SA_FROMDS, own_addr, ETH_ALEN);
+	pos = (u8 *) (hdr + 1);
+
+	if (qos) {
+		/* Set highest priority in QoS header */
+		pos[0] = 7;
+		pos[1] = 0;
+		pos += 2;
+	}
+
+	memcpy(pos, rfc1042_header, sizeof(rfc1042_header));
+	pos += sizeof(rfc1042_header);
+	WPA_PUT_BE16(pos, ETH_P_PAE);
+	pos += 2;
+	memcpy(pos, data, data_len);
+
+	res = wpa_driver_capwap_send_frame(bss, (u8 *) hdr, len, encrypt, 0,
+					    0, 0, 0, 0);
+	if (res < 0) {
+		wpa_printf(MSG_ERROR, "i802_send_eapol - packet len: %lu - "
+			   "failed: %d (%s)",
+			   (unsigned long) len, errno, strerror(errno));
+	}
+	os_free(hdr);
+
+	return res;
+}
+
+
+static int wpa_driver_capwap_sta_set_flags(void *priv, const u8 *addr,
+					    int total_flags,
+					    int flags_or, int flags_and)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg, *flags = NULL;
+	struct nl80211_sta_flag_update upd;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	flags = nlmsg_alloc();
+	if (!flags) {
+		nlmsg_free(msg);
+		return -ENOMEM;
+	}
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_STATION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX,
+		    if_nametoindex(bss->ifname));
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+
+	/*
+	 * Backwards compatibility version using NL80211_ATTR_STA_FLAGS. This
+	 * can be removed eventually.
+	 */
+	if (total_flags & WPA_STA_AUTHORIZED)
+		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_AUTHORIZED);
+
+	if (total_flags & WPA_STA_WMM)
+		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_WME);
+
+	if (total_flags & WPA_STA_SHORT_PREAMBLE)
+		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_SHORT_PREAMBLE);
+
+	if (total_flags & WPA_STA_MFP)
+		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_MFP);
+
+	if (total_flags & WPA_STA_TDLS_PEER)
+		NLA_PUT_FLAG(flags, NL80211_STA_FLAG_TDLS_PEER);
+
+	if (nla_put_nested(msg, NL80211_ATTR_STA_FLAGS, flags))
+		goto nla_put_failure;
+
+	os_memset(&upd, 0, sizeof(upd));
+	upd.mask = sta_flags_capwap(flags_or | ~flags_and);
+	upd.set = sta_flags_capwap(flags_or);
+	NLA_PUT(msg, NL80211_ATTR_STA_FLAGS2, sizeof(upd), &upd);
+
+	nlmsg_free(flags);
+
+	return send_and_recv_msgs(drv, msg, NULL, NULL);
+ nla_put_failure:
+	nlmsg_free(msg);
+	nlmsg_free(flags);
+	return -ENOBUFS;
+}
+
+
+static int wpa_driver_capwap_ap(struct wpa_driver_capwap_data *drv,
+				 struct wpa_driver_associate_params *params)
+{
+	enum nl80211_iftype nlmode, old_mode;
+	struct hostapd_freq_params freq = {
+		.freq = params->freq,
+	};
+
+	if (params->p2p) {
+		wpa_printf(MSG_DEBUG, "capwap: Setup AP operations for P2P "
+			   "group (GO)");
+		nlmode = NL80211_IFTYPE_P2P_GO;
+	} else
+		nlmode = NL80211_IFTYPE_AP;
+
+	old_mode = drv->nlmode;
+	if (wpa_driver_capwap_set_mode(&drv->first_bss, nlmode)) {
+		capwap_remove_monitor_interface(drv);
+		return -1;
+	}
+
+	if (wpa_driver_capwap_set_freq(&drv->first_bss, &freq)) {
+		if (old_mode != nlmode)
+			wpa_driver_capwap_set_mode(&drv->first_bss, old_mode);
+		capwap_remove_monitor_interface(drv);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int capwap_leave_ibss(struct wpa_driver_capwap_data *drv)
+{
+	struct nl_msg *msg;
+	int ret = -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_LEAVE_IBSS);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Leave IBSS failed: ret=%d "
+			   "(%s)", ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+
+	ret = 0;
+	wpa_printf(MSG_DEBUG, "capwap: Leave IBSS request sent successfully");
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wpa_driver_capwap_ibss(struct wpa_driver_capwap_data *drv,
+				   struct wpa_driver_associate_params *params)
+{
+	struct nl_msg *msg;
+	int ret = -1, i;
+	int count = 0;
+
+	wpa_printf(MSG_DEBUG, "capwap: Join IBSS (ifindex=%d)", drv->ifindex);
+
+	if (wpa_driver_capwap_set_mode(&drv->first_bss,
+					NL80211_IFTYPE_ADHOC)) {
+		wpa_printf(MSG_INFO, "capwap: Failed to set interface into "
+			   "IBSS mode");
+		return -1;
+	}
+
+retry:
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_JOIN_IBSS);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+
+	if (params->ssid == NULL || params->ssid_len > sizeof(drv->ssid))
+		goto nla_put_failure;
+
+	wpa_hexdump_ascii(MSG_DEBUG, "  * SSID",
+			  params->ssid, params->ssid_len);
+	NLA_PUT(msg, NL80211_ATTR_SSID, params->ssid_len,
+		params->ssid);
+	os_memcpy(drv->ssid, params->ssid, params->ssid_len);
+	drv->ssid_len = params->ssid_len;
+
+	wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
+
+//	if (params->fixed_freq) {
+//		wpa_printf(MSG_DEBUG, "  * fixed_freq");
+//		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
+//	}
+
+//	if (params->beacon_interval > 0) {
+//		wpa_printf(MSG_DEBUG, "  * beacon_interval=%d",
+//			   params->beacon_interval);
+//		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL,
+//			    params->beacon_interval);
+//	}
+
+//	if (params->rates[0] > 0) {
+//		wpa_printf(MSG_DEBUG, "  * basic_rates:");
+//		i = 0;
+//		while (i < NL80211_MAX_SUPP_RATES &&
+//		       params->rates[i] > 0) {
+//			wpa_printf(MSG_DEBUG, "    %.1f",
+//				   (double)params->rates[i] / 2);
+//			i++;
+//		}
+//		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
+//			params->rates);
+//	}
+
+//	if (params->mcast_rate > 0) {
+//		wpa_printf(MSG_DEBUG, "  * mcast_rates=%.1f",
+//			   (double)params->mcast_rate / 10);
+//		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
+//	}
+
+//	if (params->ht_set) {
+//		switch(params->htmode) {
+//			case NL80211_CHAN_HT20:
+//				wpa_printf(MSG_DEBUG, "  * ht=HT20");
+//				break;
+//			case NL80211_CHAN_HT40PLUS:
+//				wpa_printf(MSG_DEBUG, "  * ht=HT40+");
+//				break;
+//			case NL80211_CHAN_HT40MINUS:
+//				wpa_printf(MSG_DEBUG, "  * ht=HT40-");
+//				break;
+//		}
+//		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+//			    params->htmode);
+//	}
+
+	ret = capwap_set_conn_keys(params, msg);
+	if (ret)
+		goto nla_put_failure;
+
+	if (params->bssid && params->fixed_bssid) {
+		wpa_printf(MSG_DEBUG, "  * BSSID=" MACSTR,
+			   MAC2STR(params->bssid));
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, params->bssid);
+	}
+
+	if (params->key_mgmt_suite == KEY_MGMT_802_1X ||
+	    params->key_mgmt_suite == KEY_MGMT_PSK ||
+	    params->key_mgmt_suite == KEY_MGMT_802_1X_SHA256 ||
+	    params->key_mgmt_suite == KEY_MGMT_PSK_SHA256) {
+		wpa_printf(MSG_DEBUG, "  * control port");
+		NLA_PUT_FLAG(msg, NL80211_ATTR_CONTROL_PORT);
+	}
+
+	if (params->wpa_ie) {
+		wpa_hexdump(MSG_DEBUG,
+			    "  * Extra IEs for Beacon/Probe Response frames",
+			    params->wpa_ie, params->wpa_ie_len);
+		NLA_PUT(msg, NL80211_ATTR_IE, params->wpa_ie_len,
+			params->wpa_ie);
+	}
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Join IBSS failed: ret=%d (%s)",
+			   ret, strerror(-ret));
+		count++;
+		if (ret == -EALREADY && count == 1) {
+			wpa_printf(MSG_DEBUG, "capwap: Retry IBSS join after "
+				   "forced leave");
+			capwap_leave_ibss(drv);
+			nlmsg_free(msg);
+			goto retry;
+		}
+
+		goto nla_put_failure;
+	}
+	ret = 0;
+	wpa_printf(MSG_DEBUG, "capwap: Join IBSS request sent successfully");
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wpa_driver_capwap_try_connect(
+	struct wpa_driver_capwap_data *drv,
+	struct wpa_driver_associate_params *params)
+{
+	struct nl_msg *msg;
+	enum nl80211_auth_type type;
+	int ret = 0;
+	int algs;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: Connect (ifindex=%d)", drv->ifindex);
+	capwap_cmd(drv, msg, 0, NL80211_CMD_CONNECT);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	if (params->bssid) {
+		wpa_printf(MSG_DEBUG, "  * bssid=" MACSTR,
+			   MAC2STR(params->bssid));
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, params->bssid);
+	}
+	if (params->freq) {
+		wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
+	}
+	if (params->bg_scan_period >= 0) {
+		wpa_printf(MSG_DEBUG, "  * bg scan period=%d",
+			   params->bg_scan_period);
+		NLA_PUT_U16(msg, NL80211_ATTR_BG_SCAN_PERIOD,
+			    params->bg_scan_period);
+	}
+	if (params->ssid) {
+		wpa_hexdump_ascii(MSG_DEBUG, "  * SSID",
+				  params->ssid, params->ssid_len);
+		NLA_PUT(msg, NL80211_ATTR_SSID, params->ssid_len,
+			params->ssid);
+		if (params->ssid_len > sizeof(drv->ssid))
+			goto nla_put_failure;
+		os_memcpy(drv->ssid, params->ssid, params->ssid_len);
+		drv->ssid_len = params->ssid_len;
+	}
+	wpa_hexdump(MSG_DEBUG, "  * IEs", params->wpa_ie, params->wpa_ie_len);
+	if (params->wpa_ie)
+		NLA_PUT(msg, NL80211_ATTR_IE, params->wpa_ie_len,
+			params->wpa_ie);
+
+	algs = 0;
+	if (params->auth_alg & WPA_AUTH_ALG_OPEN)
+		algs++;
+	if (params->auth_alg & WPA_AUTH_ALG_SHARED)
+		algs++;
+	if (params->auth_alg & WPA_AUTH_ALG_LEAP)
+		algs++;
+	if (algs > 1) {
+		wpa_printf(MSG_DEBUG, "  * Leave out Auth Type for automatic "
+			   "selection");
+		goto skip_auth_type;
+	}
+
+	if (params->auth_alg & WPA_AUTH_ALG_OPEN)
+		type = NL80211_AUTHTYPE_OPEN_SYSTEM;
+	else if (params->auth_alg & WPA_AUTH_ALG_SHARED)
+		type = NL80211_AUTHTYPE_SHARED_KEY;
+	else if (params->auth_alg & WPA_AUTH_ALG_LEAP)
+		type = NL80211_AUTHTYPE_NETWORK_EAP;
+	else if (params->auth_alg & WPA_AUTH_ALG_FT)
+		type = NL80211_AUTHTYPE_FT;
+	else
+		goto nla_put_failure;
+
+	wpa_printf(MSG_DEBUG, "  * Auth Type %d", type);
+	NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE, type);
+
+skip_auth_type:
+	if (params->wpa_proto) {
+		enum nl80211_wpa_versions ver = 0;
+
+		if (params->wpa_proto & WPA_PROTO_WPA)
+			ver |= NL80211_WPA_VERSION_1;
+		if (params->wpa_proto & WPA_PROTO_RSN)
+			ver |= NL80211_WPA_VERSION_2;
+
+		wpa_printf(MSG_DEBUG, "  * WPA Versions 0x%x", ver);
+		NLA_PUT_U32(msg, NL80211_ATTR_WPA_VERSIONS, ver);
+	}
+
+	if (params->pairwise_suite != CIPHER_NONE) {
+		int cipher;
+
+		switch (params->pairwise_suite) {
+		case CIPHER_SMS4:
+			cipher = WLAN_CIPHER_SUITE_SMS4;
+			break;
+		case CIPHER_WEP40:
+			cipher = WLAN_CIPHER_SUITE_WEP40;
+			break;
+		case CIPHER_WEP104:
+			cipher = WLAN_CIPHER_SUITE_WEP104;
+			break;
+		case CIPHER_CCMP:
+			cipher = WLAN_CIPHER_SUITE_CCMP;
+			break;
+		case CIPHER_GCMP:
+			cipher = WLAN_CIPHER_SUITE_GCMP;
+			break;
+		case CIPHER_TKIP:
+		default:
+			cipher = WLAN_CIPHER_SUITE_TKIP;
+			break;
+		}
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITES_PAIRWISE, cipher);
+	}
+
+	if (params->group_suite != CIPHER_NONE) {
+		int cipher;
+
+		switch (params->group_suite) {
+		case CIPHER_SMS4:
+			cipher = WLAN_CIPHER_SUITE_SMS4;
+			break;
+		case CIPHER_WEP40:
+			cipher = WLAN_CIPHER_SUITE_WEP40;
+			break;
+		case CIPHER_WEP104:
+			cipher = WLAN_CIPHER_SUITE_WEP104;
+			break;
+		case CIPHER_CCMP:
+			cipher = WLAN_CIPHER_SUITE_CCMP;
+			break;
+		case CIPHER_GCMP:
+			cipher = WLAN_CIPHER_SUITE_GCMP;
+			break;
+		case CIPHER_TKIP:
+		default:
+			cipher = WLAN_CIPHER_SUITE_TKIP;
+			break;
+		}
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP, cipher);
+	}
+
+	if (params->key_mgmt_suite == KEY_MGMT_802_1X ||
+	    params->key_mgmt_suite == KEY_MGMT_PSK ||
+	    params->key_mgmt_suite == KEY_MGMT_CCKM) {
+		int mgmt = WLAN_AKM_SUITE_PSK;
+
+		switch (params->key_mgmt_suite) {
+		case KEY_MGMT_CCKM:
+			mgmt = WLAN_AKM_SUITE_CCKM;
+			break;
+		case KEY_MGMT_802_1X:
+			mgmt = WLAN_AKM_SUITE_8021X;
+			break;
+		case KEY_MGMT_PSK:
+		default:
+			mgmt = WLAN_AKM_SUITE_PSK;
+			break;
+		}
+		NLA_PUT_U32(msg, NL80211_ATTR_AKM_SUITES, mgmt);
+	}
+
+#ifdef CONFIG_IEEE80211W
+	if (params->mgmt_frame_protection == MGMT_FRAME_PROTECTION_REQUIRED)
+		NLA_PUT_U32(msg, NL80211_ATTR_USE_MFP, NL80211_MFP_REQUIRED);
+#endif /* CONFIG_IEEE80211W */
+
+	if (params->disable_ht)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_DISABLE_HT);
+
+	if (params->htcaps && params->htcaps_mask) {
+		int sz = sizeof(struct ieee80211_ht_capabilities);
+		NLA_PUT(msg, NL80211_ATTR_HT_CAPABILITY, sz, params->htcaps);
+		NLA_PUT(msg, NL80211_ATTR_HT_CAPABILITY_MASK, sz,
+			params->htcaps_mask);
+	}
+
+	ret = capwap_set_conn_keys(params, msg);
+	if (ret)
+		goto nla_put_failure;
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: MLME connect failed: ret=%d "
+			   "(%s)", ret, strerror(-ret));
+		goto nla_put_failure;
+	}
+	ret = 0;
+	wpa_printf(MSG_DEBUG, "capwap: Connect request send successfully");
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+
+}
+
+
+static int wpa_driver_capwap_connect(
+	struct wpa_driver_capwap_data *drv,
+	struct wpa_driver_associate_params *params)
+{
+	int ret = wpa_driver_capwap_try_connect(drv, params);
+	if (ret == -EALREADY) {
+		/*
+		 * cfg80211 does not currently accept new connections if
+		 * we are already connected. As a workaround, force
+		 * disconnection and try again.
+		 */
+		wpa_printf(MSG_DEBUG, "capwap: Explicitly "
+			   "disconnecting before reassociation "
+			   "attempt");
+		if (wpa_driver_capwap_disconnect(
+			    drv, WLAN_REASON_PREV_AUTH_NOT_VALID))
+			return -1;
+		/* Ignore the next local disconnect message. */
+		drv->ignore_next_local_disconnect = 1;
+		ret = wpa_driver_capwap_try_connect(drv, params);
+	}
+	return ret;
+}
+
+
+static int wpa_driver_capwap_associate(
+	void *priv, struct wpa_driver_associate_params *params)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = -1;
+	struct nl_msg *msg;
+
+	if (params->mode == IEEE80211_MODE_AP)
+		return wpa_driver_capwap_ap(drv, params);
+
+	if (params->mode == IEEE80211_MODE_IBSS)
+		return wpa_driver_capwap_ibss(drv, params);
+
+	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_SME)) {
+		enum nl80211_iftype nlmode = params->p2p ?
+			NL80211_IFTYPE_P2P_CLIENT : NL80211_IFTYPE_STATION;
+
+		if (wpa_driver_capwap_set_mode(priv, nlmode) < 0)
+			return -1;
+		return wpa_driver_capwap_connect(drv, params);
+	}
+
+	drv->associated = 0;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: Associate (ifindex=%d)",
+		   drv->ifindex);
+	capwap_cmd(drv, msg, 0, NL80211_CMD_ASSOCIATE);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	if (params->bssid) {
+		wpa_printf(MSG_DEBUG, "  * bssid=" MACSTR,
+			   MAC2STR(params->bssid));
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, params->bssid);
+	}
+	if (params->freq) {
+		wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
+		drv->assoc_freq = params->freq;
+	} else
+		drv->assoc_freq = 0;
+	if (params->bg_scan_period >= 0) {
+		wpa_printf(MSG_DEBUG, "  * bg scan period=%d",
+			   params->bg_scan_period);
+		NLA_PUT_U16(msg, NL80211_ATTR_BG_SCAN_PERIOD,
+			    params->bg_scan_period);
+	}
+	if (params->ssid) {
+		wpa_hexdump_ascii(MSG_DEBUG, "  * SSID",
+				  params->ssid, params->ssid_len);
+		NLA_PUT(msg, NL80211_ATTR_SSID, params->ssid_len,
+			params->ssid);
+		if (params->ssid_len > sizeof(drv->ssid))
+			goto nla_put_failure;
+		os_memcpy(drv->ssid, params->ssid, params->ssid_len);
+		drv->ssid_len = params->ssid_len;
+	}
+	wpa_hexdump(MSG_DEBUG, "  * IEs", params->wpa_ie, params->wpa_ie_len);
+	if (params->wpa_ie)
+		NLA_PUT(msg, NL80211_ATTR_IE, params->wpa_ie_len,
+			params->wpa_ie);
+
+	if (params->pairwise_suite != CIPHER_NONE) {
+		int cipher;
+
+		switch (params->pairwise_suite) {
+		case CIPHER_WEP40:
+			cipher = WLAN_CIPHER_SUITE_WEP40;
+			break;
+		case CIPHER_WEP104:
+			cipher = WLAN_CIPHER_SUITE_WEP104;
+			break;
+		case CIPHER_CCMP:
+			cipher = WLAN_CIPHER_SUITE_CCMP;
+			break;
+		case CIPHER_GCMP:
+			cipher = WLAN_CIPHER_SUITE_GCMP;
+			break;
+		case CIPHER_TKIP:
+		default:
+			cipher = WLAN_CIPHER_SUITE_TKIP;
+			break;
+		}
+		wpa_printf(MSG_DEBUG, "  * pairwise=0x%x", cipher);
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITES_PAIRWISE, cipher);
+	}
+
+	if (params->group_suite != CIPHER_NONE) {
+		int cipher;
+
+		switch (params->group_suite) {
+		case CIPHER_WEP40:
+			cipher = WLAN_CIPHER_SUITE_WEP40;
+			break;
+		case CIPHER_WEP104:
+			cipher = WLAN_CIPHER_SUITE_WEP104;
+			break;
+		case CIPHER_CCMP:
+			cipher = WLAN_CIPHER_SUITE_CCMP;
+			break;
+		case CIPHER_GCMP:
+			cipher = WLAN_CIPHER_SUITE_GCMP;
+			break;
+		case CIPHER_TKIP:
+		default:
+			cipher = WLAN_CIPHER_SUITE_TKIP;
+			break;
+		}
+		wpa_printf(MSG_DEBUG, "  * group=0x%x", cipher);
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP, cipher);
+	}
+
+#ifdef CONFIG_IEEE80211W
+	if (params->mgmt_frame_protection == MGMT_FRAME_PROTECTION_REQUIRED)
+		NLA_PUT_U32(msg, NL80211_ATTR_USE_MFP, NL80211_MFP_REQUIRED);
+#endif /* CONFIG_IEEE80211W */
+
+	NLA_PUT_FLAG(msg, NL80211_ATTR_CONTROL_PORT);
+
+	if (params->prev_bssid) {
+		wpa_printf(MSG_DEBUG, "  * prev_bssid=" MACSTR,
+			   MAC2STR(params->prev_bssid));
+		NLA_PUT(msg, NL80211_ATTR_PREV_BSSID, ETH_ALEN,
+			params->prev_bssid);
+	}
+
+	if (params->disable_ht)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_DISABLE_HT);
+
+	if (params->htcaps && params->htcaps_mask) {
+		int sz = sizeof(struct ieee80211_ht_capabilities);
+		NLA_PUT(msg, NL80211_ATTR_HT_CAPABILITY, sz, params->htcaps);
+		NLA_PUT(msg, NL80211_ATTR_HT_CAPABILITY_MASK, sz,
+			params->htcaps_mask);
+	}
+
+	if (params->p2p)
+		wpa_printf(MSG_DEBUG, "  * P2P group");
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_dbg(drv->ctx, MSG_DEBUG,
+			"capwap: MLME command failed (assoc): ret=%d (%s)",
+			ret, strerror(-ret));
+		capwap_dump_scan(drv);
+		goto nla_put_failure;
+	}
+	ret = 0;
+	wpa_printf(MSG_DEBUG, "capwap: Association request send "
+		   "successfully");
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int capwap_set_mode(struct wpa_driver_capwap_data *drv,
+			    int ifindex, enum nl80211_iftype mode)
+{
+	wpa_printf(MSG_DEBUG, "                                         1.wpa_driver_capwap_set_mode\n");
+	struct nl_msg *msg;
+	int ret = -ENOBUFS;
+
+	wpa_printf(MSG_DEBUG, "capwap: Set mode ifindex %d iftype %d (%s)",
+		   ifindex, mode, capwap_iftype_str(mode));
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_INTERFACE);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, mode);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (!ret)
+		return 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	wpa_printf(MSG_DEBUG, "capwap: Failed to set interface %d to mode %d:"
+		   " %d (%s)", ifindex, mode, ret, strerror(-ret));
+	return ret;
+}
+
+
+static int wpa_driver_capwap_set_mode(struct i802_bss *bss,
+				       enum nl80211_iftype nlmode)
+{
+	wpa_printf(MSG_DEBUG, "                                 6.wpa_driver_capwap_set_mode\n");
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = -1;
+	int i;
+	int was_ap = is_ap_interface(drv->nlmode);
+	int res;
+
+	res = capwap_set_mode(drv, drv->ifindex, nlmode);
+	if (res == 0) {
+		drv->nlmode = nlmode;
+		ret = 0;
+		goto done;
+	}
+
+	if (res == -ENODEV)
+		return -1;
+
+	if (nlmode == drv->nlmode) {
+		wpa_printf(MSG_DEBUG, "capwap: Interface already in "
+			   "requested mode - ignore error");
+		ret = 0;
+		goto done; /* Already in the requested mode */
+	}
+
+	/* mac80211 doesn't allow mode changes while the device is up, so
+	 * take the device down, try to set the mode again, and bring the
+	 * device back up.
+	 */
+	wpa_printf(MSG_DEBUG, "capwap: Try mode change after setting "
+		   "interface down");
+	for (i = 0; i < 10; i++) {
+		res = linux_set_fake_iface_flags(drv->global->ioctl_sock,
+					    bss->ifname, 0);
+		if (res == -EACCES || res == -ENODEV)
+			break;
+		if (res == 0) {
+			/* Try to set the mode again while the interface is
+			 * down */
+			ret = capwap_set_mode(drv, drv->ifindex, nlmode);
+			if (ret == -EACCES)
+				break;
+			if (res && !ret)
+				ret = -1;
+			else if (ret != -EBUSY)
+				break;
+		} else
+			wpa_printf(MSG_DEBUG, "capwap: Failed to set "
+				   "interface down");
+		os_sleep(0, 100000);
+	}
+
+	if (!ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Mode change succeeded while "
+			   "interface is down");
+		drv->nlmode = nlmode;
+		drv->ignore_if_down_event = 1;
+		linux_set_fake_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
+	}
+
+done:
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Interface mode change to %d "
+			   "from %d failed", nlmode, drv->nlmode);
+		return ret;
+	}
+
+	if (is_p2p_interface(nlmode))
+		capwap_disable_11b_rates(drv, drv->ifindex, 1);
+	else if (drv->disabled_11b_rates)
+		capwap_disable_11b_rates(drv, drv->ifindex, 0);
+
+	if (is_ap_interface(nlmode)) {
+		capwap_mgmt_unsubscribe(bss, "start AP");
+		/* Setup additional AP mode functionality if needed */
+		if (capwap_setup_ap(bss))
+			return -1;
+	} else if (was_ap) {
+		/* Remove additional AP mode functionality */
+		capwap_teardown_ap(bss);
+	} else {
+		capwap_mgmt_unsubscribe(bss, "mode change");
+	}
+
+	if (!bss->in_deinit && !is_ap_interface(nlmode) &&
+	    capwap_mgmt_subscribe_non_ap(bss) < 0)
+		wpa_printf(MSG_DEBUG, "capwap: Failed to register Action "
+			   "frame processing - ignore for now");
+
+	return 0;
+}
+
+
+static int wpa_driver_capwap_get_capa(void *priv,
+				       struct wpa_driver_capa *capa)
+{
+	wpa_printf(MSG_DEBUG, "                         1.wpa_driver_capwap_get_capa\n");
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (!drv->has_capability)
+		return -1;
+	os_memcpy(capa, &drv->capa, sizeof(*capa));
+	return 0;
+}
+
+
+static int wpa_driver_capwap_set_operstate(void *priv, int state)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+
+	wpa_printf(MSG_DEBUG, "%s: operstate %d->%d (%s)",
+		   __func__, drv->operstate, state, state ? "UP" : "DORMANT");
+	drv->operstate = state;
+	return netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, -1,
+				      state ? IF_OPER_UP : IF_OPER_DORMANT);
+}
+
+
+static int wpa_driver_capwap_set_supp_port(void *priv, int authorized)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nl80211_sta_flag_update upd;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_STATION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX,
+		    if_nametoindex(bss->ifname));
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, drv->bssid);
+
+	os_memset(&upd, 0, sizeof(upd));
+	upd.mask = BIT(NL80211_STA_FLAG_AUTHORIZED);
+	if (authorized)
+		upd.set = BIT(NL80211_STA_FLAG_AUTHORIZED);
+	NLA_PUT(msg, NL80211_ATTR_STA_FLAGS2, sizeof(upd), &upd);
+
+	return send_and_recv_msgs(drv, msg, NULL, NULL);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+/* Set kernel driver on given frequency (MHz) */
+static int i802_set_freq(void *priv, struct hostapd_freq_params *freq)
+{
+	wpa_printf(MSG_DEBUG, "                                 1.i802_set_freq \n");
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_set_freq(bss, freq);
+}
+
+
+#if defined(HOSTAPD) || defined(CONFIG_AP)
+
+static inline int min_int(int a, int b)
+{
+	if (a < b)
+		return a;
+	return b;
+}
+
+
+static int get_key_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	/*
+	 * TODO: validate the key index and mac address!
+	 * Otherwise, there's a race condition as soon as
+	 * the kernel starts sending key notifications.
+	 */
+
+	if (tb[NL80211_ATTR_KEY_SEQ])
+		memcpy(arg, nla_data(tb[NL80211_ATTR_KEY_SEQ]),
+		       min_int(nla_len(tb[NL80211_ATTR_KEY_SEQ]), 6));
+	return NL_SKIP;
+}
+
+
+static int i802_get_seqnum(const char *iface, void *priv, const u8 *addr,
+			   int idx, u8 *seq)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_GET_KEY);
+
+	if (addr)
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+	NLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, idx);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(iface));
+
+	memset(seq, 0, 6);
+
+	return send_and_recv_msgs(drv, msg, get_key_handler, seq);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int i802_set_rts(void *priv, int rts)
+{
+	wpa_printf(MSG_DEBUG, "> i802_set_rts %d \n",rts);
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret = -ENOBUFS;
+	u32 val;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	if (rts >= 2347)
+		val = (u32) -1;
+	else
+		val = rts;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_WIPHY);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD, val);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (!ret)
+		return 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	wpa_printf(MSG_DEBUG, "capwap: Failed to set RTS threshold %d: "
+		   "%d (%s)", rts, ret, strerror(-ret));
+	return ret;
+}
+
+
+static int i802_set_frag(void *priv, int frag)
+{
+	wpa_printf(MSG_DEBUG, "> i802_set_frag  %d\n",frag);
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret = -ENOBUFS;
+	u32 val;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	if (frag >= 2346)
+		val = (u32) -1;
+	else
+		val = frag;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_WIPHY);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD, val);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (!ret)
+		return 0;
+nla_put_failure:
+	nlmsg_free(msg);
+	wpa_printf(MSG_DEBUG, "capwap: Failed to set fragmentation threshold "
+		   "%d: %d (%s)", frag, ret, strerror(-ret));
+	return ret;
+}
+
+
+static int i802_flush(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int res;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_DEL_STATION);
+
+	/*
+	 * XXX: FIX! this needs to flush all VLANs too
+	 */
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX,
+		    if_nametoindex(bss->ifname));
+
+	res = send_and_recv_msgs(drv, msg, NULL, NULL);
+	if (res) {
+		wpa_printf(MSG_DEBUG, "capwap: Station flush failed: ret=%d "
+			   "(%s)", res, strerror(-res));
+	}
+	return res;
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+#endif /* HOSTAPD || CONFIG_AP */
+
+
+static int get_sta_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct hostap_sta_driver_data *data = arg;
+	struct nlattr *stats[NL80211_STA_INFO_MAX + 1];
+	static struct nla_policy stats_policy[NL80211_STA_INFO_MAX + 1] = {
+		[NL80211_STA_INFO_INACTIVE_TIME] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_RX_BYTES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_BYTES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_RX_PACKETS] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_PACKETS] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_FAILED] = { .type = NLA_U32 },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	/*
+	 * TODO: validate the interface and mac address!
+	 * Otherwise, there's a race condition as soon as
+	 * the kernel starts sending station notifications.
+	 */
+
+	if (!tb[NL80211_ATTR_STA_INFO]) {
+		wpa_printf(MSG_DEBUG, "sta stats missing!");
+		return NL_SKIP;
+	}
+	if (nla_parse_nested(stats, NL80211_STA_INFO_MAX,
+			     tb[NL80211_ATTR_STA_INFO],
+			     stats_policy)) {
+		wpa_printf(MSG_DEBUG, "failed to parse nested attributes!");
+		return NL_SKIP;
+	}
+
+	if (stats[NL80211_STA_INFO_INACTIVE_TIME])
+		data->inactive_msec =
+			nla_get_u32(stats[NL80211_STA_INFO_INACTIVE_TIME]);
+	if (stats[NL80211_STA_INFO_RX_BYTES])
+		data->rx_bytes = nla_get_u32(stats[NL80211_STA_INFO_RX_BYTES]);
+	if (stats[NL80211_STA_INFO_TX_BYTES])
+		data->tx_bytes = nla_get_u32(stats[NL80211_STA_INFO_TX_BYTES]);
+	if (stats[NL80211_STA_INFO_RX_PACKETS])
+		data->rx_packets =
+			nla_get_u32(stats[NL80211_STA_INFO_RX_PACKETS]);
+	if (stats[NL80211_STA_INFO_TX_PACKETS])
+		data->tx_packets =
+			nla_get_u32(stats[NL80211_STA_INFO_TX_PACKETS]);
+	if (stats[NL80211_STA_INFO_TX_FAILED])
+		data->tx_retry_failed =
+			nla_get_u32(stats[NL80211_STA_INFO_TX_FAILED]);
+
+	return NL_SKIP;
+}
+
+static int i802_read_sta_data(struct i802_bss *bss,
+			      struct hostap_sta_driver_data *data,
+			      const u8 *addr)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+
+	os_memset(data, 0, sizeof(*data));
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_GET_STATION);
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(bss->ifname));
+
+	return send_and_recv_msgs(drv, msg, get_sta_handler, data);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+#if defined(HOSTAPD) || defined(CONFIG_AP)
+
+static int i802_set_tx_queue_params(void *priv, int queue, int aifs,
+				    int cw_min, int cw_max, int burst_time)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *txq, *params;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_WIPHY);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(bss->ifname));
+
+	txq = nla_nest_start(msg, NL80211_ATTR_WIPHY_TXQ_PARAMS);
+	if (!txq)
+		goto nla_put_failure;
+
+	/* We are only sending parameters for a single TXQ at a time */
+	params = nla_nest_start(msg, 1);
+	if (!params)
+		goto nla_put_failure;
+
+	switch (queue) {
+	case 0:
+		NLA_PUT_U8(msg, NL80211_TXQ_ATTR_QUEUE, NL80211_TXQ_Q_VO);
+		break;
+	case 1:
+		NLA_PUT_U8(msg, NL80211_TXQ_ATTR_QUEUE, NL80211_TXQ_Q_VI);
+		break;
+	case 2:
+		NLA_PUT_U8(msg, NL80211_TXQ_ATTR_QUEUE, NL80211_TXQ_Q_BE);
+		break;
+	case 3:
+		NLA_PUT_U8(msg, NL80211_TXQ_ATTR_QUEUE, NL80211_TXQ_Q_BK);
+		break;
+	}
+	/* Burst time is configured in units of 0.1 msec and TXOP parameter in
+	 * 32 usec, so need to convert the value here. */
+	NLA_PUT_U16(msg, NL80211_TXQ_ATTR_TXOP, (burst_time * 100 + 16) / 32);
+	NLA_PUT_U16(msg, NL80211_TXQ_ATTR_CWMIN, cw_min);
+	NLA_PUT_U16(msg, NL80211_TXQ_ATTR_CWMAX, cw_max);
+	NLA_PUT_U8(msg, NL80211_TXQ_ATTR_AIFS, aifs);
+
+	nla_nest_end(msg, params);
+
+	nla_nest_end(msg, txq);
+
+	if (send_and_recv_msgs(drv, msg, NULL, NULL) == 0)
+		return 0;
+	msg = NULL;
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
+
+static int i802_set_sta_vlan(struct i802_bss *bss, const u8 *addr,
+			     const char *ifname, int vlan_id)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret = -ENOBUFS;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_STATION);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX,
+		    if_nametoindex(bss->ifname));
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+	NLA_PUT_U32(msg, NL80211_ATTR_STA_VLAN,
+		    if_nametoindex(ifname));
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "capwap: NL80211_ATTR_STA_VLAN (addr="
+			   MACSTR " ifname=%s vlan_id=%d) failed: %d (%s)",
+			   MAC2STR(addr), ifname, vlan_id, ret,
+			   strerror(-ret));
+	}
+ nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int i802_get_inact_sec(void *priv, const u8 *addr)
+{
+	struct hostap_sta_driver_data data;
+	int ret;
+
+	data.inactive_msec = (unsigned long) -1;
+	ret = i802_read_sta_data(priv, &data, addr);
+	if (ret || data.inactive_msec == (unsigned long) -1)
+		return -1;
+	return data.inactive_msec / 1000;
+}
+
+
+static int i802_sta_clear_stats(void *priv, const u8 *addr)
+{
+#if 0
+	/* TODO */
+#endif
+	return 0;
+}
+
+
+static int i802_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
+			   int reason)
+{
+	wpa_printf(MSG_DEBUG, "                                                                 1.i802_sta_deauth \n");
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct ieee80211_mgmt mgmt;
+
+	if (drv->device_ap_sme)
+		return wpa_driver_capwap_sta_remove(bss, addr);
+
+	memset(&mgmt, 0, sizeof(mgmt));
+	mgmt.frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
+					  WLAN_FC_STYPE_DEAUTH);
+	memcpy(mgmt.da, addr, ETH_ALEN);
+	memcpy(mgmt.sa, own_addr, ETH_ALEN);
+	memcpy(mgmt.bssid, own_addr, ETH_ALEN);
+	mgmt.u.deauth.reason_code = host_to_le16(reason);
+	int r = wpa_driver_capwap_send_mlme(bss, (u8 *) &mgmt,
+					    IEEE80211_HDRLEN +
+					    sizeof(mgmt.u.deauth), 0, 0, 0, 0,
+					    0);
+	return r;
+}
+
+
+static int i802_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
+			     int reason)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct ieee80211_mgmt mgmt;
+
+	if (drv->device_ap_sme)
+		return wpa_driver_capwap_sta_remove(bss, addr);
+
+	memset(&mgmt, 0, sizeof(mgmt));
+	mgmt.frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
+					  WLAN_FC_STYPE_DISASSOC);
+	memcpy(mgmt.da, addr, ETH_ALEN);
+	memcpy(mgmt.sa, own_addr, ETH_ALEN);
+	memcpy(mgmt.bssid, own_addr, ETH_ALEN);
+	mgmt.u.disassoc.reason_code = host_to_le16(reason);
+	return wpa_driver_capwap_send_mlme(bss, (u8 *) &mgmt,
+					    IEEE80211_HDRLEN +
+					    sizeof(mgmt.u.disassoc), 0, 0, 0, 0,
+					    0);
+}
+
+#endif /* HOSTAPD || CONFIG_AP */
+
+#ifdef HOSTAPD
+
+static void add_ifidx(struct wpa_driver_capwap_data *drv, int ifidx)
+{
+	wpa_printf(MSG_DEBUG,"                                  3.add_ifidx\n");
+	int i;
+	int *old;
+
+	wpa_printf(MSG_DEBUG, "capwap: Add own interface ifindex %d",
+		   ifidx);
+	for (i = 0; i < drv->num_if_indices; i++) {
+		if (drv->if_indices[i] == 0) {
+			drv->if_indices[i] = ifidx;
+			return;
+		}
+	}
+
+	if (drv->if_indices != drv->default_if_indices)
+		old = drv->if_indices;
+	else
+		old = NULL;
+
+	drv->if_indices = os_realloc_array(old, drv->num_if_indices + 1,
+					   sizeof(int));
+	if (!drv->if_indices) {
+		if (!old)
+			drv->if_indices = drv->default_if_indices;
+		else
+			drv->if_indices = old;
+		wpa_printf(MSG_ERROR, "Failed to reallocate memory for "
+			   "interfaces");
+		wpa_printf(MSG_ERROR, "Ignoring EAPOL on interface %d", ifidx);
+		return;
+	} else if (!old)
+		os_memcpy(drv->if_indices, drv->default_if_indices,
+			  sizeof(drv->default_if_indices));
+	drv->if_indices[drv->num_if_indices] = ifidx;
+	drv->num_if_indices++;
+}
+
+
+static void del_ifidx(struct wpa_driver_capwap_data *drv, int ifidx)
+{
+	int i;
+
+	for (i = 0; i < drv->num_if_indices; i++) {
+		if (drv->if_indices[i] == ifidx) {
+			drv->if_indices[i] = 0;
+			break;
+		}
+	}
+}
+
+
+static int have_ifidx(struct wpa_driver_capwap_data *drv, int ifidx)
+{
+	int i;
+
+	for (i = 0; i < drv->num_if_indices; i++)
+		if (drv->if_indices[i] == ifidx)
+			return 1;
+
+	return 0;
+}
+
+
+static int i802_set_wds_sta(void *priv, const u8 *addr, int aid, int val,
+                            const char *bridge_ifname)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	char name[IFNAMSIZ + 1];
+
+	os_snprintf(name, sizeof(name), "%s.sta%d", bss->ifname, aid);
+	wpa_printf(MSG_DEBUG, "capwap: Set WDS STA addr=" MACSTR
+		   " aid=%d val=%d name=%s", MAC2STR(addr), aid, val, name);
+	if (val) {
+		if (!if_nametoindex(name)) {
+			if (capwap_create_iface(drv, name,
+						 NL80211_IFTYPE_AP_VLAN,
+						 bss->addr, 1) < 0)
+				return -1;
+			if (bridge_ifname &&
+			    linux_br_fake_add_if(drv->global->ioctl_sock,
+					    bridge_ifname, name) < 0)
+				return -1;
+		}
+		if (linux_set_fake_iface_flags(drv->global->ioctl_sock, name, 1)) {
+			wpa_printf(MSG_ERROR, "capwap: Failed to set WDS STA "
+				   "interface %s up", name);
+		}
+		return i802_set_sta_vlan(priv, addr, name, 0);
+	} else {
+		if (bridge_ifname)
+			linux_br_fake_del_if(drv->global->ioctl_sock, bridge_ifname,
+					name);
+
+		i802_set_sta_vlan(priv, addr, bss->ifname, 0);
+		return wpa_driver_capwap_if_remove(priv, WPA_IF_AP_VLAN,
+						    name);
+	}
+}
+
+void AC_handle_eapol(struct wpa_driver_capwap_data *drv, u8 *buf, int len){
+	u8 sa[6];
+
+	int hlen = GetEapol_Frame(sa, buf, len);
+	//stampa_mac("AC eapol: " ,sa);
+
+	drv_event_eapol_rx(drv->ctx, sa, buf + hlen, len - hlen);
+}
+
+
+
+static void handle_eapol(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	wpa_printf(MSG_DEBUG, "handle_eapol %d\n",sock);
+	struct wpa_driver_capwap_data *drv = eloop_ctx;
+	struct sockaddr_ll lladdr;
+	unsigned char buf[3000];
+	int len;
+	socklen_t fromlen = sizeof(lladdr);
+
+	len = recvfrom(sock, buf, sizeof(buf), 0,
+		       (struct sockaddr *)&lladdr, &fromlen);
+
+	return;
+	if (len < 0) {
+	wpa_printf(MSG_ERROR, "recv");
+               return;
+	}
+
+	wpa_printf(MSG_DEBUG, "LOCALE");
+	stampa_frame(buf,len);
+
+	wpa_printf(MSG_DEBUG, "%d,%d", len,have_ifidx(drv, lladdr.sll_ifindex));
+
+	//stampa_mac("  EAPOL MAC: ",lladdr.sll_addr);
+	drv_event_eapol_rx(drv->ctx, lladdr.sll_addr, buf, len);
+}
+
+
+static int i802_check_bridge(struct wpa_driver_capwap_data *drv,
+			     struct i802_bss *bss,
+			     const char *brname, const char *ifname)
+{
+	wpa_printf(MSG_DEBUG, "                                 7.i802_check_bridge\n");
+	int ifindex;
+	char in_br[IFNAMSIZ];
+
+	os_strlcpy(bss->brname, brname, IFNAMSIZ);
+	ifindex = if_nametoindex(brname);
+	if (ifindex == 0) {
+		/*
+		 * Bridge was configured, but the bridge device does
+		 * not exist. Try to add it now.
+		 */
+		if (linux_br_fake_add(drv->global->ioctl_sock, brname) < 0) {
+			wpa_printf(MSG_ERROR, "capwap: Failed to add the "
+				   "bridge interface %s: %s",
+				   brname, strerror(errno));
+			return -1;
+		}
+		bss->added_bridge = 1;
+		add_ifidx(drv, if_nametoindex(brname));
+	}
+
+	if (linux_br_fake_get(in_br, ifname) == 0) {
+		if (os_strcmp(in_br, brname) == 0)
+			return 0; /* already in the bridge */
+
+		wpa_printf(MSG_DEBUG, "capwap: Removing interface %s from "
+			   "bridge %s", ifname, in_br);
+		if (linux_br_fake_del_if(drv->global->ioctl_sock, in_br, ifname) <
+		    0) {
+			wpa_printf(MSG_ERROR, "capwap: Failed to "
+				   "remove interface %s from bridge "
+				   "%s: %s",
+				   ifname, brname, strerror(errno));
+			return -1;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Adding interface %s into bridge %s",
+		   ifname, brname);
+	if (linux_br_fake_add_if(drv->global->ioctl_sock, brname, ifname) < 0) {
+		wpa_printf(MSG_ERROR, "capwap: Failed to add interface %s "
+			   "into bridge %s: %s",
+			   ifname, brname, strerror(errno));
+		return -1;
+	}
+	bss->added_if_into_bridge = 1;
+
+	return 0;
+}
+
+static void *i802_init(struct hostapd_data *hapd,
+		       struct wpa_init_params *params)
+{
+	wpa_printf(MSG_DEBUG, "                         1.i802_init\n");
+	struct wpa_driver_capwap_data *drv;
+	struct i802_bss *bss;
+	size_t i;
+	char brname[IFNAMSIZ];
+	int ifindex, br_ifindex;
+	int br_added = 0;
+
+	bss = wpa_driver_capwap_init(hapd, params->ifname,
+				      params->global_priv);
+	if (bss == NULL)
+		return NULL;
+
+	drv = bss->drv;
+	drv->nlmode = NL80211_IFTYPE_AP;
+	drv->eapol_sock = -1;
+
+	if (linux_br_fake_get(brname, params->ifname) == 0) {
+		wpa_printf(MSG_DEBUG, "capwap: Interface %s is in bridge %s",
+			   params->ifname, brname);
+		br_ifindex = if_nametoindex(brname);
+	} else {
+		brname[0] = '\0';
+		br_ifindex = 0;
+	}
+
+	for (i = 0; i < params->num_bridge; i++) {
+		if (params->bridge[i]) {
+			ifindex = if_nametoindex(params->bridge[i]);
+			if (ifindex)
+				add_ifidx(drv, ifindex);
+			if (ifindex == br_ifindex)
+				br_added = 1;
+		}
+	}
+	if (!br_added && br_ifindex &&
+	    (params->num_bridge == 0 || !params->bridge[0]))
+		add_ifidx(drv, br_ifindex);
+
+	/* start listening for EAPOL on the default AP interface */
+	add_ifidx(drv, drv->ifindex);
+
+	if (linux_set_fake_iface_flags(drv->global->ioctl_sock, bss->ifname, 0))
+		goto failed;
+
+	if (params->bssid) {
+		if (linux_set_fake_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
+				       params->bssid))
+			goto failed;
+	}
+
+	if (wpa_driver_capwap_set_mode(bss, drv->nlmode)) {
+		wpa_printf(MSG_ERROR, "capwap: Failed to set interface %s "
+			   "into AP mode", bss->ifname);
+		goto failed;
+	}
+
+	if (params->num_bridge && params->bridge[0] &&
+	    i802_check_bridge(drv, bss, params->bridge[0], params->ifname) < 0)
+		goto failed;
+
+	if (linux_set_fake_iface_flags(drv->global->ioctl_sock, bss->ifname, 1))
+		goto failed;
+
+	drv->eapol_sock = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_PAE));
+	if (drv->eapol_sock < 0) {
+		perror("socket(PF_PACKET, SOCK_DGRAM, ETH_P_PAE)");
+		goto failed;
+	}
+
+	if (linux_get_fake_ifhwaddr(drv->global->ioctl_sock, bss->ifname,  params->own_addr))        goto failed;
+
+	generic_ac_info.pseudo_interface = params->ifname;
+	void (*pointer_inject_frame)(void *, unsigned char*,int);
+	pointer_inject_frame = AC_inject_frame_in_hostapd;
+	
+	generic_ac_info.fd_ipc = start_ipc(drv->ctx, pointer_inject_frame);
+
+	capability_get_mac(generic_ac_info.own_mac_addr);
+	memcpy(drv->addr,generic_ac_info.own_mac_addr, ETH_ALEN);
+	memcpy(params->own_addr,generic_ac_info.own_mac_addr, ETH_ALEN);
+	if(generic_ac_info.fd_ipc<=0){
+		wpa_printf(MSG_ERROR, "Error: start_ipc");
+		return;
+	}
+
+	return bss;
+
+failed:
+	wpa_driver_capwap_deinit(bss);
+	return NULL;
+}
+
+
+static void i802_deinit(void *priv)
+{
+	struct i802_bss *bss = priv;
+	ipc_send_DEL_WLAN(generic_ac_info.fd_ipc);
+	end_ipc(generic_ac_info.fd_ipc);
+	wpa_driver_capwap_deinit(bss);
+}
+
+#endif /* HOSTAPD */
+
+
+static enum capwap_iftype wpa_driver_capwap_if_type(
+	enum wpa_driver_if_type type)
+{
+	switch (type) {
+	case WPA_IF_STATION:
+		return NL80211_IFTYPE_STATION;
+	case WPA_IF_P2P_CLIENT:
+	case WPA_IF_P2P_GROUP:
+		return NL80211_IFTYPE_P2P_CLIENT;
+	case WPA_IF_AP_VLAN:
+		return NL80211_IFTYPE_AP_VLAN;
+	case WPA_IF_AP_BSS:
+		return NL80211_IFTYPE_AP;
+	case WPA_IF_P2P_GO:
+		return NL80211_IFTYPE_P2P_GO;
+	}
+	return -1;
+}
+
+
+#ifdef CONFIG_P2P
+
+static int capwap_addr_in_use(struct capwap_global *global, const u8 *addr)
+{
+	struct wpa_driver_capwap_data *drv;
+	dl_list_for_each(drv, &global->interfaces,
+			 struct wpa_driver_capwap_data, list) {
+		if (os_memcmp(addr, drv->first_bss.addr, ETH_ALEN) == 0)
+			return 1;
+	}
+	return 0;
+}
+
+
+static int capwap_p2p_interface_addr(struct wpa_driver_capwap_data *drv,
+				      u8 *new_addr)
+{
+	unsigned int idx;
+
+	if (!drv->global)
+		return -1;
+
+	os_memcpy(new_addr, drv->first_bss.addr, ETH_ALEN);
+	for (idx = 0; idx < 64; idx++) {
+		new_addr[0] = drv->first_bss.addr[0] | 0x02;
+		new_addr[0] ^= idx << 2;
+		if (!capwap_addr_in_use(drv->global, new_addr))
+			break;
+	}
+	if (idx == 64)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: Assigned new P2P Interface Address "
+		   MACSTR, MAC2STR(new_addr));
+
+	return 0;
+}
+
+#endif /* CONFIG_P2P */
+
+
+static int wpa_driver_capwap_if_add(void *priv, enum wpa_driver_if_type type,
+				     const char *ifname, const u8 *addr,
+				     void *bss_ctx, void **drv_priv,
+				     char *force_ifname, u8 *if_addr,
+				     const char *bridge)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ifidx;
+#ifdef HOSTAPD
+	struct i802_bss *new_bss = NULL;
+
+	if (type == WPA_IF_AP_BSS) {
+		new_bss = os_zalloc(sizeof(*new_bss));
+		if (new_bss == NULL)
+			return -1;
+	}
+#endif /* HOSTAPD */
+
+	if (addr)
+		os_memcpy(if_addr, addr, ETH_ALEN);
+	ifidx = capwap_create_iface(drv, ifname,
+				     wpa_driver_capwap_if_type(type), addr,
+				     0);
+	if (ifidx < 0) {
+#ifdef HOSTAPD
+		os_free(new_bss);
+#endif /* HOSTAPD */
+		return -1;
+	}
+
+	if (!addr &&
+	    linux_get_fake_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
+			       if_addr) < 0) {
+		capwap_remove_iface(drv, ifidx);
+		return -1;
+	}
+
+#ifdef CONFIG_P2P
+	if (!addr &&
+	    (type == WPA_IF_P2P_CLIENT || type == WPA_IF_P2P_GROUP ||
+	     type == WPA_IF_P2P_GO)) {
+		/* Enforce unique P2P Interface Address */
+		u8 new_addr[ETH_ALEN], own_addr[ETH_ALEN];
+
+		if (linux_get_fake_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
+				       own_addr) < 0 ||
+		    linux_get_fake_ifhwaddr(drv->global->ioctl_sock, ifname,
+				       new_addr) < 0) {
+			capwap_remove_iface(drv, ifidx);
+			return -1;
+		}
+		if (os_memcmp(own_addr, new_addr, ETH_ALEN) == 0) {
+			wpa_printf(MSG_DEBUG, "capwap: Allocate new address "
+				   "for P2P group interface");
+			if (capwap_p2p_interface_addr(drv, new_addr) < 0) {
+				capwap_remove_iface(drv, ifidx);
+				return -1;
+			}
+			if (linux_set_fake_ifhwaddr(drv->global->ioctl_sock, ifname,
+					       new_addr) < 0) {
+				capwap_remove_iface(drv, ifidx);
+				return -1;
+			}
+		}
+		os_memcpy(if_addr, new_addr, ETH_ALEN);
+	}
+#endif /* CONFIG_P2P */
+
+#ifdef HOSTAPD
+	if (bridge &&
+	    i802_check_bridge(drv, new_bss, bridge, ifname) < 0) {
+		wpa_printf(MSG_ERROR, "capwap: Failed to add the new "
+			   "interface %s to a bridge %s", ifname, bridge);
+		capwap_remove_iface(drv, ifidx);
+		os_free(new_bss);
+		return -1;
+	}
+
+	if (type == WPA_IF_AP_BSS) {
+		if (linux_set_fake_iface_flags(drv->global->ioctl_sock, ifname, 1))
+		{
+			capwap_remove_iface(drv, ifidx);
+			os_free(new_bss);
+			return -1;
+		}
+		os_strlcpy(new_bss->ifname, ifname, IFNAMSIZ);
+		os_memcpy(new_bss->addr, if_addr, ETH_ALEN);
+		new_bss->ifindex = ifidx;
+		new_bss->drv = drv;
+		new_bss->next = drv->first_bss.next;
+		new_bss->freq = drv->first_bss.freq;
+		new_bss->ctx = bss_ctx;
+		drv->first_bss.next = new_bss;
+		if (drv_priv)
+			*drv_priv = new_bss;
+		capwap_init_bss(new_bss);
+
+		/* Subscribe management frames for this WPA_IF_AP_BSS */
+		if (capwap_setup_ap(new_bss))
+			return -1;
+	}
+#endif /* HOSTAPD */
+
+	if (drv->global)
+		drv->global->if_add_ifindex = ifidx;
+
+	return 0;
+}
+
+
+static int wpa_driver_capwap_if_remove(struct i802_bss *bss,
+					enum wpa_driver_if_type type,
+					const char *ifname)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ifindex = if_nametoindex(ifname);
+
+	wpa_printf(MSG_DEBUG, "capwap: %s(type=%d ifname=%s) ifindex=%d",
+		   __func__, type, ifname, ifindex);
+	if (ifindex <= 0)
+		return -1;
+
+	capwap_remove_iface(drv, ifindex);
+
+#ifdef HOSTAPD
+	if (type != WPA_IF_AP_BSS)
+		return 0;
+
+	if (bss->added_if_into_bridge) {
+		if (linux_br_fake_del_if(drv->global->ioctl_sock, bss->brname,
+				    bss->ifname) < 0)
+			wpa_printf(MSG_INFO, "capwap: Failed to remove "
+				   "interface %s from bridge %s: %s",
+				   bss->ifname, bss->brname, strerror(errno));
+	}
+	if (bss->added_bridge) {
+		if (linux_br_fake_del(drv->global->ioctl_sock, bss->brname) < 0)
+			wpa_printf(MSG_INFO, "capwap: Failed to remove "
+				   "bridge %s: %s",
+				   bss->brname, strerror(errno));
+	}
+
+	if (bss != &drv->first_bss) {
+		struct i802_bss *tbss;
+
+		for (tbss = &drv->first_bss; tbss; tbss = tbss->next) {
+			if (tbss->next == bss) {
+				tbss->next = bss->next;
+				/* Unsubscribe management frames */
+				capwap_teardown_ap(bss);
+				capwap_destroy_bss(bss);
+				os_free(bss);
+				bss = NULL;
+				break;
+			}
+		}
+		if (bss)
+			wpa_printf(MSG_INFO, "capwap: %s - could not find "
+				   "BSS %p in the list", __func__, bss);
+	}
+#endif /* HOSTAPD */
+
+	return 0;
+}
+
+
+static int cookie_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	u64 *cookie = arg;
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	if (tb[NL80211_ATTR_COOKIE])
+		*cookie = nla_get_u64(tb[NL80211_ATTR_COOKIE]);
+	return NL_SKIP;
+}
+
+
+static int capwap_send_frame_cmd(struct i802_bss *bss,
+				  unsigned int freq, unsigned int wait,
+				  const u8 *buf, size_t buf_len,
+				  u64 *cookie_out, int no_cck, int no_ack,
+				  int offchanok)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	u64 cookie;
+	int ret = -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: CMD_FRAME freq=%u wait=%u no_cck=%d "
+		   "no_ack=%d offchanok=%d",
+		   freq, wait, no_cck, no_ack, offchanok);
+	capwap_cmd(drv, msg, 0, NL80211_CMD_FRAME);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);
+	if (wait)
+		NLA_PUT_U32(msg, NL80211_ATTR_DURATION, wait);
+	if (offchanok && (drv->capa.flags & WPA_DRIVER_FLAGS_OFFCHANNEL_TX))
+		NLA_PUT_FLAG(msg, NL80211_ATTR_OFFCHANNEL_TX_OK);
+	if (no_cck)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_TX_NO_CCK_RATE);
+	if (no_ack)
+		NLA_PUT_FLAG(msg, NL80211_ATTR_DONT_WAIT_FOR_ACK);
+
+	NLA_PUT(msg, NL80211_ATTR_FRAME, buf_len, buf);
+
+	cookie = 0;
+	ret = send_and_recv_msgs(drv, msg, cookie_handler, &cookie);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Frame command failed: ret=%d "
+			   "(%s) (freq=%u wait=%u)", ret, strerror(-ret),
+			   freq, wait);
+		goto nla_put_failure;
+	}
+	wpa_printf(MSG_DEBUG, "capwap: Frame TX command accepted%s; "
+		   "cookie 0x%llx", no_ack ? " (no ACK)" : "",
+		   (long long unsigned int) cookie);
+
+	if (cookie_out)
+		*cookie_out = no_ack ? (u64) -1 : cookie;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wpa_driver_capwap_send_action(struct i802_bss *bss,
+					  unsigned int freq,
+					  unsigned int wait_time,
+					  const u8 *dst, const u8 *src,
+					  const u8 *bssid,
+					  const u8 *data, size_t data_len,
+					  int no_cck)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret = -1;
+	u8 *buf;
+	struct ieee80211_hdr *hdr;
+
+	wpa_printf(MSG_DEBUG, "capwap: Send Action frame (ifindex=%d, "
+		   "freq=%u MHz wait=%d ms no_cck=%d)",
+		   drv->ifindex, freq, wait_time, no_cck);
+
+	buf = os_zalloc(24 + data_len);
+	if (buf == NULL)
+		return ret;
+	os_memcpy(buf + 24, data, data_len);
+	hdr = (struct ieee80211_hdr *) buf;
+	hdr->frame_control =
+		IEEE80211_FC(WLAN_FC_TYPE_MGMT, WLAN_FC_STYPE_ACTION);
+	os_memcpy(hdr->addr1, dst, ETH_ALEN);
+	os_memcpy(hdr->addr2, src, ETH_ALEN);
+	os_memcpy(hdr->addr3, bssid, ETH_ALEN);
+
+	if (is_ap_interface(drv->nlmode))
+		ret = wpa_driver_capwap_send_mlme(bss, buf, 24 + data_len,
+						   0, freq, no_cck, 1,
+						   wait_time);
+	else
+		ret = capwap_send_frame_cmd(bss, freq, wait_time, buf,
+					     24 + data_len,
+					     &drv->send_action_cookie,
+					     no_cck, 0, 1);
+
+	os_free(buf);
+	return ret;
+}
+
+
+static void wpa_driver_capwap_send_action_cancel_wait(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return;
+
+	wpa_printf(MSG_DEBUG, "capwap: Cancel TX frame wait: cookie=0x%llx",
+		   (long long unsigned int) drv->send_action_cookie);
+	capwap_cmd(drv, msg, 0, NL80211_CMD_FRAME_WAIT_CANCEL);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U64(msg, NL80211_ATTR_COOKIE, drv->send_action_cookie);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret)
+		wpa_printf(MSG_DEBUG, "capwap: wait cancel failed: ret=%d "
+			   "(%s)", ret, strerror(-ret));
+
+ nla_put_failure:
+	nlmsg_free(msg);
+}
+
+
+static int wpa_driver_capwap_remain_on_channel(void *priv, unsigned int freq,
+						unsigned int duration)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+	u64 cookie;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_REMAIN_ON_CHANNEL);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);
+	NLA_PUT_U32(msg, NL80211_ATTR_DURATION, duration);
+
+	cookie = 0;
+	ret = send_and_recv_msgs(drv, msg, cookie_handler, &cookie);
+	msg = NULL;
+	if (ret == 0) {
+		wpa_printf(MSG_DEBUG, "capwap: Remain-on-channel cookie "
+			   "0x%llx for freq=%u MHz duration=%u",
+			   (long long unsigned int) cookie, freq, duration);
+		drv->remain_on_chan_cookie = cookie;
+		drv->pending_remain_on_chan = 1;
+		return 0;
+	}
+	wpa_printf(MSG_DEBUG, "capwap: Failed to request remain-on-channel "
+		   "(freq=%d duration=%u): %d (%s)",
+		   freq, duration, ret, strerror(-ret));
+nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
+
+static int wpa_driver_capwap_cancel_remain_on_channel(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	if (!drv->pending_remain_on_chan) {
+		wpa_printf(MSG_DEBUG, "capwap: No pending remain-on-channel "
+			   "to cancel");
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "capwap: Cancel remain-on-channel with cookie "
+		   "0x%llx",
+		   (long long unsigned int) drv->remain_on_chan_cookie);
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U64(msg, NL80211_ATTR_COOKIE, drv->remain_on_chan_cookie);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret == 0)
+		return 0;
+	wpa_printf(MSG_DEBUG, "capwap: Failed to cancel remain-on-channel: "
+		   "%d (%s)", ret, strerror(-ret));
+nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
+
+static int wpa_driver_capwap_probe_req_report(struct i802_bss *bss, int report)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+
+	if (!report) {
+		if (bss->nl_preq && drv->device_ap_sme &&
+		    is_ap_interface(drv->nlmode)) {
+			/*
+			 * Do not disable Probe Request reporting that was
+			 * enabled in capwap_setup_ap().
+			 */
+			wpa_printf(MSG_DEBUG, "capwap: Skip disabling of "
+				   "Probe Request reporting nl_preq=%p while "
+				   "in AP mode", bss->nl_preq);
+		} else if (bss->nl_preq) {
+			wpa_printf(MSG_DEBUG, "capwap: Disable Probe Request "
+				   "reporting nl_preq=%p", bss->nl_preq);
+			eloop_unregister_read_sock(
+				nl_socket_get_fd(bss->nl_preq));
+		        nl_destroy_cache(&bss->nl_preq_cache);
+			nl_destroy_handles(&bss->nl_preq);
+		}
+		return 0;
+	}
+
+	if (bss->nl_preq) {
+		wpa_printf(MSG_DEBUG, "capwap: Probe Request reporting "
+			   "already on! nl_preq=%p", bss->nl_preq);
+		return 0;
+	}
+
+	bss->nl_preq = nl_create_handle(drv->global->nl_cb, "preq");
+        bss->nl_preq_cache = nl_create_cache(bss->nl_preq);
+	if (bss->nl_preq == NULL)
+		return -1;
+	wpa_printf(MSG_DEBUG, "capwap: Enable Probe Request "
+		   "reporting nl_preq=%p", bss->nl_preq);
+
+	if (capwap_register_frame(bss, bss->nl_preq,
+				   (WLAN_FC_TYPE_MGMT << 2) |
+				   (WLAN_FC_STYPE_PROBE_REQ << 4),
+				   NULL, 0) < 0)
+		goto out_err;
+
+	eloop_register_read_sock(nl_socket_get_fd(bss->nl_preq),
+				 wpa_driver_capwap_event_receive, bss->nl_cb,
+				 bss->nl_preq);
+
+	return 0;
+
+ out_err:
+        nl_destroy_cache(&bss->nl_preq_cache);
+	nl_destroy_handles(&bss->nl_preq);
+	return -1;
+}
+
+
+static int capwap_disable_11b_rates(struct wpa_driver_capwap_data *drv,
+				     int ifindex, int disabled)
+{
+	struct nl_msg *msg;
+	struct nlattr *bands, *band;
+	int ret;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_TX_BITRATE_MASK);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
+
+	bands = nla_nest_start(msg, NL80211_ATTR_TX_RATES);
+	if (!bands)
+		goto nla_put_failure;
+
+	/*
+	 * Disable 2 GHz rates 1, 2, 5.5, 11 Mbps by masking out everything
+	 * else apart from 6, 9, 12, 18, 24, 36, 48, 54 Mbps from non-MCS
+	 * rates. All 5 GHz rates are left enabled.
+	 */
+	band = nla_nest_start(msg, NL80211_BAND_2GHZ);
+	if (!band)
+		goto nla_put_failure;
+	if (disabled) {
+		NLA_PUT(msg, NL80211_TXRATE_LEGACY, 8,
+			"\x0c\x12\x18\x24\x30\x48\x60\x6c");
+	}
+	nla_nest_end(msg, band);
+
+	nla_nest_end(msg, bands);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "capwap: Set TX rates failed: ret=%d "
+			   "(%s)", ret, strerror(-ret));
+	} else
+		drv->disabled_11b_rates = disabled;
+
+	return ret;
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -1;
+}
+
+
+static int wpa_driver_capwap_deinit_ap(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (!is_ap_interface(drv->nlmode))
+		return -1;
+	wpa_driver_capwap_del_beacon(drv);
+	return wpa_driver_capwap_set_mode(priv, NL80211_IFTYPE_STATION);
+}
+
+static int wpa_driver_capwap_deinit_p2p_cli(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (drv->nlmode != NL80211_IFTYPE_P2P_CLIENT)
+		return -1;
+	return wpa_driver_capwap_set_mode(priv, NL80211_IFTYPE_STATION);
+}
+
+
+static void wpa_driver_capwap_resume(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	if (linux_set_fake_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
+		wpa_printf(MSG_DEBUG, "capwap: Failed to set interface up on "
+			   "resume event");
+	}
+}
+
+
+static int capwap_send_ft_action(void *priv, u8 action, const u8 *target_ap,
+				  const u8 *ies, size_t ies_len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int ret;
+	u8 *data, *pos;
+	size_t data_len;
+	const u8 *own_addr = bss->addr;
+
+	if (action != 1) {
+		wpa_printf(MSG_ERROR, "capwap: Unsupported send_ft_action "
+			   "action %d", action);
+		return -1;
+	}
+
+	/*
+	 * Action frame payload:
+	 * Category[1] = 6 (Fast BSS Transition)
+	 * Action[1] = 1 (Fast BSS Transition Request)
+	 * STA Address
+	 * Target AP Address
+	 * FT IEs
+	 */
+
+	data_len = 2 + 2 * ETH_ALEN + ies_len;
+	data = os_malloc(data_len);
+	if (data == NULL)
+		return -1;
+	pos = data;
+	*pos++ = 0x06; /* FT Action category */
+	*pos++ = action;
+	os_memcpy(pos, own_addr, ETH_ALEN);
+	pos += ETH_ALEN;
+	os_memcpy(pos, target_ap, ETH_ALEN);
+	pos += ETH_ALEN;
+	os_memcpy(pos, ies, ies_len);
+
+	ret = wpa_driver_capwap_send_action(bss, drv->assoc_freq, 0,
+					     drv->bssid, own_addr, drv->bssid,
+					     data, data_len, 0);
+	os_free(data);
+
+	return ret;
+}
+
+
+static int capwap_signal_monitor(void *priv, int threshold, int hysteresis)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg, *cqm = NULL;
+	int ret = -1;
+
+	wpa_printf(MSG_DEBUG, "capwap: Signal monitor threshold=%d "
+		   "hysteresis=%d", threshold, hysteresis);
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_CQM);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+
+	cqm = nlmsg_alloc();
+	if (cqm == NULL)
+		goto nla_put_failure;
+
+	NLA_PUT_U32(cqm, NL80211_ATTR_CQM_RSSI_THOLD, threshold);
+	NLA_PUT_U32(cqm, NL80211_ATTR_CQM_RSSI_HYST, hysteresis);
+	if (nla_put_nested(msg, NL80211_ATTR_CQM, cqm) < 0)
+		goto nla_put_failure;
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
+	msg = NULL;
+
+nla_put_failure:
+	nlmsg_free(cqm);
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int capwap_signal_poll(void *priv, struct wpa_signal_info *si)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	int res;
+
+	os_memset(si, 0, sizeof(*si));
+	res = capwap_get_link_signal(drv, si);
+	if (res != 0)
+		return res;
+
+	return capwap_get_link_noise(drv, si);
+}
+
+
+static int wpa_driver_capwap_shared_freq(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct wpa_driver_capwap_data *driver;
+	int freq = 0;
+
+	/*
+	 * If the same PHY is in connected state with some other interface,
+	 * then retrieve the assoc freq.
+	 */
+	wpa_printf(MSG_DEBUG, "capwap: Get shared freq for PHY %s",
+		   drv->phyname);
+
+	dl_list_for_each(driver, &drv->global->interfaces,
+			 struct wpa_driver_capwap_data, list) {
+		if (drv == driver ||
+		    os_strcmp(drv->phyname, driver->phyname) != 0 ||
+		    !driver->associated)
+			continue;
+
+		wpa_printf(MSG_DEBUG, "capwap: Found a match for PHY %s - %s "
+			   MACSTR,
+			   driver->phyname, driver->first_bss.ifname,
+			   MAC2STR(driver->first_bss.addr));
+		if (is_ap_interface(driver->nlmode))
+			freq = driver->first_bss.freq;
+		else
+			freq = capwap_get_assoc_freq(driver);
+		wpa_printf(MSG_DEBUG, "capwap: Shared freq for PHY %s: %d",
+			   drv->phyname, freq);
+	}
+
+	if (!freq)
+		wpa_printf(MSG_DEBUG, "capwap: No shared interface for "
+			   "PHY (%s) in associated state", drv->phyname);
+
+	return freq;
+}
+
+
+static int capwap_send_frame(void *priv, const u8 *data, size_t data_len,
+			      int encrypt)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_send_frame(bss, data, data_len, encrypt, 0,
+					     0, 0, 0, 0);
+}
+
+
+static int capwap_set_param(void *priv, const char *param)
+{
+	wpa_printf(MSG_DEBUG, "capwap: driver param='%s'", param);
+	if (param == NULL)
+		return 0;
+
+#ifdef CONFIG_P2P
+	if (os_strstr(param, "use_p2p_group_interface=1")) {
+		struct i802_bss *bss = priv;
+		struct wpa_driver_capwap_data *drv = bss->drv;
+
+		wpa_printf(MSG_DEBUG, "capwap: Use separate P2P group "
+			   "interface");
+		drv->capa.flags |= WPA_DRIVER_FLAGS_P2P_CONCURRENT;
+		drv->capa.flags |= WPA_DRIVER_FLAGS_P2P_MGMT_AND_NON_P2P;
+	}
+#endif /* CONFIG_P2P */
+
+	return 0;
+}
+
+
+static void * capwap_global_init(void)
+{
+	wpa_printf(MSG_DEBUG,"                          1.capwap_global_init\n");
+	struct capwap_global *global;
+	struct netlink_config *cfg;
+
+	global = os_zalloc(sizeof(*global));
+	if (global == NULL)
+		return NULL;
+	global->ioctl_sock = -1;
+	dl_list_init(&global->interfaces);
+	global->if_add_ifindex = -1;
+
+	cfg = os_zalloc(sizeof(*cfg));
+	if (cfg == NULL)
+		goto err;
+
+	cfg->ctx = global;
+	cfg->newlink_cb = wpa_driver_capwap_event_rtm_newlink;
+	cfg->dellink_cb = wpa_driver_capwap_event_rtm_dellink;
+	global->netlink = netlink_fake_init(cfg);
+	if (global->netlink == NULL) {
+		os_free(cfg);
+		goto err;
+	}
+
+	if (wpa_driver_capwap_init_nl_global(global) < 0)
+		goto err;
+
+	global->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (global->ioctl_sock < 0) {
+		perror("socket(PF_INET,SOCK_DGRAM)");
+		goto err;
+	}
+
+	return global;
+
+err:
+	capwap_global_deinit(global);
+	return NULL;
+}
+
+
+static void capwap_global_deinit(void *priv)
+{
+	struct capwap_global *global = priv;
+	if (global == NULL)
+		return;
+	if (!dl_list_empty(&global->interfaces)) {
+		wpa_printf(MSG_ERROR, "capwap: %u interface(s) remain at "
+			   "capwap_global_deinit",
+			   dl_list_len(&global->interfaces));
+	}
+
+	if (global->netlink)
+		netlink_deinit(global->netlink);
+	if (global->capwap)
+		genl_family_put(global->capwap);
+
+
+        nl_destroy_cache(&global->nl_cache);
+	nl_destroy_handles(&global->nl);
+
+	if (global->nl_event) {
+		eloop_unregister_read_sock(
+			nl_socket_get_fd(global->nl_event));
+        	nl_destroy_cache(&global->nl_event_cache);
+		nl_destroy_handles(&global->nl_event);
+	}
+
+	nl_cb_put(global->nl_cb);
+
+	if (global->ioctl_sock >= 0)
+		close(global->ioctl_sock);
+
+	os_free(global);
+}
+
+
+static const char * capwap_get_radio_name(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	return drv->phyname;
+}
+
+
+static int capwap_pmkid(struct i802_bss *bss, int cmd, const u8 *bssid,
+			 const u8 *pmkid)
+{
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(bss->drv, msg, 0, cmd);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(bss->ifname));
+	if (pmkid)
+		NLA_PUT(msg, NL80211_ATTR_PMKID, 16, pmkid);
+	if (bssid)
+		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);
+
+	return send_and_recv_msgs(bss->drv, msg, NULL, NULL);
+ nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int capwap_add_pmkid(void *priv, const u8 *bssid, const u8 *pmkid)
+{
+	struct i802_bss *bss = priv;
+	wpa_printf(MSG_DEBUG, "capwap: Add PMKID for " MACSTR, MAC2STR(bssid));
+	return capwap_pmkid(bss, NL80211_CMD_SET_PMKSA, bssid, pmkid);
+}
+
+
+static int capwap_remove_pmkid(void *priv, const u8 *bssid, const u8 *pmkid)
+{
+	struct i802_bss *bss = priv;
+	wpa_printf(MSG_DEBUG, "capwap: Delete PMKID for " MACSTR,
+		   MAC2STR(bssid));
+	return capwap_pmkid(bss, NL80211_CMD_DEL_PMKSA, bssid, pmkid);
+}
+
+
+static int capwap_flush_pmkid(void *priv)
+{
+	struct i802_bss *bss = priv;
+	wpa_printf(MSG_DEBUG, "capwap: Flush PMKIDs");
+	return capwap_pmkid(bss, NL80211_CMD_FLUSH_PMKSA, NULL, NULL);
+}
+
+
+static void capwap_set_rekey_info(void *priv, const u8 *kek, const u8 *kck,
+				   const u8 *replay_ctr)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nlattr *replay_nested;
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_SET_REKEY_OFFLOAD);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+
+	replay_nested = nla_nest_start(msg, NL80211_ATTR_REKEY_DATA);
+	if (!replay_nested)
+		goto nla_put_failure;
+
+	NLA_PUT(msg, NL80211_REKEY_DATA_KEK, NL80211_KEK_LEN, kek);
+	NLA_PUT(msg, NL80211_REKEY_DATA_KCK, NL80211_KCK_LEN, kck);
+	NLA_PUT(msg, NL80211_REKEY_DATA_REPLAY_CTR, NL80211_REPLAY_CTR_LEN,
+		replay_ctr);
+
+	nla_nest_end(msg, replay_nested);
+
+	send_and_recv_msgs(drv, msg, NULL, NULL);
+	return;
+ nla_put_failure:
+	nlmsg_free(msg);
+}
+
+
+static void capwap_send_null_frame(struct i802_bss *bss, const u8 *own_addr,
+				    const u8 *addr, int qos)
+{
+	/* send data frame to poll STA and check whether
+	 * this frame is ACKed */
+	struct {
+		struct ieee80211_hdr hdr;
+		u16 qos_ctl;
+	} STRUCT_PACKED nulldata;
+	size_t size;
+
+	/* Send data frame to poll STA and check whether this frame is ACKed */
+
+	os_memset(&nulldata, 0, sizeof(nulldata));
+
+	if (qos) {
+		nulldata.hdr.frame_control =
+			IEEE80211_FC(WLAN_FC_TYPE_DATA,
+				     WLAN_FC_STYPE_QOS_NULL);
+		size = sizeof(nulldata);
+	} else {
+		nulldata.hdr.frame_control =
+			IEEE80211_FC(WLAN_FC_TYPE_DATA,
+				     WLAN_FC_STYPE_NULLFUNC);
+		size = sizeof(struct ieee80211_hdr);
+	}
+
+	nulldata.hdr.frame_control |= host_to_le16(WLAN_FC_FROMDS);
+	os_memcpy(nulldata.hdr.IEEE80211_DA_FROMDS, addr, ETH_ALEN);
+	os_memcpy(nulldata.hdr.IEEE80211_BSSID_FROMDS, own_addr, ETH_ALEN);
+	os_memcpy(nulldata.hdr.IEEE80211_SA_FROMDS, own_addr, ETH_ALEN);
+
+	if (wpa_driver_capwap_send_mlme(bss, (u8 *) &nulldata, size, 0, 0, 0,
+					 0, 0) < 0)
+		wpa_printf(MSG_DEBUG, "capwap_send_null_frame: Failed to "
+			   "send poll frame");
+}
+
+static void capwap_poll_client(void *priv, const u8 *own_addr, const u8 *addr,
+				int qos)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+
+	if (!drv->poll_command_supported) {
+		capwap_send_null_frame(bss, own_addr, addr, qos);
+		return;
+	}
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_PROBE_CLIENT);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
+
+	send_and_recv_msgs(drv, msg, NULL, NULL);
+	return;
+ nla_put_failure:
+	nlmsg_free(msg);
+}
+
+
+static int capwap_set_power_save(struct i802_bss *bss, int enabled)
+{
+	struct nl_msg *msg;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(bss->drv, msg, 0, NL80211_CMD_SET_POWER_SAVE);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_PS_STATE,
+		    enabled ? NL80211_PS_ENABLED : NL80211_PS_DISABLED);
+	return send_and_recv_msgs(bss->drv, msg, NULL, NULL);
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int capwap_set_p2p_powersave(void *priv, int legacy_ps, int opp_ps,
+				     int ctwindow)
+{
+	struct i802_bss *bss = priv;
+
+	wpa_printf(MSG_DEBUG, "capwap: set_p2p_powersave (legacy_ps=%d "
+		   "opp_ps=%d ctwindow=%d)", legacy_ps, opp_ps, ctwindow);
+
+	if (opp_ps != -1 || ctwindow != -1)
+		return -1; /* Not yet supported */
+
+	if (legacy_ps == -1)
+		return 0;
+	if (legacy_ps != 0 && legacy_ps != 1)
+		return -1; /* Not yet supported */
+
+	return capwap_set_power_save(bss, legacy_ps);
+}
+
+
+#ifdef CONFIG_TDLS
+
+static int capwap_send_tdls_mgmt(void *priv, const u8 *dst, u8 action_code,
+				  u8 dialog_token, u16 status_code,
+				  const u8 *buf, size_t len)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+
+	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_TDLS_SUPPORT))
+		return -EOPNOTSUPP;
+
+	if (!dst)
+		return -EINVAL;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_TDLS_MGMT);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, dst);
+	NLA_PUT_U8(msg, NL80211_ATTR_TDLS_ACTION, action_code);
+	NLA_PUT_U8(msg, NL80211_ATTR_TDLS_DIALOG_TOKEN, dialog_token);
+	NLA_PUT_U16(msg, NL80211_ATTR_STATUS_CODE, status_code);
+	NLA_PUT(msg, NL80211_ATTR_IE, len, buf);
+
+	return send_and_recv_msgs(drv, msg, NULL, NULL);
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+
+static int capwap_tdls_oper(void *priv, enum tdls_oper oper, const u8 *peer)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct nl_msg *msg;
+	enum nl80211_tdls_operation capwap_oper;
+
+	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_TDLS_SUPPORT))
+		return -EOPNOTSUPP;
+
+	switch (oper) {
+	case TDLS_DISCOVERY_REQ:
+		capwap_oper = NL80211_TDLS_DISCOVERY_REQ;
+		break;
+	case TDLS_SETUP:
+		capwap_oper = NL80211_TDLS_SETUP;
+		break;
+	case TDLS_TEARDOWN:
+		capwap_oper = NL80211_TDLS_TEARDOWN;
+		break;
+	case TDLS_ENABLE_LINK:
+		capwap_oper = NL80211_TDLS_ENABLE_LINK;
+		break;
+	case TDLS_DISABLE_LINK:
+		capwap_oper = NL80211_TDLS_DISABLE_LINK;
+		break;
+	case TDLS_ENABLE:
+		return 0;
+	case TDLS_DISABLE:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	capwap_cmd(drv, msg, 0, NL80211_CMD_TDLS_OPER);
+	NLA_PUT_U8(msg, NL80211_ATTR_TDLS_OPERATION, capwap_oper);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, peer);
+
+	return send_and_recv_msgs(drv, msg, NULL, NULL);
+
+nla_put_failure:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+#endif /* CONFIG TDLS */
+
+void AC_inject_frame_in_hostapd(void *priv, u8 *buf, int len){
+
+       struct i802_bss *bss = priv;
+       struct wpa_driver_capwap_data *drv = bss->drv;
+
+	int ret;
+	int datarate = 0, ssi_signal = 0;
+	int failed = 0, rxflags = 0;
+
+
+	if (len < 24) {
+		perror("recv");
+		return;
+	}
+
+	int type = AC_get_Type(buf ,len );
+
+
+	if( type == WLAN_FC_TYPE_DATA ){
+
+               if( isEAPOL_Frame(buf, len) ){
+			if(isCallBackFrame(buf,len,generic_ac_info.own_mac_addr)) {
+				wpa_printf(MSG_DEBUG, "EAPOL Data Frame 4 (%d)\n",len);
+				handle_tx_callback(drv->ctx, buf ,len , !failed);
+			}else{
+				wpa_printf(MSG_DEBUG, "EAPOL Data Frame 6 (%d)\n",len);
+				AC_handle_eapol(drv,buf,len);
+			}
+               }else{
+			handle_frame(drv, buf , len , datarate, ssi_signal);
+               }
+
+		int stype = AC_get_SubType(buf ,len );
+
+		/* Per ora scarto i pacchetti PROBE REQUEST */
+		if(stype == WLAN_FC_STYPE_PROBE_REQ) {
+			return;
+		}
+
+		if(isCallBackFrame(buf,len,generic_ac_info.own_mac_addr)) {
+			handle_tx_callback(drv->ctx, buf ,len , !failed);
+
+			if( stype == WLAN_FC_STYPE_ASSOC_RESP || stype == WLAN_FC_STYPE_REASSOC_RESP ){
+				ipc_send_add_station(generic_ac_info.fd_ipc,buf,len);
+			}
+		}else{
+			handle_frame(drv, buf , len , datarate, ssi_signal);
+
+			if( stype == WLAN_FC_STYPE_DISASSOC ){
+				ipc_send_del_station(generic_ac_info.fd_ipc, buf, len);
+			}
+		}
+	}else{
+		wpa_printf(MSG_ERROR,"Error: invalid/control 802.11 Type ");
+	}
+
+}
+
+#ifdef ANDROID
+
+typedef struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+} android_wifi_priv_cmd;
+
+static int drv_errors = 0;
+
+static void wpa_driver_send_hang_msg(struct wpa_driver_capwap_data *drv)
+{
+	drv_errors++;
+	if (drv_errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
+		drv_errors = 0;
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+	}
+}
+
+
+static int android_priv_cmd(struct i802_bss *bss, const char *cmd)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct ifreq ifr;
+	android_wifi_priv_cmd priv_cmd;
+	char buf[MAX_DRV_CMD_SIZE];
+	int ret;
+
+	os_memset(&ifr, 0, sizeof(ifr));
+	os_memset(&priv_cmd, 0, sizeof(priv_cmd));
+	os_strlcpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+
+	os_memset(buf, 0, sizeof(buf));
+	os_strlcpy(buf, cmd, sizeof(buf));
+
+	priv_cmd.buf = buf;
+	priv_cmd.used_len = sizeof(buf);
+	priv_cmd.total_len = sizeof(buf);
+	ifr.ifr_data = &priv_cmd;
+
+	ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr);
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "%s: failed to issue private commands",
+			   __func__);
+		wpa_driver_send_hang_msg(drv);
+		return ret;
+	}
+
+	drv_errors = 0;
+	return 0;
+}
+
+
+static int android_pno_start(struct i802_bss *bss,
+			     struct wpa_driver_scan_params *params)
+{
+	struct wpa_driver_capwap_data *drv = bss->drv;
+	struct ifreq ifr;
+	android_wifi_priv_cmd priv_cmd;
+	int ret = 0, i = 0, bp;
+	char buf[WEXT_PNO_MAX_COMMAND_SIZE];
+
+	bp = WEXT_PNOSETUP_HEADER_SIZE;
+	os_memcpy(buf, WEXT_PNOSETUP_HEADER, bp);
+	buf[bp++] = WEXT_PNO_TLV_PREFIX;
+	buf[bp++] = WEXT_PNO_TLV_VERSION;
+	buf[bp++] = WEXT_PNO_TLV_SUBVERSION;
+	buf[bp++] = WEXT_PNO_TLV_RESERVED;
+
+	while (i < WEXT_PNO_AMOUNT && (size_t) i < params->num_ssids) {
+		/* Check that there is enough space needed for 1 more SSID, the
+		 * other sections and null termination */
+		if ((bp + WEXT_PNO_SSID_HEADER_SIZE + MAX_SSID_LEN +
+		     WEXT_PNO_NONSSID_SECTIONS_SIZE + 1) >= (int) sizeof(buf))
+			break;
+		wpa_hexdump_ascii(MSG_DEBUG, "For PNO Scan",
+				  params->ssids[i].ssid,
+				  params->ssids[i].ssid_len);
+		buf[bp++] = WEXT_PNO_SSID_SECTION;
+		buf[bp++] = params->ssids[i].ssid_len;
+		os_memcpy(&buf[bp], params->ssids[i].ssid,
+			  params->ssids[i].ssid_len);
+		bp += params->ssids[i].ssid_len;
+		i++;
+	}
+
+	buf[bp++] = WEXT_PNO_SCAN_INTERVAL_SECTION;
+	os_snprintf(&buf[bp], WEXT_PNO_SCAN_INTERVAL_LENGTH + 1, "%x",
+		    WEXT_PNO_SCAN_INTERVAL);
+	bp += WEXT_PNO_SCAN_INTERVAL_LENGTH;
+
+	buf[bp++] = WEXT_PNO_REPEAT_SECTION;
+	os_snprintf(&buf[bp], WEXT_PNO_REPEAT_LENGTH + 1, "%x",
+		    WEXT_PNO_REPEAT);
+	bp += WEXT_PNO_REPEAT_LENGTH;
+
+	buf[bp++] = WEXT_PNO_MAX_REPEAT_SECTION;
+	os_snprintf(&buf[bp], WEXT_PNO_MAX_REPEAT_LENGTH + 1, "%x",
+		    WEXT_PNO_MAX_REPEAT);
+	bp += WEXT_PNO_MAX_REPEAT_LENGTH + 1;
+
+	memset(&ifr, 0, sizeof(ifr));
+	memset(&priv_cmd, 0, sizeof(priv_cmd));
+	os_strncpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+
+	priv_cmd.buf = buf;
+	priv_cmd.used_len = bp;
+	priv_cmd.total_len = bp;
+	ifr.ifr_data = &priv_cmd;
+
+	ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr);
+
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (pnosetup): %d",
+			   ret);
+		wpa_driver_send_hang_msg(drv);
+		return ret;
+	}
+
+	drv_errors = 0;
+
+	return android_priv_cmd(bss, "PNOFORCE 1");
+}
+
+
+static int android_pno_stop(struct i802_bss *bss)
+{
+	return android_priv_cmd(bss, "PNOFORCE 0");
+}
+
+#endif /* ANDROID */
+
+
+static int driver_capwap_set_key(const char *ifname, void *priv,
+				  enum wpa_alg alg, const u8 *addr,
+				  int key_idx, int set_tx,
+				  const u8 *seq, size_t seq_len,
+				  const u8 *key, size_t key_len)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_set_key(ifname, bss, alg, addr, key_idx,
+					  set_tx, seq, seq_len, key, key_len);
+}
+
+
+static int driver_capwap_scan2(void *priv,
+				struct wpa_driver_scan_params *params)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_scan(bss, params);
+}
+
+
+static int driver_capwap_deauthenticate(void *priv, const u8 *addr,
+					 int reason_code)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_deauthenticate(bss, addr, reason_code);
+}
+
+
+static int driver_capwap_authenticate(void *priv,
+				       struct wpa_driver_auth_params *params)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_authenticate(bss, params);
+}
+
+
+static void driver_capwap_deinit(void *priv)
+{
+	struct i802_bss *bss = priv;
+	wpa_driver_capwap_deinit(bss);
+}
+
+
+static int driver_capwap_if_remove(void *priv, enum wpa_driver_if_type type,
+				    const char *ifname)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_if_remove(bss, type, ifname);
+}
+
+
+static int driver_capwap_send_mlme(void *priv, const u8 *data,
+				    size_t data_len, int noack)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_send_mlme(bss, data, data_len, noack,
+					    0, 0, 0, 0);
+}
+
+
+static int driver_capwap_sta_remove(void *priv, const u8 *addr)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_sta_remove(bss, addr);
+}
+
+
+#if defined(HOSTAPD) || defined(CONFIG_AP)
+static int driver_capwap_set_sta_vlan(void *priv, const u8 *addr,
+				       const char *ifname, int vlan_id)
+{
+	struct i802_bss *bss = priv;
+	return i802_set_sta_vlan(bss, addr, ifname, vlan_id);
+}
+#endif /* HOSTAPD || CONFIG_AP */
+
+
+static int driver_capwap_read_sta_data(void *priv,
+					struct hostap_sta_driver_data *data,
+					const u8 *addr)
+{
+	struct i802_bss *bss = priv;
+	return i802_read_sta_data(bss, data, addr);
+}
+
+
+static int driver_capwap_send_action(void *priv, unsigned int freq,
+				      unsigned int wait_time,
+				      const u8 *dst, const u8 *src,
+				      const u8 *bssid,
+				      const u8 *data, size_t data_len,
+				      int no_cck)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_send_action(bss, freq, wait_time, dst, src,
+					      bssid, data, data_len, no_cck);
+}
+
+
+static int driver_capwap_probe_req_report(void *priv, int report)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_capwap_probe_req_report(bss, report);
+}
+
+
+const struct wpa_driver_ops wpa_driver_capwap_ops = {
+	.name = "capwap",
+	.desc = "Linux capwap/cfg80211",
+	.get_bssid = wpa_driver_capwap_get_bssid,
+	.get_ssid = wpa_driver_capwap_get_ssid,
+	.set_key = driver_capwap_set_key,
+	.scan2 = driver_capwap_scan2,
+	.sched_scan = wpa_driver_capwap_sched_scan,
+	.stop_sched_scan = wpa_driver_capwap_stop_sched_scan,
+	.get_scan_results2 = wpa_driver_capwap_get_scan_results,
+	.deauthenticate = driver_capwap_deauthenticate,
+	.authenticate = driver_capwap_authenticate,
+	.associate = wpa_driver_capwap_associate,
+	.global_init = capwap_global_init,
+	.global_deinit = capwap_global_deinit,
+	.init2 = wpa_driver_capwap_init,
+	.deinit = driver_capwap_deinit,
+	.get_capa = wpa_driver_capwap_get_capa,
+	.set_operstate = wpa_driver_capwap_set_operstate,
+	.set_supp_port = wpa_driver_capwap_set_supp_port,
+	.set_country = wpa_driver_capwap_set_country,
+	.set_ap = wpa_driver_capwap_set_ap,
+	.if_add = wpa_driver_capwap_if_add,
+	.if_remove = driver_capwap_if_remove,
+	.send_mlme = driver_capwap_send_mlme,
+	.get_hw_feature_data = wpa_driver_capwap_get_hw_feature_data,
+	.sta_add = wpa_driver_capwap_sta_add,
+	.sta_remove = driver_capwap_sta_remove,
+	.hapd_send_eapol = wpa_driver_capwap_hapd_send_eapol,
+	.sta_set_flags = wpa_driver_capwap_sta_set_flags,
+	//.inject_frame_in_hostapd = AC_inject_frame_in_hostapd,
+#ifdef HOSTAPD
+	.hapd_init = i802_init,
+	.hapd_deinit = i802_deinit,
+	.set_wds_sta = i802_set_wds_sta,
+#endif /* HOSTAPD */
+#if defined(HOSTAPD) || defined(CONFIG_AP)
+	.get_seqnum = i802_get_seqnum,
+	.flush = i802_flush,
+	.get_inact_sec = i802_get_inact_sec,
+	.sta_clear_stats = i802_sta_clear_stats,
+	.set_rts = i802_set_rts,
+	.set_frag = i802_set_frag,
+	.set_tx_queue_params = i802_set_tx_queue_params,
+	.set_sta_vlan = driver_capwap_set_sta_vlan,
+	.sta_deauth = i802_sta_deauth,
+	.sta_disassoc = i802_sta_disassoc,
+#endif /* HOSTAPD || CONFIG_AP */
+	.read_sta_data = driver_capwap_read_sta_data,
+	.set_freq = i802_set_freq,
+	.send_action = driver_capwap_send_action,
+	.send_action_cancel_wait = wpa_driver_capwap_send_action_cancel_wait,
+	.remain_on_channel = wpa_driver_capwap_remain_on_channel,
+	.cancel_remain_on_channel =
+	wpa_driver_capwap_cancel_remain_on_channel,
+	.probe_req_report = driver_capwap_probe_req_report,
+	.deinit_ap = wpa_driver_capwap_deinit_ap,
+	.deinit_p2p_cli = wpa_driver_capwap_deinit_p2p_cli,
+	.resume = wpa_driver_capwap_resume,
+	.send_ft_action = capwap_send_ft_action,
+	.signal_monitor = capwap_signal_monitor,
+	.signal_poll = capwap_signal_poll,
+	.send_frame = capwap_send_frame,
+	.shared_freq = wpa_driver_capwap_shared_freq,
+	.set_param = capwap_set_param,
+	.get_radio_name = capwap_get_radio_name,
+	.add_pmkid = capwap_add_pmkid,
+	.remove_pmkid = capwap_remove_pmkid,
+	.flush_pmkid = capwap_flush_pmkid,
+	.set_rekey_info = capwap_set_rekey_info,
+	.poll_client = capwap_poll_client,
+	.set_p2p_powersave = capwap_set_p2p_powersave,
+#ifdef CONFIG_TDLS
+	.send_tdls_mgmt = capwap_send_tdls_mgmt,
+	.tdls_oper = capwap_tdls_oper,
+#endif /* CONFIG_TDLS */
+	.stop_ap = wpa_driver_capwap_stop_ap,
+};
diff -purN hostapd-20130302/src/drivers/driver.h hostapd-20130302-linux/src/drivers/driver.h
--- hostapd-20130302/src/drivers/driver.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/driver.h	2013-07-04 11:17:51.000000000 -0400
@@ -19,6 +19,7 @@
 
 #define WPA_SUPPLICANT_DRIVER_VERSION 4
 
+#include "drivers/nl80211_copy.h"
 #include "common/defs.h"
 
 #define HOSTAPD_CHAN_DISABLED 0x00000001
@@ -363,6 +364,13 @@ struct wpa_driver_associate_params {
 	 */
 	int freq;
 
+	int beacon_interval;
+	int fixed_freq;
+	unsigned char rates[NL80211_MAX_SUPP_RATES];
+	int mcast_rate;
+	int ht_set;
+	unsigned int htmode;
+
 	/**
 	 * bg_scan_period - Background scan period in seconds, 0 to disable
 	 * background scan, or -1 to indicate no change to default driver
@@ -982,6 +990,8 @@ struct wpa_init_params {
 	int use_pae_group_addr;
 	char **bridge;
 	size_t num_bridge;
+	char *tap;
+	char *br_name;
 
 	u8 *own_addr; /* buffer for writing own MAC address */
 };
@@ -1223,6 +1233,15 @@ struct wpa_driver_ops {
 	 */
 	int (*deauthenticate)(void *priv, const u8 *addr, int reason_code);
 
+        /**
+         * disassociate - Benunets added for capwap
+         */
+        int (*disassociate)(void *priv,  const u8 *addr,
+			int reason_code);
+
+	int (*set_rate_sets)(void *priv, int *supp_rates, int *basic_rates,
+			int mode);
+
 	/**
 	 * associate - Request driver to associate
 	 * @priv: private driver interface data
@@ -2071,6 +2090,9 @@ struct wpa_driver_ops {
 	 */
 	int (*probe_req_report)(void *priv, int report);
 
+
+	int (*stop_ap)(void *priv);
+
 	/**
 	 * deinit_ap - Deinitialize AP mode
 	 * @priv: Private driver interface data
@@ -3726,8 +3748,8 @@ union wpa_event_data {
  * Driver wrapper code should call this function whenever an event is received
  * from the driver.
  */
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data);
+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
+				    union wpa_event_data *data);
 
 
 /*
diff -purN hostapd-20130302/src/drivers/driver_madwifi.c hostapd-20130302-linux/src/drivers/driver_madwifi.c
--- hostapd-20130302/src/drivers/driver_madwifi.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/driver_madwifi.c	2013-07-04 11:17:51.000000000 -0400
@@ -453,7 +453,9 @@ wpa_driver_madwifi_set_key(const char *i
 
 	memset(&wk, 0, sizeof(wk));
 	wk.ik_type = cipher;
-	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
+	wk.ik_flags = IEEE80211_KEY_RECV;
+	if (set_tx)
+		wk.ik_flags |= IEEE80211_KEY_XMIT;
 	if (addr == NULL || is_broadcast_ether_addr(addr)) {
 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
 		wk.ik_keyix = key_idx;
@@ -465,6 +467,20 @@ wpa_driver_madwifi_set_key(const char *i
 	wk.ik_keylen = key_len;
 	memcpy(wk.ik_keydata, key, key_len);
 
+#ifdef WORDS_BIGENDIAN
+#define WPA_KEY_RSC_LEN 8
+	{
+		size_t i;
+		u8 tmp[WPA_KEY_RSC_LEN];
+		os_memset(tmp, 0, sizeof(tmp));
+		for (i = 0; i < seq_len; i++)
+			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
+		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
+	}
+#else /* WORDS_BIGENDIAN */
+	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
+#endif /* WORDS_BIGENDIAN */
+
 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
 	if (ret < 0) {
 		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
diff -purN hostapd-20130302/src/drivers/driver_nl80211.c hostapd-20130302-linux/src/drivers/driver_nl80211.c
--- hostapd-20130302/src/drivers/driver_nl80211.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/driver_nl80211.c	2013-07-07 03:22:14.000000000 -0400
@@ -10,6 +10,7 @@
  * See README for more details.
  */
 
+
 #include "includes.h"
 #include <sys/ioctl.h>
 #include <sys/types.h>
@@ -127,7 +128,7 @@ static struct nl_handle * nl_create_hand
 	}
 
 	if (genl_connect(handle)) {
-		wpa_printf(MSG_ERROR, "nl80211: Failed to connect to generic "
+		wpa_printf(MSG_DEBUG, "nl80211: Failed to connect to generic "
 			   "netlink (%s)", dbg);
 		nl80211_handle_destroy(handle);
 		return NULL;
@@ -218,7 +219,9 @@ struct wpa_driver_nl80211_data {
 	int if_removed;
 	int if_disabled;
 	int ignore_if_down_event;
+#ifdef CONFIG_RFKILL
 	struct rfkill_data *rfkill;
+#endif
 	struct wpa_driver_capa capa;
 	int has_capability;
 
@@ -897,6 +900,10 @@ static void wpa_driver_nl80211_event_rtm
 		return;
 	}
 
+	if (ifi->ifi_family == AF_BRIDGE &&
+	    drv->nlmode != NL80211_IFTYPE_AP)
+		return;
+
 	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
 		   "(%s%s%s%s)",
 		   drv->operstate, ifi->ifi_flags,
@@ -1004,6 +1011,10 @@ static void wpa_driver_nl80211_event_rtm
 	attrlen = len;
 	attr = (struct rtattr *) buf;
 
+	if (ifi->ifi_family == AF_BRIDGE &&
+	    drv->nlmode != NL80211_IFTYPE_AP)
+		return;
+
 	rta_len = RTA_ALIGN(sizeof(struct rtattr));
 	while (RTA_OK(attr, attrlen)) {
 		if (attr->rta_type == IFLA_IFNAME) {
@@ -2959,7 +2970,7 @@ static int wpa_driver_nl80211_init_nl(st
 	return 0;
 }
 
-
+#ifdef CONFIG_RFKILL
 static void wpa_driver_nl80211_rfkill_blocked(void *ctx)
 {
 	wpa_printf(MSG_DEBUG, "nl80211: RFKILL blocked");
@@ -2982,6 +2993,7 @@ static void wpa_driver_nl80211_rfkill_un
 	}
 	/* rtnetlink ifup handler will report interface as enabled */
 }
+#endif /* CONFIG_RFKILL */
 
 
 static void nl80211_get_phy_name(struct wpa_driver_nl80211_data *drv)
@@ -3110,7 +3122,9 @@ static void * wpa_driver_nl80211_init(vo
 				      void *global_priv)
 {
 	struct wpa_driver_nl80211_data *drv;
+#ifdef CONFIG_RFKILL
 	struct rfkill_config *rcfg;
+#endif
 	struct i802_bss *bss;
 
 	if (global_priv == NULL)
@@ -3129,6 +3143,12 @@ static void * wpa_driver_nl80211_init(vo
 	drv->monitor_sock = -1;
 	drv->eapol_tx_sock = -1;
 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
+	drv->nlmode = NL80211_IFTYPE_STATION;
+
+#ifdef HOSTAPD
+	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
+	drv->if_indices = drv->default_if_indices;
+#endif
 
 	if (wpa_driver_nl80211_init_nl(drv)) {
 		os_free(drv);
@@ -3140,6 +3160,7 @@ static void * wpa_driver_nl80211_init(vo
 
 	nl80211_get_phy_name(drv);
 
+#ifdef CONFIG_RFKILL
 	rcfg = os_zalloc(sizeof(*rcfg));
 	if (rcfg == NULL)
 		goto failed;
@@ -3152,6 +3173,7 @@ static void * wpa_driver_nl80211_init(vo
 		wpa_printf(MSG_DEBUG, "nl80211: RFKILL status not available");
 		os_free(rcfg);
 	}
+#endif /* CONFIG_RFKILL */
 
 	if (wpa_driver_nl80211_finish_drv_init(drv))
 		goto failed;
@@ -3441,22 +3463,19 @@ static void nl80211_mgmt_unsubscribe(str
 }
 
 
+#ifdef CONFIG_RFKILL
 static void wpa_driver_nl80211_send_rfkill(void *eloop_ctx, void *timeout_ctx)
 {
 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
 }
-
+#endif /* CONFIG_RFKILL */
 
 static int
-wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
+wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
+				       int *send_rfkill_event)
 {
 	struct i802_bss *bss = &drv->first_bss;
-	int send_rfkill_event = 0;
-
-	drv->ifindex = if_nametoindex(bss->ifname);
-	drv->first_bss.ifindex = drv->ifindex;
 
-#ifndef HOSTAPD
 	/*
 	 * Make sure the interface starts up in station mode unless this is a
 	 * dynamically added interface (e.g., P2P) that was already configured
@@ -3470,13 +3489,16 @@ wpa_driver_nl80211_finish_drv_init(struc
 	}
 
 	if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
+#ifdef CONFIG_RFKILL
 		if (rfkill_is_blocked(drv->rfkill)) {
 			wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
 				   "interface '%s' due to rfkill",
 				   bss->ifname);
 			drv->if_disabled = 1;
-			send_rfkill_event = 1;
-		} else {
+			*send_rfkill_event = 1;
+		} else
+#endif
+		{
 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
 				   "interface '%s' UP", bss->ifname);
 			return -1;
@@ -3485,7 +3507,19 @@ wpa_driver_nl80211_finish_drv_init(struc
 
 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
 			       1, IF_OPER_DORMANT);
-#endif /* HOSTAPD */
+}
+
+static int
+wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
+{
+	struct i802_bss *bss = &drv->first_bss;
+	int send_rfkill_event = 0;
+
+	drv->ifindex = if_nametoindex(bss->ifname);
+	drv->first_bss.ifindex = drv->ifindex;
+
+	if (drv->nlmode == NL80211_IFTYPE_STATION)
+		wpa_driver_nl80211_finish_drv_init_sta(drv, &send_rfkill_event);
 
 	if (wpa_driver_nl80211_capa(drv))
 		return -1;
@@ -3495,24 +3529,28 @@ wpa_driver_nl80211_finish_drv_init(struc
 		return -1;
 
 	if (send_rfkill_event) {
+#ifdef CONFIG_RFKILL
 		eloop_register_timeout(0, 0, wpa_driver_nl80211_send_rfkill,
 				       drv, drv->ctx);
+#endif
 	}
 
 	return 0;
 }
 
 
-static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
+static int wpa_driver_nl80211_del_bss_beacon(struct i802_bss *bss)
 {
+	struct wpa_driver_nl80211_data *drv = bss->drv;
 	struct nl_msg *msg;
 
+	bss->beacon_set = 0;
 	msg = nlmsg_alloc();
 	if (!msg)
 		return -ENOMEM;
 
 	nl80211_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
-	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
 
 	return send_and_recv_msgs(drv, msg, NULL, NULL);
  nla_put_failure:
@@ -3520,6 +3558,21 @@ static int wpa_driver_nl80211_del_beacon
 	return -ENOBUFS;
 }
 
+static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
+{
+	struct i802_bss *bss;
+
+	for (bss = &drv->first_bss; bss; bss = bss->next)
+		wpa_driver_nl80211_del_bss_beacon(bss);
+
+	return 0;
+}
+
+static int wpa_driver_nl80211_stop_ap(void *priv)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_nl80211_del_beacon(bss->drv);
+}
 
 /**
  * wpa_driver_nl80211_deinit - Deinitialize nl80211 driver interface
@@ -3582,7 +3635,9 @@ static void wpa_driver_nl80211_deinit(st
 
 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, 0,
 			       IF_OPER_UP);
+#ifdef CONFIG_RFKILL
 	rfkill_deinit(drv->rfkill);
+#endif
 
 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
 
@@ -6752,7 +6807,7 @@ static int wpa_driver_nl80211_ibss(struc
 				   struct wpa_driver_associate_params *params)
 {
 	struct nl_msg *msg;
-	int ret = -1;
+	int ret = -1, i;
 	int count = 0;
 
 	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
@@ -6785,6 +6840,53 @@ retry:
 	wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
 
+	if (params->fixed_freq) {
+		wpa_printf(MSG_DEBUG, "  * fixed_freq");
+		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
+	}
+
+	if (params->beacon_interval > 0) {
+		wpa_printf(MSG_DEBUG, "  * beacon_interval=%d",
+			   params->beacon_interval);
+		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL,
+			    params->beacon_interval);
+	}
+
+	if (params->rates[0] > 0) {
+		wpa_printf(MSG_DEBUG, "  * basic_rates:");
+		i = 0;
+		while (i < NL80211_MAX_SUPP_RATES &&
+		       params->rates[i] > 0) {
+			wpa_printf(MSG_DEBUG, "    %.1f",
+				   (double)params->rates[i] / 2);
+			i++;
+		}
+		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
+			params->rates);
+	}
+
+	if (params->mcast_rate > 0) {
+		wpa_printf(MSG_DEBUG, "  * mcast_rates=%.1f",
+			   (double)params->mcast_rate / 10);
+		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
+	}
+
+	if (params->ht_set) {
+		switch(params->htmode) {
+			case NL80211_CHAN_HT20:
+				wpa_printf(MSG_DEBUG, "  * ht=HT20");
+				break;
+			case NL80211_CHAN_HT40PLUS:
+				wpa_printf(MSG_DEBUG, "  * ht=HT40+");
+				break;
+			case NL80211_CHAN_HT40MINUS:
+				wpa_printf(MSG_DEBUG, "  * ht=HT40-");
+				break;
+		}
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+			    params->htmode);
+	}
+
 	ret = nl80211_set_conn_keys(params, msg);
 	if (ret)
 		goto nla_put_failure;
@@ -7292,8 +7394,6 @@ static int wpa_driver_nl80211_set_mode(s
 			ret = nl80211_set_mode(drv, drv->ifindex, nlmode);
 			if (ret == -EACCES)
 				break;
-			res = linux_set_iface_flags(drv->global->ioctl_sock,
-						    bss->ifname, 1);
 			if (res && !ret)
 				ret = -1;
 			else if (ret != -EBUSY)
@@ -7309,6 +7409,7 @@ static int wpa_driver_nl80211_set_mode(s
 			   "interface is down");
 		drv->nlmode = nlmode;
 		drv->ignore_if_down_event = 1;
+		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
 	}
 
 done:
@@ -8013,8 +8114,6 @@ static void *i802_init(struct hostapd_da
 		br_ifindex = 0;
 	}
 
-	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
-	drv->if_indices = drv->default_if_indices;
 	for (i = 0; i < params->num_bridge; i++) {
 		if (params->bridge[i]) {
 			ifindex = if_nametoindex(params->bridge[i]);
@@ -9512,4 +9611,5 @@ const struct wpa_driver_ops wpa_driver_n
 	.send_tdls_mgmt = nl80211_send_tdls_mgmt,
 	.tdls_oper = nl80211_tdls_oper,
 #endif /* CONFIG_TDLS */
+	.stop_ap = wpa_driver_nl80211_stop_ap,
 };
diff -purN hostapd-20130302/src/drivers/drivers.c hostapd-20130302-linux/src/drivers/drivers.c
--- hostapd-20130302/src/drivers/drivers.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/drivers.c	2013-07-06 06:05:42.000000000 -0400
@@ -7,7 +7,11 @@
  */
 
 #include "includes.h"
+#include "common.h"
+#include "driver.h"
 
+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
 
 #ifdef CONFIG_DRIVER_WEXT
 extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
@@ -15,6 +19,9 @@ extern struct wpa_driver_ops wpa_driver_
 #ifdef CONFIG_DRIVER_NL80211
 extern struct wpa_driver_ops wpa_driver_nl80211_ops; /* driver_nl80211.c */
 #endif /* CONFIG_DRIVER_NL80211 */
+#ifdef CONFIG_DRIVER_CAPWAP
+extern struct wpa_driver_ops wpa_driver_capwap_ops; /* benunets capwap driver */
+#endif
 #ifdef CONFIG_DRIVER_HOSTAP
 extern struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */
 #endif /* CONFIG_DRIVER_HOSTAP */
@@ -56,6 +63,9 @@ struct wpa_driver_ops *wpa_drivers[] =
 #ifdef CONFIG_DRIVER_NL80211
 	&wpa_driver_nl80211_ops,
 #endif /* CONFIG_DRIVER_NL80211 */
+#ifdef CONFIG_DRIVER_CAPWAP
+	&wpa_driver_capwap_ops, /* benunets capwap driver */
+#endif
 #ifdef CONFIG_DRIVER_HOSTAP
 	&wpa_driver_hostap_ops,
 #endif /* CONFIG_DRIVER_HOSTAP */
diff -purN hostapd-20130302/src/drivers/drivers.c.orig hostapd-20130302-linux/src/drivers/drivers.c.orig
--- hostapd-20130302/src/drivers/drivers.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/drivers.c.orig	2013-07-04 11:17:51.000000000 -0400
@@ -0,0 +1,100 @@
+/*
+ * Driver interface list
+ * Copyright (c) 2004-2005, Jouni Malinen <j@w1.fi>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include "includes.h"
+#include "common.h"
+#include "driver.h"
+
+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
+
+#ifdef CONFIG_DRIVER_WEXT
+extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
+#endif /* CONFIG_DRIVER_WEXT */
+#ifdef CONFIG_DRIVER_NL80211
+extern struct wpa_driver_ops wpa_driver_nl80211_ops; /* driver_nl80211.c */
+#endif /* CONFIG_DRIVER_NL80211 */
+#ifdef CONFIG_DRIVER_CAPWAP_WTP
+extern struct wpa_driver_ops wpa_driver_capwap_wtp_ops; /* benunets capwap driver */
+#endif
+#ifdef CONFIG_DRIVER_HOSTAP
+extern struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */
+#endif /* CONFIG_DRIVER_HOSTAP */
+#ifdef CONFIG_DRIVER_MADWIFI
+extern struct wpa_driver_ops wpa_driver_madwifi_ops; /* driver_madwifi.c */
+#endif /* CONFIG_DRIVER_MADWIFI */
+#ifdef CONFIG_DRIVER_BSD
+extern struct wpa_driver_ops wpa_driver_bsd_ops; /* driver_bsd.c */
+#endif /* CONFIG_DRIVER_BSD */
+#ifdef CONFIG_DRIVER_OPENBSD
+extern struct wpa_driver_ops wpa_driver_openbsd_ops; /* driver_openbsd.c */
+#endif /* CONFIG_DRIVER_OPENBSD */
+#ifdef CONFIG_DRIVER_NDIS
+extern struct wpa_driver_ops wpa_driver_ndis_ops; /* driver_ndis.c */
+#endif /* CONFIG_DRIVER_NDIS */
+#ifdef CONFIG_DRIVER_WIRED
+extern struct wpa_driver_ops wpa_driver_wired_ops; /* driver_wired.c */
+#endif /* CONFIG_DRIVER_WIRED */
+#ifdef CONFIG_DRIVER_TEST
+extern struct wpa_driver_ops wpa_driver_test_ops; /* driver_test.c */
+#endif /* CONFIG_DRIVER_TEST */
+#ifdef CONFIG_DRIVER_ROBOSWITCH
+/* driver_roboswitch.c */
+extern struct wpa_driver_ops wpa_driver_roboswitch_ops;
+#endif /* CONFIG_DRIVER_ROBOSWITCH */
+#ifdef CONFIG_DRIVER_ATHEROS
+extern struct wpa_driver_ops wpa_driver_atheros_ops; /* driver_atheros.c */
+#endif /* CONFIG_DRIVER_ATHEROS */
+#ifdef CONFIG_DRIVER_NONE
+extern struct wpa_driver_ops wpa_driver_none_ops; /* driver_none.c */
+#endif /* CONFIG_DRIVER_NONE */
+
+
+struct wpa_driver_ops *wpa_drivers[] =
+{
+#ifdef CONFIG_DRIVER_WEXT
+	&wpa_driver_wext_ops,
+#endif /* CONFIG_DRIVER_WEXT */
+#ifdef CONFIG_DRIVER_NL80211
+	&wpa_driver_nl80211_ops,
+#endif /* CONFIG_DRIVER_NL80211 */
+#ifdef CONFIG_DRIVER_CAPWAP_WTP
+	&wpa_driver_capwap_wtp_ops, /* benunets capwap driver */
+#endif
+#ifdef CONFIG_DRIVER_HOSTAP
+	&wpa_driver_hostap_ops,
+#endif /* CONFIG_DRIVER_HOSTAP */
+#ifdef CONFIG_DRIVER_MADWIFI
+	&wpa_driver_madwifi_ops,
+#endif /* CONFIG_DRIVER_MADWIFI */
+#ifdef CONFIG_DRIVER_BSD
+	&wpa_driver_bsd_ops,
+#endif /* CONFIG_DRIVER_BSD */
+#ifdef CONFIG_DRIVER_OPENBSD
+	&wpa_driver_openbsd_ops,
+#endif /* CONFIG_DRIVER_OPENBSD */
+#ifdef CONFIG_DRIVER_NDIS
+	&wpa_driver_ndis_ops,
+#endif /* CONFIG_DRIVER_NDIS */
+#ifdef CONFIG_DRIVER_WIRED
+	&wpa_driver_wired_ops,
+#endif /* CONFIG_DRIVER_WIRED */
+#ifdef CONFIG_DRIVER_TEST
+	&wpa_driver_test_ops,
+#endif /* CONFIG_DRIVER_TEST */
+#ifdef CONFIG_DRIVER_ROBOSWITCH
+	&wpa_driver_roboswitch_ops,
+#endif /* CONFIG_DRIVER_ROBOSWITCH */
+#ifdef CONFIG_DRIVER_ATHEROS
+	&wpa_driver_atheros_ops,
+#endif /* CONFIG_DRIVER_ATHEROS */
+#ifdef CONFIG_DRIVER_NONE
+	&wpa_driver_none_ops,
+#endif /* CONFIG_DRIVER_NONE */
+	NULL
+};
diff -purN hostapd-20130302/src/drivers/drivers.c.rej hostapd-20130302-linux/src/drivers/drivers.c.rej
--- hostapd-20130302/src/drivers/drivers.c.rej	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/drivers.c.rej	2013-07-06 06:04:50.000000000 -0400
@@ -0,0 +1,22 @@
+--- src/drivers/drivers.c	2013-07-06 04:57:00.000000000 -0400
++++ src/drivers/drivers.c	2013-06-29 09:00:55.000000000 -0400
+@@ -15,6 +15,9 @@
+ #ifdef CONFIG_DRIVER_NL80211
+ extern struct wpa_driver_ops wpa_driver_nl80211_ops; /* driver_nl80211.c */
+ #endif /* CONFIG_DRIVER_NL80211 */
++#ifdef CONFIG_DRIVER_CAPWAP
++extern struct wpa_driver_ops wpa_driver_capwap_ops; /* driver_capwap.c */
++#endif /* CONFIG_DRIVER_CAPWAP */
+ #ifdef CONFIG_DRIVER_HOSTAP
+ extern struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */
+ #endif /* CONFIG_DRIVER_HOSTAP */
+@@ -53,6 +56,9 @@
+ #ifdef CONFIG_DRIVER_NL80211
+ 	&wpa_driver_nl80211_ops,
+ #endif /* CONFIG_DRIVER_NL80211 */
++#ifdef CONFIG_DRIVER_CAPWAP
++       &wpa_driver_capwap_ops,
++#endif /* CONFIG_DRIVER_CAPWAP */
+ #ifdef CONFIG_DRIVER_WEXT
+ 	&wpa_driver_wext_ops,
+ #endif /* CONFIG_DRIVER_WEXT */
diff -purN hostapd-20130302/src/drivers/drivers.mak hostapd-20130302-linux/src/drivers/drivers.mak
--- hostapd-20130302/src/drivers/drivers.mak	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/drivers.mak	2013-07-06 06:06:37.000000000 -0400
@@ -20,7 +20,7 @@ endif
 ifdef CONFIG_DRIVER_NL80211
 DRV_CFLAGS += -DCONFIG_DRIVER_NL80211
 DRV_OBJS += ../src/drivers/driver_nl80211.o
-DRV_OBJS += ../src/utils/radiotap.o
+NEED_RADIOTAP=y
 NEED_SME=y
 NEED_AP_MLME=y
 NEED_NETLINK=y
@@ -138,6 +138,47 @@ DRV_WPA_OBJS += ../src/drivers/driver_we
 NEED_RFKILL=y
 endif
 
+ifdef CONFIG_DRIVER_CAPWAP
+DRV_CFLAGS += -DCONFIG_DRIVER_CAPWAP
+DRV_OBJS += ../src/drivers/driver_capwap.o
+NEED_RADIOTAP=y
+NEED_SME=y
+NEED_AP_MLME=y
+NEED_FAKE_NETLINK=y
+NEED_LINUX_FAKE_IOCTL=y
+NEED_CAPWAP_MGMT_FRAME_AC=y
+NEED_CAPWAP_IPC_AC=y
+NEED_RFKILL=y
+
+ifdef CONFIG_LIBNL32
+  DRV_LIBS += -lnl-3
+  DRV_LIBS += -lnl-genl-3
+  DRV_CFLAGS += -DCONFIG_LIBNL20 -I/usr/include/libnl3
+else
+  ifdef CONFIG_LIBNL_TINY
+    DRV_LIBS += -lnl-tiny
+  else
+    DRV_LIBS += -lnl
+  endif
+
+   ifdef CONFIG_LIBNL20
+    DRV_LIBS += -lnl-genl
+    DRV_CFLAGS += -DCONFIG_LIBNL20
+  endif
+endif
+ifdef NEED_FAKE_NETLINK
+DRV_OBJS += ../src/drivers/netlink_fake.o
+endif
+
+ifdef NEED_LINUX_FAKE_IOCTL
+DRV_OBJS += ../src/drivers/linux_ioctl_fake.o
+endif
+endif
+
+ifdef NEED_RADIOTAP
+DRV_OBJS += ../src/utils/radiotap.o
+endif
+
 ifdef NEED_NETLINK
 DRV_OBJS += ../src/drivers/netlink.o
 endif
@@ -150,6 +191,26 @@ ifdef NEED_RFKILL
 DRV_OBJS += ../src/drivers/rfkill.o
 endif
 
+ifdef NEED_CAPWAP_MGMT_FRAME_WTP
+DRV_OBJS += ../src/capwap/capwap_mgmt_frame_wtp.o
+endif
+
+ifdef NEED_CAPWAP_MGMT_FRAME_AC
+DRV_OBJS += ../src/capwap/capwap_mgmt_frame_ac.o
+endif
+
+ifdef NEED_CAPWAP_IPC_WTP
+DRV_OBJS += ../src/capwap/ipc_capwap_wtp.o
+endif
+
+ifdef NEED_CAPWAP_IPC_AC
+DRV_OBJS += ../src/capwap/ipc_capwap_ac.o
+endif
+
+ifdef NEED_SWITCH_8023
+DRV_OBJS += ../src/capwap/switch_8023_80211.o
+endif
+
 ifdef CONFIG_VLAN_NETLINK
 ifdef CONFIG_FULL_DYNAMIC_VLAN
 ifdef CONFIG_LIBNL32
diff -purN hostapd-20130302/src/drivers/drivers.mk hostapd-20130302-linux/src/drivers/drivers.mk
--- hostapd-20130302/src/drivers/drivers.mk	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/drivers.mk	2013-07-06 06:06:37.000000000 -0400
@@ -18,9 +18,9 @@ DRV_OBJS += src/drivers/driver_wired.c
 endif
 
 ifdef CONFIG_DRIVER_NL80211
-DRV_CFLAGS += -DCONFIG_DRIVER_NL80211
+DRV_CFLAGS += -I/usr/include -DCONFIG_DRIVER_NL80211 -D_GNU_SOURCE 
 DRV_OBJS += src/drivers/driver_nl80211.c
-DRV_OBJS += src/utils/radiotap.c
+NEED_RADIOTAP=y
 NEED_SME=y
 NEED_AP_MLME=y
 NEED_NETLINK=y
@@ -45,6 +45,74 @@ else
 endif
 endif
 
+ifdef CONFIG_DRIVER_CAPWAP
+DRV_CFLAGS += -DCONFIG_DRIVER_CAPWAP
+DRV_OBJS += src/drivers/driver_capwap.c
+NEED_RADIOTAP=y
+NEED_SME=y
+NEED_AP_MLME=y
+NEED_FAKE_NETLINK=y
+NEED_LINUX_FAKE_IOCTL=y
+NEED_CAPWAP_MGMT_FRAME_AC=y
+NEED_CAPWAP_IPC_AC=y
+NEED_RFKILL=y
+ifdef CONFIG_LIBNL32
+  DRV_LIBS += -lnl-3
+  DRV_LIBS += -lnl-genl-3
+  DRV_CFLAGS += -DCONFIG_LIBNL20 -I/usr/include/libnl3
+else
+  ifdef CONFIG_LIBNL_TINY
+    DRV_LIBS += -lnl-tiny
+  else
+    DRV_LIBS += -lnl
+  endif
+
+  ifdef CONFIG_LIBNL20
+    DRV_LIBS += -lnl-genl
+    DRV_CFLAGS += -DCONFIG_LIBNL20
+  endif
+endif
+ifdef NEED_RADIOTAP
+DRV_OBJS += src/utils/radiotap.c
+endif
+
+ifdef NEED_NETLINK
+DRV_OBJS += src/drivers/netlink.c
+endif
+
+ifdef NEED_FAKE_NETLINK
+DRV_OBJS += src/drivers/netlink_fake.c
+endif
+
+ifdef NEED_LINUX_IOCTL
+DRV_OBJS += src/drivers/linux_ioctl.c
+endif
+
+ifdef NEED_LINUX_FAKE_IOCTL
+DRV_OBJS += src/drivers/linux_ioctl_fake.c
+endif
+
+ifdef NEED_RFKILL
+DRV_OBJS += src/drivers/rfkill.c
+endif
+
+ifdef NEED_CAPWAP_MGMT_FRAME_WTP
+DRV_OBJS += src/capwap/capwap_mgmt_frame_wtp.c
+endif
+
+ifdef NEED_CAPWAP_MGMT_FRAME_AC
+DRV_OBJS += src/capwap/capwap_mgmt_frame_ac.c
+endif
+
+ifdef NEED_CAPWAP_IPC_WTP
+DRV_OBJS += src/capwap/ipc_capwap_wtp.c
+endif
+
+ifdef NEED_CAPWAP_IPC_AC
+DRV_OBJS += src/capwap/ipc_capwap_ac.c
+endif
+endif
+
 ifdef CONFIG_DRIVER_BSD
 ifndef CONFIG_L2_PACKET
 CONFIG_L2_PACKET=freebsd
@@ -138,6 +206,10 @@ DRV_WPA_OBJS += src/drivers/driver_wext.
 NEED_RFKILL=y
 endif
 
+ifdef NEED_RADIOTAP
+DRV_OBJS += src/utils/radiotap.c
+endif
+
 ifdef NEED_NETLINK
 DRV_OBJS += src/drivers/netlink.c
 endif
@@ -150,6 +222,26 @@ ifdef NEED_RFKILL
 DRV_OBJS += src/drivers/rfkill.c
 endif
 
+ifdef NEED_CAPWAP_MGMT_FRAME_WTP
+DRV_OBJS += src/capwap/capwap_mgmt_frame_wtp.c
+endif
+
+ifdef NEED_CAPWAP_MGMT_FRAME_AC
+DRV_OBJS += src/capwap/capwap_mgmt_frame_ac.c
+endif
+
+ifdef NEED_CAPWAP_IPC_WTP
+DRV_OBJS += src/capwap/ipc_capwap_wtp.c
+endif
+
+ifdef NEED_CAPWAP_IPC_AC
+DRV_OBJS += src/capwap/ipc_capwap_ac.c
+endif
+
+ifdef NEED_SWITCH_8023
+DRV_OBJS += src/capwap/switch_8023_80211.c
+endif
+
 ifdef CONFIG_DRIVER_CUSTOM
 DRV_CFLAGS += -DCONFIG_DRIVER_CUSTOM
 endif
diff -purN hostapd-20130302/src/drivers/driver_wext.c hostapd-20130302-linux/src/drivers/driver_wext.c
--- hostapd-20130302/src/drivers/driver_wext.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/driver_wext.c	2013-07-04 11:17:51.000000000 -0400
@@ -742,7 +742,7 @@ static void wpa_driver_wext_event_rtm_de
 	}
 }
 
-
+#ifdef CONFIG_RFKILL
 static void wpa_driver_wext_rfkill_blocked(void *ctx)
 {
 	wpa_printf(MSG_DEBUG, "WEXT: RFKILL blocked");
@@ -764,7 +764,7 @@ static void wpa_driver_wext_rfkill_unblo
 	}
 	/* rtnetlink ifup handler will report interface as enabled */
 }
-
+#endif /* CONFIG_RFKILL */
 
 static void wext_get_phy_name(struct wpa_driver_wext_data *drv)
 {
@@ -810,7 +810,9 @@ void * wpa_driver_wext_init(void *ctx, c
 {
 	struct wpa_driver_wext_data *drv;
 	struct netlink_config *cfg;
+#ifdef CONFIG_RFKILL
 	struct rfkill_config *rcfg;
+#endif
 	char path[128];
 	struct stat buf;
 
@@ -845,6 +847,7 @@ void * wpa_driver_wext_init(void *ctx, c
 		goto err2;
 	}
 
+#ifdef CONFIG_RFKILL
 	rcfg = os_zalloc(sizeof(*rcfg));
 	if (rcfg == NULL)
 		goto err3;
@@ -857,6 +860,7 @@ void * wpa_driver_wext_init(void *ctx, c
 		wpa_printf(MSG_DEBUG, "WEXT: RFKILL status not available");
 		os_free(rcfg);
 	}
+#endif /* CONFIG_RFKILL */
 
 	drv->mlme_sock = -1;
 
@@ -874,7 +878,9 @@ void * wpa_driver_wext_init(void *ctx, c
 	return drv;
 
 err3:
+#ifdef CONFIG_RFKILL
 	rfkill_deinit(drv->rfkill);
+#endif
 	netlink_deinit(drv->netlink);
 err2:
 	close(drv->ioctl_sock);
@@ -884,10 +890,12 @@ err1:
 }
 
 
+#ifdef CONFIG_RFKILL
 static void wpa_driver_wext_send_rfkill(void *eloop_ctx, void *timeout_ctx)
 {
 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
 }
+#endif /* CONFIG_RFKILL */
 
 
 static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
@@ -895,13 +903,16 @@ static int wpa_driver_wext_finish_drv_in
 	int send_rfkill_event = 0;
 
 	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
+#ifdef CONFIG_RFKILL
 		if (rfkill_is_blocked(drv->rfkill)) {
 			wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
 				   "interface '%s' due to rfkill",
 				   drv->ifname);
 			drv->if_disabled = 1;
 			send_rfkill_event = 1;
-		} else {
+		} else
+#endif
+		{
 			wpa_printf(MSG_ERROR, "WEXT: Could not set "
 				   "interface '%s' UP", drv->ifname);
 			return -1;
@@ -949,8 +960,10 @@ static int wpa_driver_wext_finish_drv_in
 			       1, IF_OPER_DORMANT);
 
 	if (send_rfkill_event) {
+#ifdef CONFIG_RFKILL
 		eloop_register_timeout(0, 0, wpa_driver_wext_send_rfkill,
 				       drv, drv->ctx);
+#endif
 	}
 
 	return 0;
@@ -980,7 +993,9 @@ void wpa_driver_wext_deinit(void *priv)
 
 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
 	netlink_deinit(drv->netlink);
+#ifdef CONFIG_RFKILL
 	rfkill_deinit(drv->rfkill);
+#endif
 
 	if (drv->mlme_sock >= 0)
 		eloop_unregister_read_sock(drv->mlme_sock);
diff -purN hostapd-20130302/src/drivers/driver_wext.h hostapd-20130302-linux/src/drivers/driver_wext.h
--- hostapd-20130302/src/drivers/driver_wext.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/driver_wext.h	2013-07-04 11:17:51.000000000 -0400
@@ -22,7 +22,9 @@ struct wpa_driver_wext_data {
 	int ifindex2;
 	int if_removed;
 	int if_disabled;
+#ifdef CONFIG_RFKILL
 	struct rfkill_data *rfkill;
+#endif
 	u8 *assoc_req_ies;
 	size_t assoc_req_ies_len;
 	u8 *assoc_resp_ies;
diff -purN hostapd-20130302/src/drivers/linux_ioctl_fake.c hostapd-20130302-linux/src/drivers/linux_ioctl_fake.c
--- hostapd-20130302/src/drivers/linux_ioctl_fake.c	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/linux_ioctl_fake.c	2013-07-06 06:06:29.000000000 -0400
@@ -0,0 +1,137 @@
+/*
+ * Linux ioctl helper functions for driver wrappers
+ * Copyright (c) 2002-2010, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+
+#include "utils/includes.h"
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+
+#include "utils/common.h"
+#include "linux_ioctl_fake.h"
+
+
+
+int linux_set_fake_iface_flags(int sock, const char *ifname, int dev_up){
+	
+	return 0;
+}
+
+int linux_iface_fake_up(int sock, const char *ifname){
+
+	return 0;
+}
+
+int linux_get_fake_ifhwaddr(int sock, const char *ifname, u8 *addr){
+
+	int i=2;
+	
+	if(i==0){ // TP-LINK (Atheros)
+		addr[0]=0xB0;
+		addr[1]=0x48;
+		addr[2]=0x7A;
+		addr[3]=0x93;
+		addr[4]=0x90;
+		addr[5]=0xF8;
+		
+	}else if(i==1){// D-Link 
+		addr[0]=0x28;
+		addr[1]=0x10;
+		addr[2]=0x7B;
+		addr[3]=0x44;
+		addr[4]=0xd0;
+		addr[5]=0xB1;
+		
+	}else if(i==2){// TP-LINK (Atheros)
+		addr[0]=0xAA;
+		addr[1]=0xBB;
+		addr[2]=0xCC;
+		addr[3]=0xDD;
+		addr[4]=0xEE;
+		addr[5]=0xFF;
+		
+	}
+
+	return 0;
+}
+
+int linux_set_fake_ifhwaddr(int sock, const char *ifname,  u8 *addr){
+
+        int i=2;
+
+        if(i==0){ // TP-LINK (Atheros)
+                addr[0]=0xB0;
+                addr[1]=0x48;
+                addr[2]=0x7A;
+                addr[3]=0x93;
+                addr[4]=0x90;
+                addr[5]=0xF8;
+
+        }else if(i==1){// D-Link
+                addr[0]=0x28;
+                addr[1]=0x10;
+                addr[2]=0x7B;
+                addr[3]=0x44;
+                addr[4]=0xd0;
+                addr[5]=0xB1;
+
+        }else if(i==2){// TP-LINK (Atheros)
+                addr[0]=0xAA;
+                addr[1]=0xBB;
+                addr[2]=0xCC;
+                addr[3]=0xDD;
+                addr[4]=0xEE;
+                addr[5]=0xFF;
+
+        }
+
+	return 0;
+}
+
+
+#ifndef SIOCBRADDBR
+#define SIOCBRADDBR 0x89a0
+#endif
+#ifndef SIOCBRDELBR
+#define SIOCBRDELBR 0x89a1
+#endif
+#ifndef SIOCBRADDIF
+#define SIOCBRADDIF 0x89a2
+#endif
+#ifndef SIOCBRDELIF
+#define SIOCBRDELIF 0x89a3
+#endif
+
+
+int linux_br_fake_add(int sock, const char *brname){
+	return 0;
+}
+
+int linux_br_fake_del(int sock, const char *brname){
+	return 0;
+}
+
+int linux_br_fake_add_if(int sock, const char *brname, const char *ifname){
+	return 0;
+}
+
+int linux_br_fake_del_if(int sock, const char *brname, const char *ifname){
+	return 0;
+}
+
+int linux_br_fake_get(char *brname, const char *ifname){
+	return 0;
+}
+
+
diff -purN hostapd-20130302/src/drivers/linux_ioctl_fake.h hostapd-20130302-linux/src/drivers/linux_ioctl_fake.h
--- hostapd-20130302/src/drivers/linux_ioctl_fake.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/linux_ioctl_fake.h	2013-07-06 06:06:29.000000000 -0400
@@ -0,0 +1,28 @@
+/*
+ * Linux ioctl helper functions for driver wrappers
+ * Copyright (c) 2002-2010, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef LINUX_IOCTL_H
+#define LINUX_IOCTL_H
+
+int linux_set_iface_flags(int sock, const char *ifname, int dev_up);
+int linux_iface_up(int sock, const char *ifname);
+int linux_get_ifhwaddr(int sock, const char *ifname, u8 *addr);
+int linux_set_ifhwaddr(int sock, const char *ifname, const u8 *addr);
+int linux_br_add(int sock, const char *brname);
+int linux_br_del(int sock, const char *brname);
+int linux_br_add_if(int sock, const char *brname, const char *ifname);
+int linux_br_del_if(int sock, const char *brname, const char *ifname);
+int linux_br_get(char *brname, const char *ifname);
+
+#endif /* LINUX_IOCTL_H */
diff -purN hostapd-20130302/src/drivers/netlink_fake.c hostapd-20130302-linux/src/drivers/netlink_fake.c
--- hostapd-20130302/src/drivers/netlink_fake.c	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/netlink_fake.c	2013-07-06 06:06:29.000000000 -0400
@@ -0,0 +1,82 @@
+/*
+ * Netlink helper functions for driver wrappers
+ * Copyright (c) 2002-2009, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+
+#include "includes.h"
+
+#include "common.h"
+#include "eloop.h"
+#include "priv_netlink.h"
+#include "netlink_fake.h"
+
+
+
+struct netlink_data {
+	struct netlink_config *cfg;
+	int sock;
+};
+
+
+static void netlink_receive_link(struct netlink_data *netlink,
+				 void (*cb)(void *ctx, struct ifinfomsg *ifi,
+					    u8 *buf, size_t len),
+				 struct nlmsghdr *h)
+{
+	
+	return;
+}
+
+
+static void netlink_receive(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	return;
+}
+
+
+struct netlink_data * netlink_fake_init(struct netlink_config *cfg)
+{
+
+	struct netlink_data *netlink;
+	struct sockaddr_nl local;
+
+	netlink = os_zalloc(sizeof(*netlink));
+	if (netlink == NULL)
+		return NULL;
+
+	netlink->cfg = cfg;
+
+	netlink->sock = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+
+	os_memset(&local, 0, sizeof(local));
+	local.nl_family = AF_NETLINK;
+	local.nl_groups = RTMGRP_LINK;
+
+	eloop_register_read_sock(netlink->sock, netlink_receive, netlink,
+				 NULL);
+
+	return netlink;
+
+}
+
+
+void netlink_fake_deinit(struct netlink_data *netlink)
+{
+	return;
+}
+
+int netlink_fake_send_oper_ifla(struct netlink_data *netlink, int ifindex,
+			   int linkmode, int operstate){
+	
+	return 0;
+}
diff -purN hostapd-20130302/src/drivers/netlink_fake.h hostapd-20130302-linux/src/drivers/netlink_fake.h
--- hostapd-20130302/src/drivers/netlink_fake.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/drivers/netlink_fake.h	2013-07-07 03:48:41.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ * Netlink helper functions for driver wrappers
+ * Copyright (c) 2002-2009, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef NETLINK_FAKE_H
+#define NETLINK_FAKE_H
+
+struct netlink_data;
+struct ifinfomsg;
+
+struct netlink_config {
+	void *ctx;
+	void (*newlink_cb)(void *ctx, struct ifinfomsg *ifi, u8 *buf,
+			   size_t len);
+	void (*dellink_cb)(void *ctx, struct ifinfomsg *ifi, u8 *buf,
+			   size_t len);
+};
+
+struct netlink_data * netlink_fake_init(struct netlink_config *cfg);
+void netlink_fake_deinit(struct netlink_data *netlink);
+int netlink_fake_send_oper_ifla(struct netlink_data *netlink, int ifindex,
+			   int linkmode, int operstate);
+
+#endif /* NETLINK_H */
diff -purN hostapd-20130302/src/Makefile hostapd-20130302-linux/src/Makefile
--- hostapd-20130302/src/Makefile	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/Makefile	2013-07-06 06:04:50.000000000 -0400
@@ -1,4 +1,4 @@
-SUBDIRS=ap common crypto drivers eapol_auth eapol_supp eap_common eap_peer eap_server l2_packet p2p radius rsn_supp tls utils wps
+SUBDIRS=capwap ap common crypto drivers eapol_auth eapol_supp eap_common eap_peer eap_server l2_packet p2p radius rsn_supp tls utils wps
 
 all:
 	for d in $(SUBDIRS); do [ -d $$d ] && $(MAKE) -C $$d; done
diff -purN hostapd-20130302/src/rsn_supp/wpa.c hostapd-20130302-linux/src/rsn_supp/wpa.c
--- hostapd-20130302/src/rsn_supp/wpa.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/rsn_supp/wpa.c	2013-07-04 11:17:51.000000000 -0400
@@ -1848,6 +1848,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
 }
 
 
+#ifdef CONFIG_CTRL_IFACE_MIB
+
 #define RSN_SUITE "%02x-%02x-%02x-%d"
 #define RSN_SUITE_ARG(s) \
 ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
@@ -1931,6 +1933,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
 
 	return (int) len;
 }
+#endif
 #endif /* CONFIG_CTRL_IFACE */
 
 
diff -purN hostapd-20130302/src/tls/x509v3.c hostapd-20130302-linux/src/tls/x509v3.c
--- hostapd-20130302/src/tls/x509v3.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/tls/x509v3.c	2013-07-04 11:17:51.000000000 -0400
@@ -1848,6 +1848,9 @@ int x509_certificate_chain_validate(stru
 		if (chain_trusted)
 			continue;
 
+#ifdef NO_TIMESTAMP_CHECK
+		disable_time_checks = 1;
+#endif
 		if (!disable_time_checks &&
 		    ((unsigned long) now.sec <
 		     (unsigned long) cert->not_before ||
diff -purN hostapd-20130302/src/utils/build_features.h hostapd-20130302-linux/src/utils/build_features.h
--- hostapd-20130302/src/utils/build_features.h	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/src/utils/build_features.h	2013-07-04 11:17:51.000000000 -0400
@@ -0,0 +1,17 @@
+#ifndef BUILD_FEATURES_H
+#define BUILD_FEATURES_H
+
+static inline int has_feature(const char *feat)
+{
+#ifdef IEEE8021X_EAPOL
+	if (!strcmp(feat, "eap"))
+		return 1;
+#endif
+#ifdef IEEE80211N
+	if (!strcmp(feat, "11n"))
+		return 1;
+#endif
+	return 0;
+}
+
+#endif /* BUILD_FEATURES_H */
diff -purN hostapd-20130302/src/utils/eloop.h hostapd-20130302-linux/src/utils/eloop.h
--- hostapd-20130302/src/utils/eloop.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/utils/eloop.h	2013-07-04 11:17:51.000000000 -0400
@@ -17,6 +17,7 @@
 #ifndef ELOOP_H
 #define ELOOP_H
 
+#include "os.h"
 /**
  * ELOOP_ALL_CTX - eloop_cancel_timeout() magic number to match all timeouts
  */
diff -purN hostapd-20130302/src/utils/wpa_debug.c hostapd-20130302-linux/src/utils/wpa_debug.c
--- hostapd-20130302/src/utils/wpa_debug.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/utils/wpa_debug.c	2013-07-04 11:17:51.000000000 -0400
@@ -201,7 +201,7 @@ void wpa_debug_close_linux_tracing(void)
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_printf(int level, const char *fmt, ...)
+void _wpa_printf(int level, const char *fmt, ...)
 {
 	va_list ap;
 
@@ -248,8 +248,8 @@ void wpa_printf(int level, const char *f
 }
 
 
-static void _wpa_hexdump(int level, const char *title, const u8 *buf,
-			 size_t len, int show)
+void _wpa_hexdump(int level, const char *title, const u8 *buf,
+		  size_t len, int show)
 {
 	size_t i;
 
@@ -375,20 +375,9 @@ static void _wpa_hexdump(int level, cons
 #endif /* CONFIG_ANDROID_LOG */
 }
 
-void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
-{
-	_wpa_hexdump(level, title, buf, len, 1);
-}
-
-
-void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
-{
-	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
-}
 
-
-static void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-			       size_t len, int show)
+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
+			size_t len, int show)
 {
 	size_t i, llen;
 	const u8 *pos = buf;
@@ -495,19 +484,6 @@ static void _wpa_hexdump_ascii(int level
 }
 
 
-void wpa_hexdump_ascii(int level, const char *title, const u8 *buf, size_t len)
-{
-	_wpa_hexdump_ascii(level, title, buf, len, 1);
-}
-
-
-void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
-			   size_t len)
-{
-	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
-}
-
-
 #ifdef CONFIG_DEBUG_FILE
 static char *last_path = NULL;
 #endif /* CONFIG_DEBUG_FILE */
@@ -591,7 +567,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_
 }
 
 
-void wpa_msg(void *ctx, int level, const char *fmt, ...)
+void _wpa_msg(void *ctx, int level, const char *fmt, ...)
 {
 	va_list ap;
 	char *buf;
@@ -625,7 +601,7 @@ void wpa_msg(void *ctx, int level, const
 }
 
 
-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
 {
 	va_list ap;
 	char *buf;
diff -purN hostapd-20130302/src/utils/wpa_debug.h hostapd-20130302-linux/src/utils/wpa_debug.h
--- hostapd-20130302/src/utils/wpa_debug.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/src/utils/wpa_debug.h	2013-07-04 11:17:51.000000000 -0400
@@ -15,7 +15,7 @@
  * use these for debugging purposes. */
 
 enum {
-	MSG_EXCESSIVE, MSG_MSGDUMP, MSG_DEBUG, MSG_INFO, MSG_WARNING, MSG_ERROR
+	MSG_EXCESSIVE, MSG_MSGDUMP, MSG_ERROR, MSG_INFO, MSG_WARNING, MSG_DEBUG
 };
 
 #ifdef CONFIG_NO_STDOUT_DEBUG
@@ -43,6 +43,17 @@ int wpa_debug_open_file(const char *path
 int wpa_debug_reopen_file(void);
 void wpa_debug_close_file(void);
 
+/* internal */
+void _wpa_hexdump(int level, const char *title, const u8 *buf,
+		  size_t len, int show);
+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
+			size_t len, int show);
+extern int wpa_debug_show_keys;
+
+#ifndef CONFIG_MSG_MIN_PRIORITY
+#define CONFIG_MSG_MIN_PRIORITY 0
+#endif
+
 /**
  * wpa_debug_printf_timestamp - Print timestamp for debug output
  *
@@ -63,9 +74,15 @@ void wpa_debug_print_timestamp(void);
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_printf(int level, const char *fmt, ...)
+void _wpa_printf(int level, const char *fmt, ...)
 PRINTF_FORMAT(2, 3);
 
+#define wpa_printf(level, ...)						\
+	do {								\
+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
+			_wpa_printf(level, __VA_ARGS__);		\
+	} while(0)
+
 /**
  * wpa_hexdump - conditional hex dump
  * @level: priority level (MSG_*) of the message
@@ -77,7 +94,13 @@ PRINTF_FORMAT(2, 3);
  * output may be directed to stdout, stderr, and/or syslog based on
  * configuration. The contents of buf is printed out has hex dump.
  */
-void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len);
+static inline void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump(level, title, buf, len, 1);
+}
 
 static inline void wpa_hexdump_buf(int level, const char *title,
 				   const struct wpabuf *buf)
@@ -99,7 +122,13 @@ static inline void wpa_hexdump_buf(int l
  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
  * etc.) in debug output.
  */
-void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len);
+static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
+}
 
 static inline void wpa_hexdump_buf_key(int level, const char *title,
 				       const struct wpabuf *buf)
@@ -121,8 +150,14 @@ static inline void wpa_hexdump_buf_key(i
  * the hex numbers and ASCII characters (for printable range) are shown. 16
  * bytes per line will be shown.
  */
-void wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-		       size_t len);
+static inline void wpa_hexdump_ascii(int level, const char *title,
+				     const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump_ascii(level, title, buf, len, 1);
+}
 
 /**
  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
@@ -138,8 +173,14 @@ void wpa_hexdump_ascii(int level, const
  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
  * default, does not include secret keys (passwords, etc.) in debug output.
  */
-void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
-			   size_t len);
+static inline void wpa_hexdump_ascii_key(int level, const char *title,
+					 const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
+}
 
 /*
  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
@@ -172,7 +213,12 @@ void wpa_hexdump_ascii_key(int level, co
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
+void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
+#define wpa_msg(ctx, level, ...)					\
+	do {								\
+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
+			_wpa_msg(ctx, level, __VA_ARGS__);		\
+	} while(0)
 
 /**
  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
@@ -186,8 +232,13 @@ void wpa_msg(void *ctx, int level, const
  * attached ctrl_iface monitors. In other words, it can be used for frequent
  * events that do not need to be sent to syslog.
  */
-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
 PRINTF_FORMAT(3, 4);
+#define wpa_msg_ctrl(ctx, level, ...)					\
+	do {								\
+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
+			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
+	} while(0)
 
 typedef void (*wpa_msg_cb_func)(void *ctx, int level, const char *txt,
 				size_t len);
diff -purN hostapd-20130302/wpa_supplicant/bss.c hostapd-20130302-linux/wpa_supplicant/bss.c
--- hostapd-20130302/wpa_supplicant/bss.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/bss.c	2013-07-04 11:17:51.000000000 -0400
@@ -11,6 +11,7 @@
 #include "utils/common.h"
 #include "utils/eloop.h"
 #include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
 #include "drivers/driver.h"
 #include "wpa_supplicant_i.h"
 #include "config.h"
@@ -227,6 +228,8 @@ struct wpa_bss * wpa_bss_get(struct wpa_
 static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
 			     struct os_time *fetch_time)
 {
+	struct ieee80211_ht_capabilities *capab;
+	struct ieee802_11_elems elems;
 	os_time_t usec;
 
 	dst->flags = src->flags;
@@ -239,6 +242,12 @@ static void wpa_bss_copy_res(struct wpa_
 	dst->level = src->level;
 	dst->tsf = src->tsf;
 
+	memset(&elems, 0, sizeof(elems));
+	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
+	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
+	if (capab)
+		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
+
 	dst->last_update.sec = fetch_time->sec;
 	dst->last_update.usec = fetch_time->usec;
 	dst->last_update.sec -= src->age / 1000;
diff -purN hostapd-20130302/wpa_supplicant/bss.h hostapd-20130302-linux/wpa_supplicant/bss.h
--- hostapd-20130302/wpa_supplicant/bss.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/bss.h	2013-07-04 11:17:51.000000000 -0400
@@ -69,6 +69,8 @@ struct wpa_bss {
 	u8 ssid[32];
 	/** Length of SSID */
 	size_t ssid_len;
+	/** HT caapbilities */
+	u16 ht_capab;
 	/** Frequency of the channel in MHz (e.g., 2412 = channel 1) */
 	int freq;
 	/** Beacon interval in TUs (host byte order) */
diff -purN hostapd-20130302/wpa_supplicant/.config hostapd-20130302-linux/wpa_supplicant/.config
--- hostapd-20130302/wpa_supplicant/.config	1969-12-31 19:00:00.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/.config	2013-06-22 15:54:23.000000000 -0400
@@ -0,0 +1,408 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_MADWIFI=y
+# Set include directory to the madwifi source tree
+#CFLAGS += -I../../madwifi
+
+# Driver interface for ndiswrapper
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+# CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for old Broadcom driver
+# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
+# Linux wireless extensions and does not need (or even work) with the old
+# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for Ralink driver
+#CONFIG_DRIVER_RALINK=y
+
+# Driver interface for generic Linux wireless extensions
+CONFIG_DRIVER_WEXT=y
+
+# Driver interface for Linux drivers using the nl80211 kernel interface
+CONFIG_DRIVER_NL80211=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Include client MLME (management frame processing) for test driver
+# This can be used to test MLME operations in hostapd with the test interface.
+# space.
+#CONFIG_CLIENT_MLME=y
+
+# Driver interface for wired Ethernet drivers
+CONFIG_DRIVER_WIRED=y
+
+# Driver interface for the Broadcom RoboSwitch family
+#CONFIG_DRIVER_ROBOSWITCH=y
+
+# Driver interface for no driver (e.g., WPS ER only)
+#CONFIG_DRIVER_NONE=y
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+CONFIG_EAP_GTC=y
+
+# EAP-OTP
+CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+#CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+#CONFIG_EAP_AKA=y
+
+# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
+# This requires CONFIG_EAP_AKA to be enabled, too.
+#CONFIG_EAP_AKA_PRIME=y
+
+# Enable USIM simulator (Milenage) for EAP-AKA
+#CONFIG_USIM_SIMULATOR=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-TNC and related Trusted Network Connect support (experimental)
+#CONFIG_EAP_TNC=y
+
+# Wi-Fi Protected Setup (WPS)
+CONFIG_WPS=y
+
+# EAP-IKEv2
+#CONFIG_EAP_IKEV2=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM)
+# Enable this if EAP-SIM or EAP-AKA is included
+#CONFIG_PCSC=y
+
+# Development testing
+#CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=y
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+# save about 1 kB in code size when building only WPA-Personal (no EAP support)
+# or 6 kB if building for WPA-Enterprise.
+#CONFIG_NO_WPA2=y
+
+# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
+# This option can be used to reduce code size by removing support for
+# converting ASCII passphrases into PSK. If this functionality is removed, the
+# PSK can only be configured as the 64-octet hexstring (e.g., from
+# wpa_passphrase). This saves about 0.5 kB in code size.
+#CONFIG_NO_WPA_PASSPHRASE=y
+
+# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
+# This can be used if ap_scan=1 mode is never enabled.
+#CONFIG_NO_SCAN_PROCESSING=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+#CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+#CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+#CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+#CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+#CONFIG_ELOOP=eloop
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+#CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+CONFIG_TLS=internal
+
+# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
+# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
+# even though the core GnuTLS library is released under LGPL, this extra
+# library uses GPL and as such, the terms of GPL apply to the combination
+# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
+# apply for distribution of the resulting binary.
+#CONFIG_GNUTLS_EXTRA=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for old DBus control interface
+# (fi.epitest.hostap.WPASupplicant)
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for new DBus control interface
+# (fi.w1.hostap.wpa_supplicant1)
+#CONFIG_CTRL_IFACE_DBUS_NEW=y
+
+# Add introspection support for new DBus control interface
+#CONFIG_CTRL_IFACE_DBUS_INTRO=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+#CONFIG_DEBUG_FILE=y
+
+# Enable privilege separation (see README 'Privilege separation' for details)
+#CONFIG_PRIVSEP=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, comment out these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, comment out these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
+
+NEED_80211_COMMON=y
+
+CONFIG_IBSS_RSN=y
diff -purN hostapd-20130302/wpa_supplicant/config.c hostapd-20130302-linux/wpa_supplicant/config.c
--- hostapd-20130302/wpa_supplicant/config.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/config.c	2013-07-04 11:17:51.000000000 -0400
@@ -14,6 +14,7 @@
 #include "rsn_supp/wpa.h"
 #include "eap_peer/eap.h"
 #include "p2p/p2p.h"
+#include "drivers/nl80211_copy.h"
 #include "config.h"
 
 
@@ -1369,6 +1370,162 @@ static char * wpa_config_write_p2p_clien
 
 #endif /* CONFIG_P2P */
 
+static int wpa_config_parse_mcast_rate(const struct parse_data *data,
+				       struct wpa_ssid *ssid, int line,
+				       const char *value)
+{
+	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
+
+	return 0;
+}
+
+#ifndef NO_CONFIG_WRITE
+static char * wpa_config_write_mcast_rate(const struct parse_data *data,
+					  struct wpa_ssid *ssid)
+{
+	char *value;
+	int res;
+
+	if (!ssid->mcast_rate == 0)
+		return NULL;
+
+	value = os_malloc(6); /* longest: 300.0 */
+	if (value == NULL)
+		return NULL;
+	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
+	if (res < 0) {
+		os_free(value);
+		return NULL;
+	}
+	return value;
+}
+#endif /* NO_CONFIG_WRITE */
+
+static int wpa_config_parse_htmode(const struct parse_data *data,
+				   struct wpa_ssid *ssid, int line,
+				   const char *value)
+{
+	int i;
+	static const struct {
+		const char *name;
+		unsigned int val;
+	} htmap[] = {
+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
+		{ .name = "NOHT", .val = NL80211_CHAN_NO_HT, },
+	};
+	ssid->ht_set = 0;;
+	for (i = 0; i < 4; i++) {
+		if (strcasecmp(htmap[i].name, value) == 0) {
+			ssid->htmode = htmap[i].val;
+			ssid->ht_set = 1;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+#ifndef NO_CONFIG_WRITE
+static char * wpa_config_write_htmode(const struct parse_data *data,
+				      struct wpa_ssid *ssid)
+{
+	char *value;
+	int res;
+
+	value = os_malloc(6); /* longest: HT40+ */
+	if (value == NULL)
+		return NULL;
+
+	switch(ssid->htmode) {
+		case NL80211_CHAN_HT20:
+			res = os_snprintf(value, 4, "HT20");
+			break;
+		case NL80211_CHAN_HT40PLUS:
+			res = os_snprintf(value, 5, "HT40+");
+			break;
+		case NL80211_CHAN_HT40MINUS:
+			res = os_snprintf(value, 5, "HT40-");
+			break;
+		case NL80211_CHAN_NO_HT:
+			res = os_snprintf(value, 4, "NOHT");
+			break;
+		default:
+			os_free(value);
+			return NULL;
+	}
+
+	if (res < 0) {
+		os_free(value);
+		return NULL;
+	}
+
+	return value;
+}
+#endif /* NO_CONFIG_WRITE */
+
+
+static int wpa_config_parse_rates(const struct parse_data *data,
+				  struct wpa_ssid *ssid, int line,
+				  const char *value)
+{
+	int i;
+	char *pos, *r, *sptr, *end;
+	double rate;
+
+	pos = (char *)value;
+	r = strtok_r(pos, ",", &sptr);
+	i = 0;
+	while (pos && i < NL80211_MAX_SUPP_RATES) {
+		rate = 0.0;
+		if (r)
+			rate = strtod(r, &end);
+		ssid->rates[i] = rate * 2;
+		if (*end != '\0' || rate * 2 != ssid->rates[i])
+			return 1;
+
+		i++;
+		r = strtok_r(NULL, ",", &sptr);
+	}
+
+	return 0;
+}
+
+#ifndef NO_CONFIG_WRITE
+static char * wpa_config_write_rates(const struct parse_data *data,
+				     struct wpa_ssid *ssid)
+{
+	char *value, *pos;
+	int res, i;
+
+	if (ssid->rates[0] <= 0)
+		return NULL;
+
+	value = os_malloc(6 * NL80211_MAX_SUPP_RATES + 1);
+	if (value == NULL)
+		return NULL;
+	pos = value;
+	for (i = 0; i < NL80211_MAX_SUPP_RATES - 1; i++) {
+		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
+		if (res < 0) {
+			os_free(value);
+			return NULL;
+		}
+		pos += res;
+	}
+	res = os_snprintf(pos, 6, "%.1f",
+			  (double)ssid->rates[NL80211_MAX_SUPP_RATES - 1] / 2);
+	if (res < 0) {
+		os_free(value);
+		return NULL;
+	}
+
+	value[6 * NL80211_MAX_SUPP_RATES] = '\0';
+	return value;
+}
+#endif /* NO_CONFIG_WRITE */
+
 /* Helper macros for network block parser */
 
 #ifdef OFFSET
@@ -1546,6 +1703,10 @@ static const struct parse_data ssid_fiel
 	{ INT(ap_max_inactivity) },
 	{ INT(dtim_period) },
 	{ INT(beacon_int) },
+	{ INT_RANGE(fixed_freq, 0, 1) },
+	{ FUNC(rates) },
+	{ FUNC(mcast_rate) },
+	{ FUNC(htmode) },
 };
 
 #undef OFFSET
diff -purN hostapd-20130302/wpa_supplicant/config_ssid.h hostapd-20130302-linux/wpa_supplicant/config_ssid.h
--- hostapd-20130302/wpa_supplicant/config_ssid.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/config_ssid.h	2013-07-04 11:17:51.000000000 -0400
@@ -11,6 +11,7 @@
 
 #include "common/defs.h"
 #include "eap_peer/eap_config.h"
+#include "drivers/nl80211_copy.h"
 
 #define MAX_SSID_LEN 32
 
@@ -571,6 +572,12 @@ struct wpa_ssid {
 	 * dereferences since it may not be updated in all cases.
 	 */
 	void *parent_cred;
+
+	int fixed_freq;
+	unsigned char rates[NL80211_MAX_SUPP_RATES];
+	double mcast_rate;
+	int ht_set;
+	unsigned int htmode;
 };
 
 #endif /* CONFIG_SSID_H */
diff -purN hostapd-20130302/wpa_supplicant/ctrl_iface.c hostapd-20130302-linux/wpa_supplicant/ctrl_iface.c
--- hostapd-20130302/wpa_supplicant/ctrl_iface.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/ctrl_iface.c	2013-07-04 11:17:51.000000000 -0400
@@ -4933,6 +4933,7 @@ char * wpa_supplicant_ctrl_iface_process
 			reply_len = -1;
 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "MIB") == 0) {
 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
 		if (reply_len >= 0) {
@@ -4944,6 +4945,7 @@ char * wpa_supplicant_ctrl_iface_process
 			else
 				reply_len += res;
 		}
+#endif
 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
 		reply_len = wpa_supplicant_ctrl_iface_status(
 			wpa_s, buf + 6, reply, reply_size);
@@ -5350,6 +5352,7 @@ char * wpa_supplicant_ctrl_iface_process
 		reply_len = wpa_supplicant_ctrl_iface_bss(
 			wpa_s, buf + 4, reply, reply_size);
 #ifdef CONFIG_AP
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
@@ -5358,6 +5361,7 @@ char * wpa_supplicant_ctrl_iface_process
 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
 						   reply_size);
+#endif
 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
 			reply_len = -1;
diff -purN hostapd-20130302/wpa_supplicant/events.c hostapd-20130302-linux/wpa_supplicant/events.c
--- hostapd-20130302/wpa_supplicant/events.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/events.c	2013-07-04 11:17:51.000000000 -0400
@@ -2333,8 +2333,8 @@ static void wpa_supplicant_event_unprot_
 }
 
 
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data)
+void supplicant_event(void *ctx, enum wpa_event_type event,
+		      union wpa_event_data *data)
 {
 	struct wpa_supplicant *wpa_s = ctx;
 	u16 reason_code = 0;
diff -purN hostapd-20130302/wpa_supplicant/main.c hostapd-20130302-linux/wpa_supplicant/main.c
--- hostapd-20130302/wpa_supplicant/main.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/main.c	2013-07-04 11:17:51.000000000 -0400
@@ -12,6 +12,7 @@
 #endif /* __linux__ */
 
 #include "common.h"
+#include "build_features.h"
 #include "wpa_supplicant_i.h"
 #include "driver_i.h"
 
@@ -25,7 +26,7 @@ static void usage(void)
 	       "usage:\n"
 	       "  wpa_supplicant [-BddhKLqqstuvW] [-P<pid file>] "
 	       "[-g<global ctrl>] \\\n"
-	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
+	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>]"
 	       "[-p<driver_param>] \\\n"
 	       "        [-b<br_ifname>] [-f<debug file>] [-e<entropy file>] "
 	       "\\\n"
@@ -67,6 +68,7 @@ static void usage(void)
 #endif /* CONFIG_DEBUG_LINUX_TRACING */
 	printf("  -t = include timestamp in debug messages\n"
 	       "  -h = show this help text\n"
+		   "  -H = connect to a hostapd instance to manage state changes\n"
 	       "  -L = show license (BSD)\n"
 	       "  -o = override driver parameter for new interfaces\n"
 	       "  -O = override ctrl_interface parameter for new interfaces\n"
@@ -155,7 +157,7 @@ int main(int argc, char *argv[])
 
 	for (;;) {
 		c = getopt(argc, argv,
-			   "b:Bc:C:D:de:f:g:hi:KLNo:O:p:P:qsTtuvW");
+			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuv::W");
 		if (c < 0)
 			break;
 		switch (c) {
@@ -199,6 +201,9 @@ int main(int argc, char *argv[])
 			usage();
 			exitcode = 0;
 			goto out;
+		case 'H':
+			iface->hostapd_ctrl = optarg;
+			break;
 		case 'i':
 			iface->ifname = optarg;
 			break;
@@ -244,8 +249,12 @@ int main(int argc, char *argv[])
 			break;
 #endif /* CONFIG_DBUS */
 		case 'v':
-			printf("%s\n", wpa_supplicant_version);
-			exitcode = 0;
+			if (optarg) {
+				exitcode = !has_feature(optarg);
+			} else {
+				printf("%s\n", wpa_supplicant_version);
+				exitcode = 0;
+			}
 			goto out;
 		case 'W':
 			params.wait_for_monitor++;
diff -purN hostapd-20130302/wpa_supplicant/Makefile hostapd-20130302-linux/wpa_supplicant/Makefile
--- hostapd-20130302/wpa_supplicant/Makefile	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/Makefile	2013-07-06 06:13:59.000000000 -0400
@@ -13,7 +13,12 @@ PKG_CONFIG ?= pkg-config
 CFLAGS += -I../src
 CFLAGS += -I../src/utils
 
+ifdef MULTICALL
+CFLAGS += -DMULTICALL
+endif
+
 -include .config
+-include $(if $(MULTICALL),../hostapd/.config)
 
 BINALL=wpa_supplicant wpa_cli
 
@@ -75,6 +80,10 @@ OBJS_c = wpa_cli.o ../src/common/wpa_ctr
 OBJS_c += ../src/utils/wpa_debug.o
 OBJS_c += ../src/utils/common.o
 
+ifdef MULTICALL
+OBJS += ../src/common/wpa_ctrl.o
+endif
+
 ifndef CONFIG_OS
 ifdef CONFIG_NATIVE_WINDOWS
 CONFIG_OS=win32
@@ -704,6 +713,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
 CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
 LIBS += -ldl -rdynamic
 endif
+else
+  ifdef MULTICALL
+    OBJS += ../src/eap_common/eap_common.o
+  endif
 endif
 
 ifdef CONFIG_AP
@@ -712,9 +725,11 @@ NEED_EAP_COMMON=y
 NEED_RSN_AUTHENTICATOR=y
 CFLAGS += -DCONFIG_AP
 OBJS += ap.o
+ifndef MULTICALL
 CFLAGS += -DCONFIG_NO_RADIUS
 CFLAGS += -DCONFIG_NO_ACCOUNTING
 CFLAGS += -DCONFIG_NO_VLAN
+endif
 OBJS += ../src/ap/hostapd.o
 OBJS += ../src/ap/wpa_auth_glue.o
 OBJS += ../src/ap/utils.o
@@ -739,6 +754,9 @@ ifdef CONFIG_WNM
 OBJS += ../src/ap/wnm_ap.o
 endif
 ifdef CONFIG_CTRL_IFACE
+ifdef CONFIG_CTRL_IFACE_MIB
+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
+endif
 OBJS += ../src/ap/ctrl_iface_ap.o
 endif
 
@@ -769,10 +787,18 @@ endif
 ifdef CONFIG_HS20
 OBJS += ../src/ap/hs20.o
 endif
+else
+  ifdef MULTICALL
+    OBJS += ../src/eap_server/eap_server.o
+    OBJS += ../src/eap_server/eap_server_identity.o
+    OBJS += ../src/eap_server/eap_server_methods.o
+  endif
 endif
 
 ifdef NEED_RSN_AUTHENTICATOR
+ifndef MULTICALL
 CFLAGS += -DCONFIG_NO_RADIUS
+endif
 NEED_AES_WRAP=y
 OBJS += ../src/ap/wpa_auth.o
 OBJS += ../src/ap/wpa_auth_ie.o
@@ -1521,6 +1547,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
 
 $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
 
+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
+	@$(E) "  CC " $<
+	@rm -f $@
+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
+
 wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
 	@$(E) "  LD " $@
@@ -1591,6 +1623,12 @@ eap_ikev2.so: ../src/eap_peer/eap_ikev2.
 %@.service: %.service.arg.in
 	sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
 
+dump_cflags:
+	@echo -n $(CFLAGS) " "
+
+dump_ldflags:
+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
+
 wpa_supplicant.exe: wpa_supplicant
 	mv -f $< $@
 wpa_cli.exe: wpa_cli
diff -purN hostapd-20130302/wpa_supplicant/wpa_priv.c hostapd-20130302-linux/wpa_supplicant/wpa_priv.c
--- hostapd-20130302/wpa_supplicant/wpa_priv.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/wpa_priv.c	2013-07-04 11:17:51.000000000 -0400
@@ -819,8 +819,8 @@ static void wpa_priv_send_ft_response(st
 }
 
 
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data)
+static void supplicant_event(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data)
 {
 	struct wpa_priv_interface *iface = ctx;
 
@@ -962,6 +962,7 @@ int main(int argc, char *argv[])
 	if (os_program_init())
 		return -1;
 
+	wpa_supplicant_event = supplicant_event;
 	wpa_priv_fd_workaround();
 
 	for (;;) {
diff -purN hostapd-20130302/wpa_supplicant/wpa_supplicant.c hostapd-20130302-linux/wpa_supplicant/wpa_supplicant.c
--- hostapd-20130302/wpa_supplicant/wpa_supplicant.c	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/wpa_supplicant.c	2013-07-04 11:17:51.000000000 -0400
@@ -107,6 +107,55 @@ extern int wpa_debug_show_keys;
 extern int wpa_debug_timestamp;
 extern struct wpa_driver_ops *wpa_drivers[];
 
+#ifdef MULTICALL
+static int hostapd_stop(struct wpa_supplicant *wpa_s)
+{
+	const char *cmd = "DOWN";
+	char buf[256];
+	int len = sizeof(buf);
+
+	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
+		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
+{
+	char *cmd = NULL;
+	char buf[256];
+	int len = sizeof(buf);
+	int channel, hw_mode;
+	int ret;
+
+	if (!bss)
+		return;
+
+	if (bss->freq < 4000) {
+		hw_mode = HOSTAPD_MODE_IEEE80211G;
+		channel = (bss->freq - 2407) / 5;
+	} else {
+		hw_mode = HOSTAPD_MODE_IEEE80211A;
+		channel = (bss->freq - 5000) / 5;
+	}
+
+	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=0 hw_mode=%d ieee80211n=%d",
+		     channel, hw_mode, !!bss->ht_capab) < 0) {
+		return -1;
+	}
+
+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
+	free(cmd);
+
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
+		return -1;
+	}
+	return 0;
+}
+#endif
+
 /* Configure default/group WEP keys for static WEP */
 int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
 {
@@ -676,8 +725,16 @@ void wpa_supplicant_set_state(struct wpa
 #endif /* CONFIG_P2P */
 
 		sme_sched_obss_scan(wpa_s, 1);
+#ifdef MULTICALL
+		if (wpa_s->hostapd)
+			hostapd_reload(wpa_s, wpa_s->current_bss);
+#endif
 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
 		   state == WPA_ASSOCIATED) {
+#ifdef MULTICALL
+		if (wpa_s->hostapd)
+			hostapd_stop(wpa_s);
+#endif
 		wpa_s->new_connection = 1;
 		wpa_drv_set_operstate(wpa_s, 0);
 #ifndef IEEE8021X_EAPOL
@@ -1513,15 +1570,26 @@ void wpa_supplicant_associate(struct wpa
 		params.ssid_len = ssid->ssid_len;
 	}
 
-	if (ssid->mode == WPAS_MODE_IBSS && ssid->bssid_set &&
-	    wpa_s->conf->ap_scan == 2) {
-		params.bssid = ssid->bssid;
-		params.fixed_bssid = 1;
+	if (ssid->mode == WPAS_MODE_IBSS) {
+		if (ssid->bssid_set && wpa_s->conf->ap_scan == 2) {
+			params.bssid = ssid->bssid;
+			params.fixed_bssid = 1;
+		}
+		if (ssid->frequency > 0 && params.freq == 0)
+			/* Initial channel for IBSS */
+			params.freq = ssid->frequency;
+		params.fixed_freq = ssid->fixed_freq;
+		params.beacon_interval = ssid->beacon_int;
+		i = 0;
+		while (i < NL80211_MAX_SUPP_RATES) {
+			params.rates[i] = ssid->rates[i];
+			i++;
+		}
+		params.mcast_rate = ssid->mcast_rate;
+		params.ht_set = ssid->ht_set;
+		params.htmode = ssid->htmode;
 	}
 
-	if (ssid->mode == WPAS_MODE_IBSS && ssid->frequency > 0 &&
-	    params.freq == 0)
-		params.freq = ssid->frequency; /* Initial channel for IBSS */
 	params.wpa_ie = wpa_ie;
 	params.wpa_ie_len = wpa_ie_len;
 	params.pairwise_suite = cipher_pairwise;
@@ -2416,7 +2484,7 @@ static struct wpa_supplicant * wpa_suppl
 	if (wpa_s == NULL)
 		return NULL;
 	wpa_s->scan_req = INITIAL_SCAN_REQ;
-	wpa_s->scan_interval = 5;
+	wpa_s->scan_interval = 1;
 	wpa_s->new_connection = 1;
 	wpa_s->parent = wpa_s;
 	wpa_s->sched_scanning = 0;
@@ -2778,6 +2846,21 @@ static int wpa_supplicant_init_iface(str
 		os_strlcpy(wpa_s->bridge_ifname, iface->bridge_ifname,
 			   sizeof(wpa_s->bridge_ifname));
 	}
+#ifdef MULTICALL
+	if (iface->hostapd_ctrl) {
+		char *cmd = "DOWN";
+		char buf[256];
+		int len = sizeof(buf);
+
+		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
+		if (!wpa_s->hostapd) {
+			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
+			return -1;
+		}
+		if (hostapd_stop(wpa_s) < 0)
+			return -1;
+	}
+#endif
 
 	/* RSNA Supplicant Key Management - INITIALIZE */
 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
@@ -2972,6 +3055,9 @@ static void wpa_supplicant_deinit_iface(
 	}
 }
 
+extern void supplicant_event(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
+
 
 /**
  * wpa_supplicant_add_iface - Add a new network interface
@@ -3164,6 +3250,7 @@ struct wpa_global * wpa_supplicant_init(
 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
 #endif /* CONFIG_NO_WPA_MSG */
 
+	wpa_supplicant_event = supplicant_event;
 	wpa_debug_open_file(params->wpa_debug_file_path);
 	if (params->wpa_debug_syslog)
 		wpa_debug_open_syslog();
diff -purN hostapd-20130302/wpa_supplicant/wpa_supplicant_i.h hostapd-20130302-linux/wpa_supplicant/wpa_supplicant_i.h
--- hostapd-20130302/wpa_supplicant/wpa_supplicant_i.h	2013-03-04 09:34:02.000000000 -0500
+++ hostapd-20130302-linux/wpa_supplicant/wpa_supplicant_i.h	2013-07-04 11:17:51.000000000 -0400
@@ -96,6 +96,8 @@ struct wpa_interface {
 	 * receiving of EAPOL frames from an additional interface.
 	 */
 	const char *bridge_ifname;
+
+	const char *hostapd_ctrl;
 };
 
 /**
@@ -305,6 +307,8 @@ struct wpa_supplicant {
 #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
 	char bridge_ifname[16];
 
+	struct wpa_ctrl *hostapd;
+
 	char *confname;
 	struct wpa_config *conf;
 	int countermeasures;
